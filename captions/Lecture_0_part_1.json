[{"text":"Let's do another one","width":182.18181824684143},{"text":"Let's look for fork - create a child process. Yes, that's right, you create children by forking","width":922.1818182468414},{"text":"I knew you'd remember something from this lecture. We'll play more with this later because it's an amazing thing you can do with posix. You're first process can actually clone itself, at that very moment to become two separate processes","width":1220.1818182468414},{"text":"It's like you pull a switch and suddenly you've got a doppelganger","width":347.18181824684143},{"text":"If you're a physicist and you think about the many worlds theorem, it's a bit like that. The world from a process point of view splits into two. Suddenly you've got two processes for the price of one","width":681.1818182468414},{"text":"OK, so we'll see that. But again, notice we had different sections","width":265.18181824684143},{"text":"The sections you're going to see are.... can you see this? let's see if we can make it bigger","width":721.1818182468414},{"text":"section two, alright. This is where all the system calls live","width":368.18181824684143},{"text":"section three, this is where you'll find the C library stuff","width":274.18181824684143},{"text":"and section seven, you'll occasionally find there's actually longer articles. I hesitate to call them tutorials, they're not that useful","width":668.1818182468414},{"text":"but more long winded articles that have some better practices. it's worth reading at some point during this course","width":472.18181824684143},{"text":"you might find some useful information there. for example, when we talk about signals, but most of the time you'll be using these as reference","width":496.18181824684143},{"text":"unfortunately, let's go back to here and look up stat. some words appear in multiple places and if I make a new window here","width":970.1818182468414},{"text":"and I do man stat, then I get the wrong one. I get the one that would happen from the shell. So i have to say 'no, no, no I really wanted section two'","width":942.1818182468414},{"text":"so sometimes you have to force it to find the right section","width":410.18181824684143},{"text":"that's enough about man pages. you will be using them. when it comes to quizzes, i'll talk more about that later, but i will have expected you to know something basic about the return values, some of the common gotchas of using different calls","width":1074.1818182468414},{"text":"do you remember how to allocate memory on the heap?","width":398.18181824684143},{"text":"if your neighbor said 'malloc' congratulations, you made a good seating choice","width":356.18181824684143},{"text":"yes, malloc is one way to say 'hey, I need some memory and it's mine until I what?'","width":855.1818182468414},{"text":"free it, yes! ","width":216.18181824684143},{"text":"when you call malloc you are going to point to some bytes. will those bytes be zero?","width":787.1818182468414},{"text":"do you feel lucky punk? the answer is maybe, but it's not guaranteed. ","width":411.18181824684143},{"text":"if you get a brand new, fresh page of memory from the OS it's likely to have been zeroed out by the OS to make sure you don't accidently get any information from another process","width":831.1818182468414},{"text":"remember, we're trying to keep our processes separate, so you can't accidentally read someone else's password, or secret key, or something else that's secretly happening inside another process","width":550.1818182468414},{"text":"the OS makes sure to usually give you some zeroed memory","width":315.18181824684143},{"text":"however, if it's reuse of your own memory, it's quite likely there's just garbage in there","width":493.18181824684143},{"text":"it could be that because it's zero it lulls you into a false sense of security, you assume memory is zero","width":606.1818182468414},{"text":"why did C do this? sounds like a terrible thing to put the onus on programmers to make sure their programs always work. why didn't they always zero out the memory?","width":941.1818182468414},{"text":"time consuming, yes! C is all about trying to be as efficient as possible and if you can't cope with that, get a different major","width":725.1818182468414},{"text":"That is C's attitude, maybe we can find tools to spot memory errors, but it's very much a case of we're trying to write a language which is just a little bit above assembler. it's meant to be that it's almost as efficient as assembly code, just a lot easier to read and write","width":1409.1818182468414},{"text":"malloc has to be very efficient because we use it a lot. think about your java programs, OK I'm sorry. I know that was a bad experience, but think about all the times you've made new objects, etc.","width":832.1818182468414},{"text":"underneath that we're saying 'OK, I need some more memory'","width":275.18181824684143},{"text":"so malloc's job is to find some bytes. you say 'oh quick, I need another thirty two bytes and I need it right now. I can't continue my process untiil you give me thirty two bytes fo rme to play with. And, yes, I promise to free it later when I'm finished with it.'","width":960.1818182468414},{"text":"some processes are allocating a lot of memory all the time. so malloc tries to be efficient and when you free some memory, we can put it back into this pool of bytes that we can use later again. That's why it's called a heap, it's just going to be a big disorganized mess of allocated space and unallocated space","width":1346.1818182468414},{"text":"And, in fact, it's tricky to write malloc and free, so we are going to ask you to do it in 241","width":491.18181824684143},{"text":"we've got malloc and free. later on you'll also see halloc and realloc, but let's not talk about those now","width":580.1818182468414},{"text":"you can just implement those on top of malloc","width":389.18181824684143},{"text":"suppose we wanted to write our own string copy function. here it is!","width":561.1818182468414},{"text":"because these are character pointers, I should mention, how big is a character in C? ","width":638.1818182468414},{"text":"the size of a single [byte]","width":221.18181824684143},{"text":"if I do sizeof character,the answer is one. everywhere, at all times, before I even compile the code. it's a definition that the size of a character type is one","width":1079.1818182468414},{"text":"sizeof gives you the number of bytes","width":416.18181824684143},{"text":"so a character is always one byte. If i put a variable name in there I'd get one","width":618.1818182468414},{"text":"when I add one to these pointers, it is going to be incrementing along one byte at a time. I read one byte and I add one to the source pointer and add one to the destination pointer","width":901.1818182468414},{"text":"this code is slightly broken. perhaps you and your neighbor can figure out how it should be fixed. i'll point out the following","width":742.1818182468414},{"text":"what does this do? while star source","width":363.18181824684143},{"text":"thank you, yes! remember star means dereference, follow the money, take this expression and use it as a memory pointer and actually tell me what's in there","width":649.1818182468414},{"text":"because we're talking about a character pointer, we are asking memory to read just one byte. if we had an int pointer we might be reading four or eight bytes","width":553.1818182468414},{"text":"but, no, we're reading one byte. while this is non-zero, do something. with C, anything which is a non-zero value is true","width":686.1818182468414},{"text":"what a wonderful simple world","width":189.18181824684143}]