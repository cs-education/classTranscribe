// Data structure that holds captions for the videos
var videoCaptions =[
  // Video 1
  [{"text":"Okay welcome to systems programming","width":200},{"text":"so let's get started","width":51},{"text":"let's write our first c program","width":103},{"text":"that makes use of a system call","width":144},{"text":"i'll do an example and then I'll let you play as well","width":219},{"text":"so uh here's a little virtual machine","width":146},{"text":"i've got up and running","width":122},{"text":"and i can write a little c file here","width":158},{"text":"so what we're going to do is make use of a system call called write","width":306},{"text":"so let's try this","width":52},{"text":"we'll say okay write","width":102},{"text":"and then i need to give it a file descriptor","width":213},{"text":"more about that in a moment","width":84},{"text":"a little message like hello","width":201},{"text":"and then the number of characters or bytes that i actually want to send here","width":267},{"text":"so h e l l o","width":179},{"text":"that's five bytes we're going to send","width":238},{"text":"so let's try compiling this","width":203},{"text":"and once that's going we'll see that whoops","width":233},{"text":"we've got a little bit of a problem here","width":118},{"text":"that write was not declared before","width":248},{"text":"okay so the c compiler here is warning us that we're trying to call a function called write which hasn't yet been declared","width":538},{"text":"so we could declare it","width":109},{"text":"now i happen to know for example that the write signature looks a little something like this","width":261},{"text":"it takes um, it's called write ","width":200},{"text":"it takes a file descriptor which is going to be an integer","width":161},{"text":"it takes a pointer to a character","width":183},{"text":"and it takes another integer which is the number of characters to write","width":273},{"text":"so it looks a little bit like that","width":97},{"text":"in fact it takes a void pointer which means point to it without any particular type","width":600},{"text":"so i could attempt to compile this for example","width":220},{"text":"see if this works","width":152},{"text":"and oh ho ho","width":34},{"text":"if we look at the left hand side","width":80},{"text":"we can see we managed to compile a program called program here","width":252},{"text":"and when we ran it we got hello","width":102},{"text":"alright so let's do a little better then that though","width":240},{"text":"rather than me having to manually write the declaration in here","width":313},{"text":"these are already included inside an existing file which I get for free","width":326},{"text":"it's actually unistd.h","width":229},{"text":"okay so let's tell the preprocessor to read in the contents of the file","width":251},{"text":"go in and find a file named unistd.h","width":179},{"text":"and include all the text that is in that file","width":179},{"text":"okay so now when we run this","width":193},{"text":"we'll compile it and run it and great it prints out hello","width":167},{"text":"if i wanted to print out hello with a new line","width":194},{"text":"let's increment this to six","width":154},{"text":"and now i've got a program called Hello","width":166},{"text":"okay great and of course i could make my program print out hello world and do it on two different lines","width":752},{"text":"alright so uh that's my program working","width":171},{"text":"now it's time for you to play","width":120},{"text":"you create which uses a system call write","width":237},{"text":"to write a little message on the two lines","width":219},{"text":"see you in the next video after you've said hello to the world","width":255},{"text":"bye","width":133}],
  // Video 2
  [{"text":"so let's talk more about that file descriptor","width":185},{"text":"I'm gonna make my program be a little bit more useful by printing out \"Hello World\" a few times","width":325},{"text":"so for example, I have a variable 'count' here and a little for-loop","width":335},{"text":"Start with count equal to five, while count is greater than zero","width":275},{"text":"each time around the loop we're going to decrement 'count'","width":270},{"text":"In C, there is no boolean type.","width":183},{"text":"instead, if I've got an integer value which is nonzero, that is treated as a true value","width":385},{"text":"So, I could actually write this more tersely just by saying \"hey, count!\"","width":323},{"text":"meaning is count a non-zero value","width":193},{"text":"and if you compare two things, you'll learn that with an integer value of either 0 or 1 to mean for example if they are either the same or different","width":497},{"text":"so, we're going to print out \"hello world\" 5 times","width":442},{"text":"I want to show you just a little idea here that actually I've got two file descriptors which are valid when my program starts.","width":519},{"text":"And they're called 1 and 2.","width":174},{"text":"Why might it be useful to have two output streams?","width":236},{"text":"well, you can imagine we have a program that is calculating something","width":266},{"text":"for example it's thinking of something to say or it's going to write to a file","width":282},{"text":"but we may also want to display some error messages back to the user","width":190},{"text":"or we might want to print some progress information","width":360},{"text":"the first output stream identified by the number '1' is the regular output, standard output","width":456},{"text":"The second one is reserved for error messages.","width":354},{"text":"Let's, for example, use this. Instead of error messages, we'll put a little dot to see this","width":419},{"text":"We'll run this and we should (if we got everything correct) see \"Hello\" and...lib lib lib lib","width":771},{"text":"Now, why do we see \".lib\", because we said \"hey, I'm going to give you a pointer and I want you to use that pointer and take the next 6 bytes from it which is the next  six character","width":886},{"text":"So we just got whatever happened to be in memory after our dot. So, we only wanted to do the dot","width":646},{"text":"Change that and run it again","width":195},{"text":"And great, we've got Hello and dot Hello dot Hello","width":195},{"text":"So, right now, both the output and the standard error are going to different places","width":352},{"text":"we could actually change that over here in the console before we start the program","width":277},{"text":"Our terminal can actually control where the output goes","width":256},{"text":"So, for example, I might say, I want to take the standard output and put that into a file.","width":344},{"text":"So, \"output.txt\"","width":153},{"text":"So now, if I run this before the program starts, I'm going to redirect it's output into this new file","width":531},{"text":"Okay, so what we see on the console output is anything written to standard error","width":308},{"text":"The standard output is inside output.txt","width":196},{"text":"To prove it, let me have a look at that file.","width":205},{"text":"Let me cat that file","width":94},{"text":"So, output.txt","width":145},{"text":"And here it is! It says \"hello, hello, hello, hello\"","width":239},{"text":"Now, rather than writing 1 and 2 over here, perhaps we should actually have some constants","width":359},{"text":"which signify what those values actually mean","width":238},{"text":"so we could say start define things to say have a constant here, I'll call it say \"STDOUT_FILENO 1\"","width":707},{"text":"And I'll say define STDERRFILENO 2","width":480},{"text":"so anytime you do hash define, you're talking to the preprocessor to say \"hey, in the future, parts of this file, if you come across this character sequence, then replace it (in this case) with either a 1 or a 2 depending on what it is\"","width":1084},{"text":"We can compile this, except I've got a surprise for you which is that these particular macros are already defined inside unistd.h","width":705},{"text":"So, I don't actually need to define them here in my program.","width":302},{"text":"So that's my little program. You see it's got a return value of zero. Which is a convention for being correct (no errors)","width":636},{"text":"But it's up to us. We could choose a different value, for example we could choose the value 42.","width":555},{"text":"And, I don't see an output value, but I can find out what the last exit value was of the last process","width":569},{"text":"Let me print it out","width":133},{"text":"It happens to be inside special variables","width":140},{"text":"so I could say \"Hello terminal value of this dollar question mark.\"","width":308},{"text":"which means give me the exit value (or the exit status) of the last command run.","width":347},{"text":"So there's our forty-two.","width":153},{"text":"Okay so, we've covered quite a bit of ground. We've talked about how in C, any non-zero integer is considered \"true\"","width":804},{"text":"and zero is considered \"false\"","width":235},{"text":"And, we've talked about these two different output streams. Now it's your turn to play with this. After that, let's have a go at creating some new files directly from C","width":831},{"text":"by making system calls","width":160},{"text":"So, now it's your turn. Have fun playing! Bye.","width":300}],
  // Video 3
  [{"text":"Welcome so let's start creating some files","width":334},{"text":"for that we can use the system call open()","width":194},{"text":"and for open we need to say whether we want to append to an existing file, create a brand new file, and we need to give it a filename","width":683},{"text":"For example, I might have a file name called \"output.txt\"","width":396},{"text":"so the open call takes 2 or 3 arguments. the second argument will be exactly what we want to do","width":557},{"text":"so in this case we want to say create a brand new file and truncate it back to 0 if it doesn't exist","width":469},{"text":"so, I want to truncate as well","width":237},{"text":"if we are creating a new file we better say who can read this file and who can write to this file and who can execute this file","width":533},{"text":"so we are going to have to say something about the mode flags ","width":346},{"text":"who is allowed to do what","width":89},{"text":"finally this call is going to give us back an integer, a file descriptor","width":272},{"text":"just like we've seen so far with file number 1 and file number 2","width":211},{"text":"so lets store that inside a little variable","width":219},{"text":"ok, so now I better actually find out what the correct syntax is","width":374},{"text":"and the correct arguments are in order to create a file","width":301},{"text":"so lets go and look that up","width":153},{"text":"and that we'll find inside the manual","width":187},{"text":"And, if, for example, I type \"man open\" on a command line on a real linux machine. it doesn't quite work yet in my small virtual one. we didn't have enough memory to include all the manual pages yet","width":887},{"text":"but heres a linux manual page I found on the web for the open()","width":342},{"text":"and you'll see here's the function signature here","width":301},{"text":"where we're going to pass in an integer for the flags and the mode type","width":297},{"text":"so, I'm going to look up now the flags I need to open and create a new file","width":463},{"text":"I don't want to do append()","width":106},{"text":"I want to use \"create\" and I want to truncate it as well","width":404},{"text":"let's include \"O_CREAT\" here. I'm going to say \"O_CREAT\" which is a constant and I'm going to bitwise OR it with the flag to say \"truncate\" so let's look that up as well","width":1309},{"text":"alright and i want to say when i open it that i am going to open it for say reading and writing","width":592},{"text":"so let us grab that as well","width":220},{"text":"so that is the first thing","width":160},{"text":"now we need to do the mode","width":109},{"text":"Let's write this as a variable.","width":134},{"text":"and there is actually a typedef","width":192},{"text":"it is essentially an integer but it is wrapped up in this type here called mode","width":520},{"text":"mode_t","width":79},{"text":"and we'll say that with our file we want to be fairly private and only the owner of the file can access it","width":594},{"text":"Let's go back up and find those flags, where are you? Here we go.","width":387},{"text":"We'll say that the user has read and write permission","width":343},{"text":"We'll copy the read one and we'll have write permission as well.","width":839},{"text":"But no one else in my linux system will be allowed to read it and write it.","width":476},{"text":"So that's the permissions we want","width":216},{"text":"What can we do with this?","width":82},{"text":"Well let's write something out to this file.","width":473},{"text":"We will write a little message \"Great!\" and a newline","width":506},{"text":"so how many characters is that? I've got \"one, two, three, four, five, six, and a new line so that's seven characters\"","width":612},{"text":"then we'll close this file descriptor meaning we don't want to use this descriptor anymore","width":436},{"text":"that will ensure as well that all of the bytes that we send to the file stream have been saved","width":621},{"text":"We're not doing any error checking right now, we're just trying to write the smallest possible program to create a file and send something to it","width":563},{"text":"let's run this and see what we get","width":239},{"text":"we'll run into an error which is: we haven't defined what this mode_t is","width":370},{"text":"what we forgot to do, was to do the includes","width":149},{"text":"the good news is that the man pages tell us which includes we need to put at the top of our program","width":637},{"text":"so let's grab those and insert them in here","width":285},{"text":"i will just get the formatting correct","width":279},{"text":"and, run it again","width":410},{"text":"Right so our program ran and it's still printing \"Hello\" to standard out and dot to standard error","width":418},{"text":"but hopefully, it also secretly created another file","width":215},{"text":"let's have a look at that file","width":136},{"text":"I can do \"ls\" and see if anything exists starting with \"out\"","width":493},{"text":"yes we've got output.txt. great!","width":140},{"text":"let's look at the contents of that file","width":154},{"text":"and it says \"Great!\" Fantastic","width":102},{"text":"Right so now it's your turn to play: create a file and see if you can send some bytes to that file.","width":518},{"text":"so you'll be using open(), write(), and close(). Bye.","width":296}],
  // Video 4
  [{"text":"Hello, suppose we want to actually print out some integer values","width":312},{"text":"write() doesn't give us that fuctionality","width":206},{"text":"write() is the low level call that we make to the operating system","width":252},{"text":"to say \"look, here's a pointer to some memory and please take so many bytes from that memory and send it out to a file\"","width":527},{"text":"or, possibly, another device","width":113},{"text":"if we want to change a bit pattern into a sequence of characters because we want to read, say, one-seven for the value seventeen","width":533},{"text":"that's not something that the system does","width":118},{"text":"instead, we've got some C standard library calls that we can call","width":256},{"text":"that do this for us","width":144},{"text":"and they will wrap the call to write()","width":186},{"text":"so as an example, let's try printing something out","width":329},{"text":"we can say \"printf my value is\"","width":387},{"text":"and I can say \"%d\"","width":134},{"text":"this means that the next argument I give in printf() better be an integer value","width":444},{"text":"so the bit pattern we pass to printf() will be treated as an integer","width":294},{"text":"to be displayed","width":73},{"text":"so let's have a little variable called result","width":220},{"text":"and I can say result is sixty five","width":404},{"text":"if I attempt to run this, we're using printf(), we haven't declared it beforehand so we get a warning","width":490},{"text":"to say \"oh, you're just using it.\" and, what we should've done is actually declare the function signature of printf()","width":580},{"text":"and that I know from looking at the man pages","width":248},{"text":"is inside stdio.h","width":195},{"text":"if you're coming from a cpp background, there's no IO streams","width":234},{"text":"we dont have operator overloading. instead, let's use printf()","width":211},{"text":"so we've got \"my value is 65\"","width":153},{"text":"and, you'll see that actually this was printed out after the hello hello hello hello","width":572},{"text":"here's why: printf() has a buffer. the C libraries have a buffer","width":250},{"text":"so it's only going to call write() when that buffer is full","width":248},{"text":"or if we explicitly tell it to","width":103},{"text":"or if we finish a line","width":157},{"text":"so let's put a newline in here and run it again","width":280},{"text":"this time, we've compiled it, and we should see that \"my value is 65\" appear before my hellos","width":523},{"text":"so this time, because we sent a new line, printf() will be making that call to write()","width":443},{"text":"to send its buffer out to standard out","width":347},{"text":"so now we can actually print out the value of our file descriptor","width":318},{"text":"let's do that. after we've opened our file, I'll send \"fildes is\" and, we will print out fildes.","width":1358},{"text":"and, let's get rid of the first one","width":157},{"text":"and let's flush our little buffer by sending in a newline","width":409},{"text":"and we'll see that our value is three","width":363},{"text":"so, we've opened up a file descriptor who's value is three","width":206},{"text":"in fact, that is expected by specification because if we successfully open a file, we'll get back the lowest unused integer (the lowest unused file descriptor)","width":809},{"text":"as one and two are already being used, we get back three","width":215},{"text":"so just for fun, let's actually close one of the existing file descriptors before we do the open()","width":547},{"text":"so let's close standard error","width":235},{"text":"I'm sorry, we'll close standard out","width":252},{"text":"and, we won't close our own file descriptor until the very end of the program here","width":545},{"text":"so I'm going to move that line down to here","width":164},{"text":"great, so, let's run this","width":457},{"text":"so, what did we do? we opened a file descriptor and now if we look at the output of the program, you'll see we're only getting our dots printed out on standard error","width":720},{"text":"why is that?","width":63},{"text":"what happened to our standard output?","width":63},{"text":"well, we better check out file output.text","width":221},{"text":"and you'll see that everything printed to standard out has been sent to our file","width":435},{"text":"why? because when we called open(), it gave us back a file descriptor for stream number one. and, that is the. that is where all the standard output is going to go","width":895},{"text":"so, all future output is being sent to our file","width":250},{"text":"this is a neat way if you'd like to do logging","width":252},{"text":"and we've just changed our program so that all future output goes to output.text","width":459},{"text":"now what if we've got a problem with open() ?","width":199},{"text":"right now, our code doesn't check for any error","width":221},{"text":"and, a better program would actually check the return values of our different calls","width":369},{"text":"for example, it could be that open() could fail. suppose, for example, we gave it a bad file descriptor","width":675},{"text":"now so we can see what's going on, I'm not going to close standard out anymore.","width":316},{"text":"I'm just going to give it a bad file name","width":234},{"text":"now, our program compiles correctly of course","width":192},{"text":"but this time our file descriptor is negative one","width":211},{"text":"so, we should check that","width":215},{"text":"in fact, if we check the man page of open(), it's always a good idea to check the section called \"return value\"","width":475},{"text":"and you'll see, it's specified here that we'll get back a negative one if an error occurred","width":318},{"text":"so the last thing we'll do today is let's capture that and quit if we get a bad error","width":340},{"text":"so, if fildes equals negative one","width":227},{"text":"a common error is to write equals instead of double equals for comparison","width":371},{"text":"and we want to quit here","width":171},{"text":"so we'll leave our program, so let's exit with a value","width":238},{"text":"to say: \"hey, we couldn't carry on\"","width":250},{"text":"I could've returned zero but I wanted to show you an alternative way to quit a C program is to call exit","width":327},{"text":"and we'll print out an error","width":398},{"text":"so, something bad happened while calling open","width":228},{"text":"so, we'll use perror()","width":269},{"text":"let's run this","width":246},{"text":"and, I get some implicit problem here that we're calling exit(). I need to find the right #include to call for that.","width":734},{"text":"but, you'll see on the lefthand side that we've got open() failed, so that's the part of the error message that I supplied","width":487},{"text":"followed by a colon followed by no such file or directories","width":213},{"text":"so it's complaining that my file name is bad","width":292},{"text":"if I had included a dot here, this is also an invalid file name because a single dot corresponds to the current directory","width":542},{"text":"and, it's complaining that it can't open that because dot corresponds to a directory","width":414},{"text":"so now it's your turn to play. bye!","width":240}],
  // Video 5
  [{"text":"Hi, so C is designed to be a portable language in a sense that we could write a C compiler for many many different hardware architectures","width":542},{"text":"from small embedded machines to large mainframes","width":284},{"text":"so C does not specify a precise number of bits required for, say, and integer","width":394},{"text":"instead it specifies minimums that should be supported by the architecture","width":348},{"text":"let's have a look at that. let's see how we can find out how large or small of numbers we can store in different types","width":385},{"text":"and also how many bytes each different type is ","width":209},{"text":"and even further, what is a byte?","width":183},{"text":"so let's start with our integers","width":152},{"text":"I could say hello but what's the largest value I can store inside my integer type?","width":438},{"text":"fortunately, there's some macros, some constants, defined inside limits.h","width":677},{"text":"let's find out what these are","width":209},{"text":"the int min and max is going to be %d and %d and INT_MIN and INT_MAX","width":753},{"text":"so, we'll print that out. I'll get rid of my unnecessary variable here","width":240},{"text":"let's run that","width":91},{"text":"and we see that on this particular machine, that an integer can represent numbers from roughly minus 2 billion to plus 2 billion","width":649},{"text":"a very wide range of numbers","width":135},{"text":"C promises that we'll be able to store the numbers between minus 32768 and plus 32767","width":460},{"text":"in other words, an integer will be at least 16 bits","width":292},{"text":"what else do we have? how about a character?","width":180},{"text":"well, here's a surprising thing, a character is one byte","width":225},{"text":"so what do we mean by byte?","width":113},{"text":"surely we mean 8 bits? no.","width":224},{"text":"though we often say a byte means 8 bits in modern parlance, it doesn't have to be true","width":421},{"text":"and in fact, C is very careful to say that a byte does not mean 8 bits","width":294},{"text":"it means at least 8 bits","width":101},{"text":"our character, then, is at least 8 bits","width":184},{"text":"so why this distinction?","width":122},{"text":"well, in being portable, C needs to be able to read and write every bit inside memory and each bit inside each memory should only live inside one addressable memory location","width":875},{"text":"and, it could be that architecture have very different numbers of bits it can read or write","width":515},{"text":"for example, an early PDP machine had a 36 bit wide addressable memory","width":394},{"text":"so, C does not attempt to say it's going to be exactly 8 bits","width":396},{"text":"so how do we find out how many bits are actually in a character?","width":254},{"text":"well, again, the limits.h includes a useful constants here","width":404},{"text":"a character is %d bytes","width":197},{"text":"let's go and see what that is","width":114},{"text":"so CHAR_BITS","width":129},{"text":"and we'll print that out","width":471},{"text":"on this architecture, a character is 8 bits","width":181},{"text":"that's typical on modern machines","width":283},{"text":"so what if I wanted to know the actual number of bytes in different types?","width":247},{"text":"for that, we have something called sizeof","width":306},{"text":"we can give it a type and it will tell us how many bytes (or if you prefer, how many characters) are required to hold that particular kind","width":468},{"text":"so for example, let's find out how big an integer is on this machine","width":334},{"text":"perhaps you can guess the answer already","width":136},{"text":"so, sizeof int is %d and we'll have a newline as well","width":903},{"text":"is it any surprise that the size of an integer on this particular machine happens to be 4 bytes","width":354},{"text":"and that's not surprising because we need thirty two bits to represent all numbers between minus two billion and plus two billion","width":529},{"text":"there are other integer types you'll see things like short (which is generally shorter than an int), long (which is generally longer), long long (which is even longer, still)","width":843},{"text":"and compilers even occasionally provide their own custom types as well","width":257},{"text":"notice as well that these types are signed","width":422},{"text":"so we can represent negative numbers and plus numbers","width":176},{"text":"C also provides the idea of being able to say that we can have an unsigned version","width":450},{"text":"so, for example, I can have an unsigned int","width":255},{"text":"now there is no signed bit that is included in the bitwise representation","width":439},{"text":"so that's great if you wanted to represent all the numbers between zero and 4 billion on this particular machine","width":355},{"text":"the character type can actually be signed or unsigned","width":343},{"text":"depending on the particular implementation of the C language for this particular architecture","width":404},{"text":"so that's enough for now","width":142},{"text":"in the next video, we will talk about pointers","width":137},{"text":"now it's time for you to play and learn a little bit about the basic C primitives. Bye!","width":394}],
  // Video 6
  [{"text":"Now let's talk about pointers and arrays","width":224},{"text":"how might I make an array of integers?","width":179},{"text":"let's say I had some data and I did this","width":241},{"text":"well, on this particular architecture we just found out that an integer is four bytes","width":272},{"text":"so I've now got thirty two bytes of storage","width":226},{"text":"and in fact, it's going to be thirty two bytes on the stack","width":209},{"text":"so what do I have here?","width":120},{"text":"when I say data square brackets eight, I'm going to get back four times eight, thirty two bytes all together","width":456},{"text":"all contiguous in memory","width":117},{"text":"and in fact, data is going to point to  the very first four bytes","width":240},{"text":"so I've got four bytes and then four bytes and then four bytes and then four bytes and so on","width":364},{"text":"let's have a look at that","width":116},{"text":"so, if I say printf data is at and this time do %p, that means treat data as and print it out as an address","width":760},{"text":"so we'll print this out","width":538},{"text":"and we see we've got a value here in memory","width":253},{"text":"that data points to the very first element","width":191},{"text":"let's do something a little bit surprising here","width":133},{"text":"let's add one to data and print that out","width":257},{"text":"so, data plus one","width":161},{"text":"and we'll do data plus two","width":244},{"text":"and so on","width":626},{"text":"so, if we look over here at our output, we'll see that each time we add one, our address in hexadecimal is going up by four each time","width":563},{"text":"so we've got 9d40, 9d44, 9d48","width":323},{"text":"here's why","width":43},{"text":"when you add an integer to an address pointer","width":308},{"text":"C knows the type of that pointer","width":209},{"text":"so in this case, we're pointing at integers","width":135},{"text":"so each time we add one, we actually want to progress to the next integer stored in memory","width":306},{"text":"and as each integer takes four bytes, that's why our address is going up by four each time","width":483},{"text":"so how could I use this?","width":101},{"text":"well, one way is to use asterisk which means use the address so, for example, I can say data the parenthesis are not strictly necessary but we'll use them in a moment","width":941},{"text":"and let's say store the value a hundred in there","width":188},{"text":"what about if I wanted to store some value at the next entry?","width":383},{"text":"ok so, hundred, hundred one","width":123},{"text":"so now I've stored the value a hundred that integer pattern into the first four bytes","width":376},{"text":"and the integer pattern for a hundred and one in the next four bytes","width":358},{"text":"and I guess you could figure out what this would do as well","width":374},{"text":"the asterisks means use the pointer follow the pointer dereference the pointer","width":409},{"text":"in other word, we've got an expression which is a memory address, now I want to use it","width":291},{"text":"now I actually want to use that pattern that bitwise pattern to actually read or write some memory","width":469},{"text":"so that's what the asterisk does means actually okay it's time to go and talk to memory","width":288},{"text":"this is so useful with arrays","width":127},{"text":"there is an alternative syntax which is to use the square brackets","width":228},{"text":"so for example I could have written the following","width":300},{"text":"which means take my address pointer add two to it and use that address for the array","width":473},{"text":"so these last two lines are the same","width":133},{"text":"in fact, here's a little secret about C that I could actually swap these around","width":319},{"text":"so we could also write this in this slightly crazy way","width":418},{"text":"so this is crazy but actually two square bracket data would evaluate to the same thing","width":396},{"text":"so that's something to confuse your non-C friends with","width":377},{"text":"that's enough with me playing with integer pointers","width":272},{"text":"now, it's your turn. Bye!","width":188}],
  // Video 7
  [{"text":"so what about strings in c?","width":131},{"text":"what if I said","width":99},{"text":"\"hello\"","width":79},{"text":"how is this represented? well clearly it's made up of characters","width":214},{"text":"and I've got five characters to display","width":218},{"text":"h e l l o, but actually C strings contain an extra character at the end","width":325},{"text":"a zero value or null character to say \"hey this is the end of the string\"","width":383},{"text":"so this is going to take six bytes of storage","width":196},{"text":"let's see if we can prove that","width":106},{"text":"we'll say printf() and \"Size of hello is %d\"","width":420},{"text":"and we'll have a little expression here to say what is the sizeof() \"hello\"","width":658},{"text":"and we'll print it out and you see that size of hello is 6","width":477},{"text":"h e l l o that's five, plus an extra byte for the 0 to say that's the end","width":410},{"text":"so we can use sizeof() on constant strings","width":339},{"text":"we could also run through the string to actually find the 0 byte ourselves","width":408},{"text":"so let's do that","width":79},{"text":"let's have a pointer to a character","width":279},{"text":"I will initialize it to my string \"hello\"","width":347},{"text":"which means pointer is initially pointing to h the first character","width":448},{"text":"I'll have a little count variable here","width":161},{"text":"and let's say \"while the pointer the value is not equal to 0\"","width":676},{"text":"I want to do something","width":83},{"text":"lets increment the pointer","width":72},{"text":"lets move it onto the next character","width":115},{"text":"and let's increment our count as well","width":185},{"text":"so we can find out how many characters we have","width":261},{"text":"and then at the end we will say how many characters we found","width":461},{"text":"which are not the 0 byte","width":276},{"text":"so if our program works this should find five characters","width":324},{"text":"lets run it and i'll put in a new line at the end","width":707},{"text":"our little loop went around five times and all it did was increment count","width":302},{"text":"we could have made it of course print out each one of those letters","width":254},{"text":"we could also simplify our program a little bit","width":142},{"text":"because as you know any non-zero value is treated as true","width":342},{"text":"so let's remove that and say while star pointer","width":245},{"text":"and when we get to the null byte we will finish","width":197},{"text":"so just for fun lets change our program as well before we increment the pointer to print out the next characters","width":603},{"text":"my format string is just %c. and what character would I want? well the one pointed to by the pointer","width":493},{"text":"pointers to characters that Â each character is exactly one byte","width":353},{"text":"so when we add one to our pointer, line ten here","width":266},{"text":"we are actually just going to add one to it","width":176},{"text":"because each character is exactly one byte","width":165},{"text":"so there's our program and it managed to print out exactly \"hello\"","width":538},{"text":"do we need to write this every time that we want to find out the number of characters in a string?","width":397},{"text":"no! guess what there's a function called strlen()","width":190},{"text":"so instead of my little loop if I include string.h","width":413},{"text":"I've now got strlen()","width":92},{"text":"so let me check the two results","width":212},{"text":"instead I'll say len is strlen() and pass it a pointer to my character","width":394},{"text":"I'm tempted to use pointer but that would be a bad idea","width":209},{"text":"perhaps you can figure out why","width":159},{"text":"so \"Strlen returned\" and we'll talk about how to fix my program in a moment","width":621},{"text":"so we'll run this","width":454},{"text":"strlen() returned 0","width":104},{"text":"why? because by the time my loop finished I'd advanced that pointer on until it had reached that null byte","width":395},{"text":"so when we passed that to strlen() it immediately found the null byte","width":209},{"text":"now what we should do is evaluate our strlen() before we change our pointer","width":962},{"text":"the last thing we'll do today is make our program crash","width":201},{"text":"let's try and change our first character to be someting else","width":396},{"text":"like 'J' turn it into Jello","width":283},{"text":"so let's dereference that pointer and use it to push in a character","width":397},{"text":"I don't want to have a string, i actually want to have a character","width":322},{"text":"let's try that and see what happens","width":296},{"text":"I get a segmentation fault when I try to run that line","width":189},{"text":"here's why, different parts of my proccesses' memory are valid for reading or reading and writing","width":549},{"text":"the program code, the actual assembly, the actual instructions for the cpu, can only be read","width":418},{"text":"and my constants, such as this \"hello\" can only be read","width":274},{"text":"and the hardware is sophisticated enough to know which parts of memory are read and which parts of memory are read/write","width":487},{"text":"and which parts of memory are invalid","width":147},{"text":"so that's why I get a segmentation fault if I try to change the constant memory","width":383},{"text":"alright time for you to play with character poitners, bye","width":270}],
  // Video 8
  [{"text":"So this video is about how to have an argument","width":174},{"text":"let's have a look inside some directories that we've got on our little system","width":281},{"text":"so if I type ls /bin","width":170},{"text":"you'll see here's a whole lot of programs that I can run from my terminal window","width":298},{"text":"and some of them you might recognize already","width":123},{"text":"including ls for list the contents of a directory (what we just did)","width":243},{"text":"cat to list the contents of a file and print it out","width":213},{"text":"and echo simply to echo back whatever we type","width":260},{"text":"so I can say echo Hello World","width":196},{"text":"and we also can used echo to print out the result of the exit value of the last program run","width":364},{"text":"how is it that these programs then can find out the parameters (the arguments) that we supply?","width":456},{"text":"when they are run?","width":90},{"text":"and the answer is that actually our main method can have two parameters here","width":339},{"text":"we have an integer (the number of arguments here) and also an array of character pointers","width":601},{"text":"called argv for value","width":206},{"text":"so let's actually print out some of these things","width":218},{"text":"so we'll say printf and we'll have the argv, the very first entry, the zero-th index is this","width":600},{"text":"and we'll say argv of zero","width":157},{"text":"and we will also print out what the last thing points to","width":384},{"text":"so that's going to be argc","width":190},{"text":"so that's %p","width":143},{"text":"we'll have a new line or two","width":135},{"text":"alright, and change that argc","width":311},{"text":"so here's two surprising things","width":176},{"text":"first of all, the very first entry is actually the execution name of the program","width":291},{"text":"how we started the program","width":150},{"text":"here, our program is just called \"program\"","width":298},{"text":"and secondly, there is actually one extra argument at the end and that points to the null string","width":417},{"text":"our pointer is null, it's zero","width":264},{"text":"so, let's now actually print out the other values","width":359},{"text":"we'll find out what the other values of argv is","width":628},{"text":"and we'll loop through and we'll print out all of those values","width":258},{"text":"so I'll have a little count. I'll start from 1 this time.","width":226},{"text":"because we don't want to print out the program name","width":343},{"text":"I can say: while count is less than argc, because I don't need the null pointer at the end","width":457},{"text":"and each time around the loop, increment count","width":274},{"text":"I'll print out the value of my count that's %d and print out its value as a string","width":565},{"text":"ok so that's going to be count and argv at index of count","width":442},{"text":"finally, let's put a new line in here","width":173},{"text":"here's my mistake: I should have said argc here for count","width":297},{"text":"ok, let's print it out","width":296},{"text":"when we start, argc is just 1. we've got just the program","width":197},{"text":"run it again but this time but this time have \"cat hat sat\"","width":277},{"text":"and you'll see I've got three additional arguments","width":254},{"text":"if I had put that inside double quotes then the hat and sat would be one argument","width":565},{"text":"so you see that we can now send our arguments","width":199},{"text":"for example, I could write a little program that helps me add up some numbers","width":370},{"text":"and I need a simple way to turn a string of digits into an integer","width":444},{"text":"in other words, I want to go from ASCII to an integer","width":136},{"text":"so this is the simplest way of turning a string into an integer number","width":466},{"text":"but this function doesn't give us much error checking","width":123},{"text":"if it can't read it, it simply returns zero","width":121},{"text":"I'll talk about how we can do a better job using scanf in a different lecture","width":238},{"text":"so we'll add those up and we'll print the result. right so we've got a result of zero","width":425},{"text":"let's try running our program again with 10 20 30","width":280},{"text":"and we see we get a result of 60","width":205},{"text":"if I had put some non-numbers in here, I get the result ten because the string I've got here it's converted into a zero","width":821},{"text":"alright, that's enough from me. now it's time for you to play. bye!","width":257}],
  // Video 9
  [{"text":"hi so this video is about the environment","width":260},{"text":"so in addition to being able to set arguments to our little programs","width":317},{"text":"each program also has access to environment variables","width":229},{"text":"let's have a look at those now","width":104},{"text":"so in my shell over here","width":149},{"text":"so my terminal window","width":63},{"text":"if i type for example set","width":117},{"text":"i can see a list of environment variables","width":181},{"text":"so these can be used by the shell and any other programs that we start to help configure their behavior","width":316},{"text":"for example we see down here that I am running as superuser","width":377},{"text":"as the root on this little system here","width":188},{"text":"we can also see that my home directory is in slash root","width":258},{"text":"so that's where kind of root's files will be stored","width":236},{"text":"great so how will i get access to that in my c programs","width":274},{"text":"well there's two ways","width":118},{"text":"first of all there's a variable called environ","width":301},{"text":"which if we are running in an older posix environment","width":280},{"text":"we have to specifically declare ","width":167},{"text":"in fact we say look there is somewhere in there is already a variable declared called environ and we just need access to it","width":475},{"text":"so that's what the extern keyword means","width":168},{"text":"we are not trying to say give me additional storage for this","width":149},{"text":"rather that the storage for this environment variable has already been made","width":210},{"text":"and we just want to be able to reference it inside our program","width":253},{"text":"so if i use that","width":173},{"text":"you'll see that it's actually a character pointer pointer","width":212},{"text":"in other words i'm going to dereference it twice","width":173},{"text":"the first time i dereference it","width":180},{"text":"i get a pointer and that pointer itself is going to point to character strings","width":297},{"text":"and i can keep moving along then to print out different environmental variables","width":342},{"text":"so if i had the same kind of pointer ","width":252},{"text":"i'll call it ptr and i initialize it to environ","width":341},{"text":"i could print out the very first one","width":234},{"text":"if i say let me print out a string and a new line and if I do star pointer we can follow that money if you like","width":710},{"text":"we can follow where that pointer points to","width":101},{"text":"so it points to the first entry in this array ","width":351},{"text":"so we can run this and we see i get the first environment variable","width":244},{"text":"which looks like a key or a name followed by an equal sign followed by its value","width":297},{"text":"so if i was to add one to the pointer","width":244},{"text":"then i move on to the next character pointer","width":196},{"text":"and i get the next entry","width":253},{"text":"so let's put that in a loop","width":121},{"text":"how can i do that","width":63},{"text":"well i can say while i might be tempted to write pointer but that's not going to be particularly useful","width":494},{"text":"instead i want to say whilst the thing that pointer is looking at is a non null value","width":322},{"text":"in other words whilst i have a valid pointer","width":214},{"text":"why? because i happen to know that this array has one extra entry at the end which is the null entry","width":400},{"text":"meaning that its got a pointer that points to nothing","width":139},{"text":"and let's also increment our pointer at the end","width":171},{"text":"great so we can run this and get a look at all of the entries","width":414},{"text":"in fact why don't we set a couple of entries here","width":258},{"text":"so export secret to be 123456","width":324},{"text":"let's try that and run our program again","width":183},{"text":"this time when we run it","width":128},{"text":"the environmental variable secret is part of the environment of our running program","width":480},{"text":"if you already know the name of the environment variable that you wish to use","width":346},{"text":"you can get to it directly","width":125},{"text":"so we can also say hey give me the environment variable and give it a name","width":287},{"text":"for example secret and this will give me back a pointer to a character array","width":603},{"text":"oops i better call it secret","width":188},{"text":"let's print it out and quit","width":163},{"text":"so the secret is and we can call exit","width":992},{"text":"great i've got a little program that can print out secrets","width":222},{"text":"so now i can make my program check that the secret is set for example","width":320},{"text":"for example if I try to get an environmental variable that doesn't exist","width":465},{"text":"then my pointer is actually going to be nil","width":288},{"text":"let me show you that","width":94},{"text":"let me try to print out the value of secret as an integer","width":486},{"text":"so my secret pointer is pointing to nothing","width":268},{"text":"we didn't set that environmental variable yet","width":126},{"text":"so we for example i could say look if secret is null then i'm not going to let this program run","width":662},{"text":"i am just going to stop","width":294},{"text":"so we'll stop and let's now change it so that very secret is something like abc","width":779},{"text":"and when we run the program again this time you'll see that secret is a valid integer value so that's just an integer representation of the pointer","width":793},{"text":"and we got back at that memory location the contents of that environment variable ABC","width":469},{"text":"okay that's enough for me now it's time for you to play","width":124},{"text":"bye","width":48}],
  // Video 10
  [{"text":"let's talk about strings today","width":165},{"text":"first of all, these two things are very different","width":171},{"text":"I could have a pointer to \"hello world\"","width":403},{"text":"or I could have an array of characters to \"hello world\"","width":492},{"text":"though both ptr and array points to the first letters","width":353},{"text":"some things that are noteworthy here is first of all they have different sizes","width":303},{"text":"so let's look at the sizes of each of these, perhaps you can guess what the result is going to be","width":405},{"text":"so you'll see the size of the pointer is the number of bytes to actually hold the character pointer","width":307},{"text":"which as this is a 32-bit machine is four bytes","width":226},{"text":"the size of array is the total size required to hold the whole array","width":420},{"text":"so when this code runs it's actually going to copy the contents of that string literal \"hello world\" into the new array object","width":564},{"text":"so in this case we need twelve bytes for that, eleven for \"hello world\" plus a twelfth to hold the null character at the end the bit pattern zero to say okay we've reached the end of the string","width":769},{"text":"their sizes is very different, plus remember that because we've made additional memory on the stack","width":496},{"text":"we can change it so I can change it to \"jello world\" for example","width":272},{"text":"let's start manipulating our string","width":234},{"text":"we'll do this on our array so we can actually make modifications to it","width":240},{"text":"how about we change all the 'l's to a different letter","width":242},{"text":"so we'll change and we'll pass the beggining of the array","width":255},{"text":"so let's pass in the array and afterwards we'll print what the array is so that's %s","width":985},{"text":"alright so I'll have my function called change down here and it takes a pointer to that memory","width":378},{"text":"so we don't need to return anything because we are actually going to be using the parameter to point to some memory that we are going to change","width":506},{"text":"what can we do with this?","width":121},{"text":"well let's have a little loop that says while(p) that says while p is non zero","width":433},{"text":"actually what we care about is whether p is pointing to memory that holds zero","width":316},{"text":"in other words, we've reached the end of the string","width":142},{"text":"we want to follow the pointer we want to dereference the pointer and for that we need the asterisk","width":290},{"text":"okay so what should we do with this. well we could change all of the letters","width":429},{"text":"for example we could blank it out","width":173},{"text":"we could say star p equals","width":147},{"text":"and it might be tempting to write an astericks here","width":376},{"text":"but that's not right because the asterisk means I've given the address of the asterisk","width":473},{"text":"so I'd be writing an asterisk into the address of the asterisk into that occasion","width":483},{"text":"if I run this I get a few warnings","width":134},{"text":"but it runs and it runs it for forever because my loops runs forever","width":257},{"text":"so let me ctrl-c that to break it","width":171},{"text":"this time change the loop so I add one to p each time","width":504},{"text":"so now I've got a very strange character because it's taken the lowest eight bits and copied that into my character","width":555},{"text":"instead let's change that to the actual bitwise pattern of my character","width":326},{"text":"now I've got something which can get rid of swear words by over writing them with asterisks or perhaps a password or something","width":573},{"text":"but we didn't want to do that for all the characters, we just wanted to do that for the l's","width":208},{"text":"so let's see if my p is, at when I look at that memory location, whether it's a lowercase l","width":594},{"text":"and as I said before because we are working with characters it is ok to compare them so note the use of double equals here","width":553},{"text":"okay so let's run that","width":341},{"text":"we have a couple of errors here","width":204},{"text":"for starters we're not using pointer","width":150},{"text":"so I can comment out that line","width":111},{"text":"I've got another problem here which is that change is implicitly declared","width":289},{"text":"that's because we haven't declared what the function signature of change() looks like","width":301},{"text":"let's do that now","width":89},{"text":"I'm going to say later on compiler, I expect to actually define a function and I'll give you the actual code to create this change method","width":700},{"text":"but for now here is what it's signature looks like","width":153},{"text":"it's called change, it takes a pointer to a character and it doesn't return anything","width":272},{"text":"so if I compile that now my warnings should go away","width":283},{"text":"great so I've got a function that can walk through","width":402},{"text":"I could have another function that finds letters as well","width":186},{"text":"so for example suppose we wanted to find the first o in this","width":503},{"text":"I could change this so that rather than changing the letters","width":413},{"text":"if the contents of p is an 'o', let's return p","width":466},{"text":"now I'm going to change my method signature","width":243},{"text":"and I'd better have a return value that returns something if I get to the very end","width":338},{"text":"so for example, it returns where p is","width":324},{"text":"we can now update my original code so that it finds the first 'o' and gives you back a pointer to that","width":876},{"text":"if I print that out","width":93},{"text":"hopefully you can guess what my program should do","width":407},{"text":"okay so it gave us back a string and it this time the pointer was half way through \"hello world\"","width":453},{"text":"that's OK, our pointers don't care what they point to","width":278},{"text":"we know that strings will continue until we reach the null byte at the end","width":384},{"text":"so that's how we were able to print out hello world","width":257},{"text":"okay that's enough for me, time for you to play. bye!","width":83}],
  // Video 11
  [{"text":"Hello! Let's talk about automatic variables","width":204},{"text":"so here's my main method I've got two function calls f1 f2","width":328},{"text":"and today I'm going to actually define them before my main method","width":266},{"text":"so I don't need to put in the additional declares in","width":211},{"text":"so let's have f1 here and f2...ok","width":353},{"text":"so now I've got a syntactically correct program","width":257},{"text":"but I want to talk about the variables that we might put inside these","width":182},{"text":"so if I create a variable like this to say \"hey I've got a value here, something I need to compute inside f1\" or maybe I want to make an array","width":718},{"text":"so here's my array and I can initialize it to, say, \"f1f1\" here we go","width":529},{"text":"then the lifetime of my array (this variable) is only for the lifetime of the function","width":456},{"text":"when I return from f1, then the variable goes out of scope","width":307},{"text":"which means the name \"array\" doesn't mean anything anymore inside our program","width":271},{"text":"but secondly, the memory that we were using for the array is automatically free'd up","width":298},{"text":"it can be reused for other purposes in a moment by the rest of the program","width":197},{"text":"so isn't that fantastic","width":131},{"text":"that's why it's called an automatic variable","width":160},{"text":"so automatic variables are very easy to use","width":140},{"text":"they also come with a big warning sticker and that's this","width":273},{"text":"which is to be very wary of just how long they live for","width":440},{"text":"let's do a couple of things here","width":126},{"text":"first of all, let's make it so that we can actually see the pointer in memory where array is pointing to","width":671},{"text":"so, let's print that out inside our function here","width":341},{"text":"remember that the name of the array (when converted to address) gives us the very beginning of the array","width":400},{"text":"and, we'll do that for our second function too","width":172},{"text":"okay, so, f2 f2","width":220},{"text":"just to prove that they're making different arrays","width":215},{"text":"okay, so we'll compile and run this","width":190},{"text":"and, when we run it, we see that both f1 and f2 both these functions the array is actually stored inside the same memory location","width":864},{"text":"isn't that fantastic. we didn't need any additional memory","width":155},{"text":"and that's because after we return from f1, any of those automatic variables are free'd so they are no longer needed so we can reuse that space","width":598},{"text":"internally, later we'll discover that a stack data structure is used to implement this","width":497},{"text":"and I can show a little bit of this by having a either a recursive function or we can make another function call these","width":611},{"text":"so for example, I could have a function called eg","width":421},{"text":"and, this calls f1","width":146},{"text":"so now let's have a look in the case that I'm not using f2 anymore","width":363},{"text":"so that can go away","width":180},{"text":"instead, I've got a function called eg and that can say have its own space","width":365},{"text":"so, blah and maybe say a thousand and twenty four bytes here","width":571},{"text":"and then we call f1 again","width":142},{"text":"so let's run this now","width":474},{"text":"so, in the output, you'll see that f1 is printed twice and the second time it's because it's being called from our function eg","width":784},{"text":"and in this case, it's further down in the stack. it's in lower memory","width":348},{"text":"f948 as opposed to fd50","width":154},{"text":"because it's being called from eg","width":335},{"text":"so, we'll see more about the stack in a moment","width":162},{"text":"later on. I just wanted to show you that they really are stored in different places","width":326},{"text":"finally, to reinforce this idea, let's make a little recursive function","width":348},{"text":"so, I can have something which takes an integer say I'll call it \"level\"","width":488},{"text":"and if level is greater than zero, let's call ourselves again with a slightly reduced value","width":667},{"text":"and I can of course make that simpler by just saying \"if level\"","width":272},{"text":"so if level is nonzero, then call it again","width":125},{"text":"and let's call it with say five","width":178},{"text":"okay, a semicolon would help","width":303},{"text":"each case as we go deeper and deeper into recursion, our array is getting lower and lower and lower in memory","width":587},{"text":"so we have all of these arrays created. all of these different activation records in different places","width":370},{"text":"inside our processes's memory","width":181},{"text":"so the last point we'll make, which is the most important, which is that it's very dangerous to return pointers to memory that is no longer valid","width":472},{"text":"for example, rather than returning nothing returning void, suppose we try to return a pointer to our array","width":659},{"text":"then though this code might compile, okay, I can get rid of \"level\" now","width":557},{"text":"it's certainly not a valid program because the pointer we get back from f1 now points to stale memory","width":631},{"text":"that memory is no longer ours to control","width":167},{"text":"it will be used in a moment for other function calls","width":182},{"text":"so always be careful if you are returning a pointer to something. make sure that that memory is still valid","width":413},{"text":"and never return a pointer to an automatic variable","width":208},{"text":"that's it for me. time for you to play. bye!","width":187}],
  // Video 12
  [{"text":"welcome so let's talk about some options other than automatic variables","width":350},{"text":"so here's a little problem i've got so far","width":121},{"text":"in my main method i want to print out the current time ","width":273},{"text":"and i'm going to write my function called currenttime that returns a new string array","width":460},{"text":"i already know that i cannot make an array in here to hold the result","width":385},{"text":"say with two hundred and fifty because when I go to return from this function","width":333},{"text":"the array variable won't be pointing to memory that is valid any longer","width":424},{"text":"so here is two options","width":102},{"text":"i could make my array static","width":130},{"text":"so how do i do that","width":127},{"text":"just by the keyword static","width":106},{"text":"so for example if i were to just say okay i've got myself a static array out here outside of that method","width":445},{"text":"then my array lives forever or at least for the length of my process","width":377},{"text":"so that gets rid of the problem of having some space","width":260},{"text":"i cheated i said look just give me some space for the lifetime of my program here ","width":319},{"text":"so that's what static does","width":167},{"text":"i can also put this inside the function","width":174},{"text":"that doesn't change the lifetime of the variable","width":125},{"text":"it just changes the scoping","width":126},{"text":"so as always that means simply that now the variable name array can only be connected to that piece of memory inside my little method","width":756},{"text":"so it's just changing how the actual name of the variable is bound to the memory","width":380},{"text":"so that's one method","width":134},{"text":"but instead i want to talk about a completely different way which is to use malloc","width":379},{"text":"so you're going to come across malloc calloc and realloc","width":703},{"text":"today let's talk about malloc ","width":124},{"text":"which essentially means give me some bytes","width":192},{"text":"and i can say how many bytes i need","width":204},{"text":"and that storage space is found inside the program's heap","width":271},{"text":"so for example if I want one hundred and twenty eight bytes I would say malloc one hundred and twenty eight","width":275},{"text":"so this is going to give me a pointer to the very first byte","width":245},{"text":"so let's store that inside my little character pointer here","width":294},{"text":"and i'll say there is my result","width":285},{"text":"it is possible that malloc fails","width":268},{"text":"if it is unable to give me one hundred and twenty eight bytes it would give me back an invalid pointer pointed to null or pointed to nothing","width":381},{"text":"so i could say look if result is zero or null or if i wanted to be really terse I could say if not result","width":684},{"text":"in other words result is null","width":115},{"text":"then just return that null pointer","width":176},{"text":"i am not going to try and use it","width":130},{"text":"it's not a valid pointer","width":135},{"text":"otherwise let's put some things inside this and I could turn the current time and store it inside that array","width":620},{"text":"so let me use a function called strcpy to put in the current time which is two fifty one pm","width":572},{"text":"#include <string.h>Â let's run this","width":887},{"text":"and my program calls currenttime creates some memory and then returns it","width":375},{"text":"this is fantastic right","width":63},{"text":"i've now got a way to make long lived pieces of memory and put data inside them","width":365},{"text":"but with great opportunity comes great responsibility here ","width":207},{"text":"so what we should do is let our programs is with every malloc we should at some point free up that memory to say hey i've finished with it","width":640},{"text":"so the correct way to do this is to keep a pointer around","width":191},{"text":"so let's have a pointer down here","width":280},{"text":"and when i finished using that memory","width":169},{"text":"i can free it","width":122},{"text":"to say hey this memory is no longer being used","width":128},{"text":"this block of memory of one hundred and twenty eight bytes is no longer being used","width":289},{"text":"please put it back into the heap and maybe we will reuse that memory again for a future malloc","width":566},{"text":"so good programs will have one free for every malloc ","width":353},{"text":"in the next video i'll talk about some of the mistakes that we can make with heap allocation","width":334},{"text":"but now it's time for you to play with malloc ","width":162},{"text":"bye","width":52}],
  // Video 13
  [{"text":"hi welcome","width":116},{"text":"so we have got a little function so far called currenttime()","width":136},{"text":"that requests 128 bytes from the heap","width":307},{"text":"and then providing we get a non-null pointer back from malloc","width":263},{"text":"we will copy in the time 2:51 PM into that memory","width":288},{"text":"and then return a pointer to the first byte of that memory so that's our little currenttime","width":262},{"text":"we've been careful to make sure that if malloc fails, perhaps our program has used all of the heap memory","width":411},{"text":"then we don't try to use that null pointer","width":207},{"text":"but now let's actually make it so that it actually makes a call to find out what the current time is","width":540},{"text":"the current time is known by the system","width":114},{"text":"so it's time to make a system call and then we will format that using a c function called ctime()","width":529},{"text":"to actually give us a human readable version of the time","width":328},{"text":"both of these functions can be found inside the include time.h","width":306},{"text":"I've commented them up here","width":113},{"text":"so the first think we can do is call time so when you call time you can pass it a pointer to a time_t variable","width":717},{"text":"or you can say actuall I'm not going to give you anything and it will still give you back the time in its result","width":512},{"text":"so let's just use the result","width":145},{"text":"so here's the number of seconds since 1970","width":534},{"text":"we'll store that inside our little variable called secondsSince1970","width":359},{"text":"but I don't want that as a value, I just want to turn that into a string","width":224},{"text":"for that there's a function called ctime, this a library function. there are other functions that give greater control to the precise formatting","width":630},{"text":"but for this demo let's just use ctime() which has some reasonable formatting that most people can understand","width":617},{"text":"this will give us back a pointer to the time","width":319},{"text":"so the time in ASCII, in otherwords in letters, in readable time","width":484},{"text":"and then we can use that and copy that result into new memory, into our result","width":526},{"text":"so one problem with ctime() is that it uses static storage","width":339},{"text":"in other words it's great if you just want to call it once, and it will use it's static storage to give you back the time in a readable format","width":674},{"text":"but don't expect that to stay around because if you call ctime() again in the future it is going to overwrite those bytes","width":455},{"text":"and that's why our little function here called currenttime() is useful","width":200},{"text":"we are going to take that temporary result and put it into some memory that is ours to control","width":403},{"text":"so it can't be overwritten","width":174},{"text":"we need to pass in seconds since midnight","width":223},{"text":"except we've got a problem here","width":208},{"text":"it doesn't actually want the value, it wants a pointer to this variable, it wants to know where in memory this variable is","width":554},{"text":"for that I have to introduce some new syntax, which is the &","width":270},{"text":"when you see & it means that I don't want to know about the variable itself, but where it is stored in memory","width":523},{"text":"tell me the address of the variable","width":305},{"text":"we didn't need this for arrays because that's what the array name gives us automatically","width":224},{"text":"but for other items we can use the & to find out where it is stored in memory","width":500},{"text":"let's compile and run it","width":374},{"text":"and we find out that my little virtual machine thinks it's Jan 1 2014","width":389},{"text":"not very accurate, we should probably change it, but it did print out what it thinks the current time","width":487},{"text":"I promised you that I'd mention a few more mistakes that we can make with heap memory","width":479},{"text":"one mistake we can make is to double free the same pointer","width":423},{"text":"this can lead to all sorts of horrendous problems because when you tell the heap that you've freed with some memory it might actually use that memory for it's own book keeping","width":719},{"text":"so it knows that the particular block of memory is free","width":275},{"text":"if you free it again it can confuse the book keeping, the pointers that the heap is using itself","width":684},{"text":"once we've freed some memory, dont free it by accident a second time!","width":208},{"text":"another common mistake in C programs is to continue using memory after we've freed it","width":536},{"text":"we shouldn't consider that memory to be valid anymore","width":175},{"text":"perhaps it's going to be reused by some other part of the program that is about to call malloc()","width":458},{"text":"and certainly we shouldn't expect anything that we've previously stored in there to be valid","width":469},{"text":"once we've freed it don't try to use the pointer again","width":188},{"text":"so for example, this would be an error","width":217},{"text":"so how can we guard against some of these errors?","width":199},{"text":"one common defensive programming technique is once we free a pointer set that pointer to be NULL","width":498},{"text":"to mean that I'm not pointing to anything anymore","width":212},{"text":"so this avoids the problem of what is called a dangling pointer error","width":429},{"text":"that now our pointer is no longer pointing to invalid memory","width":541},{"text":"that's it for me. time for you to play, bye!","width":231}],
  // Video 14
  [{"text":"Hi, welcome!","width":94},{"text":"let's talk about creating more complicated data types in C","width":294},{"text":"so far, we've talked about integer and character pointers","width":220},{"text":"what if we wanted to make something more complicated like a linked list?","width":196},{"text":"for that, we will use a struct","width":193},{"text":"so, let's say we've got a struct and we'll say my struct I'll call it say Link","width":561},{"text":"and what should we have inside this?","width":80},{"text":"well, we've have a value to store and we'll need a pointer to the next link","width":310},{"text":"we'll need to know where the next link is in memory","width":117},{"text":"so, we can say struct Link and it's a pointer to that","width":368},{"text":"so, don't forget the asterisk","width":80},{"text":"so that's our little struct here. a semicolon is required at the end","width":297},{"text":"but it's kind of painful to keep saying \"struct Link\" every time I want to refer to this type","width":412},{"text":"so I can have a link here called \"one\" for example","width":204},{"text":"so quite often, we can use, or you'll find that people use \"typedef\"","width":277},{"text":"to say \"here's an alias\" and I can use typedef with any kind of type","width":417},{"text":"I can even use it with integers","width":139},{"text":"for example, I can say typedef number","width":168},{"text":"now I can say \"number x\" instead of \"int x\"","width":368},{"text":"but today we're going to use typedef for our link","width":190},{"text":"so we'll say instead of having to write struct Link, I'll call this my link type","width":416},{"text":"so now I've got my link type, I can make a link","width":238},{"text":"here's one","width":63},{"text":"and if I declare variables like this, outside of my functions, then they live forever","width":614},{"text":"and, let me write my main method here","width":326},{"text":"so, my link called \"one\" and my value live forever","width":395},{"text":"and in fact, they're initialized","width":87},{"text":"so their bitwise pattern is just all zeros","width":212},{"text":"so in other words, my value will be zero and the link \"one\" will have a value of zero and its next pointer will have a value of zero as well","width":740},{"text":"if we wanted to change that, then we could say one.value equals fourty two","width":369},{"text":"and one.next equals well, where should we put it?","width":237},{"text":"well where should we send it next?","width":98},{"text":"we could say \"NULL\" if we wish to use NULL, actually we have to #include <stdlib.h>","width":570},{"text":"to have NULL defined","width":185},{"text":"and now our Link says \"I'm the last thing. there's no one after me\"","width":354},{"text":"if we wanted to be particularly crazy, we can make the next pointer point to the very same link","width":425},{"text":"we do that by saying \"one\" except we don't want \"one\" we want the address of \"one\"","width":350},{"text":"we need a pointer to \"one\"","width":70},{"text":"so how do I do that? I use ampersand to say \"give me the address\" of this","width":281},{"text":"so that gives me a pointer to a link","width":121},{"text":"well thats great if we only need one link","width":114},{"text":"but that's not much of a linked list","width":150},{"text":"let's actually work out then how we can actually make a whole load of links","width":292},{"text":"for that, we'll use some heap memory","width":148},{"text":"and I'm going to use malloc which is also declared inside stdlib.h","width":268},{"text":"so, I need some memory","width":160},{"text":"how many bytes do I need?","width":109},{"text":"for that, I can say: \"give me the sizeof my link structure\"","width":225},{"text":"in other words, give me the size of link_t","width":143},{"text":"be careful you don't put an asterisk here otherwise, you'll only be reserving enough bytes for a pointer","width":362},{"text":"in other words, 4 bytes or so","width":109},{"text":"that's not enough for what we need","width":104},{"text":"we need the size of our whole struct","width":247},{"text":"so that gives me back a pointer and I actually want to cast it so that it's type pointer to a link_t","width":528},{"text":"so I can now store that inside a variable","width":227},{"text":"and I can have it as my first pointer","width":261},{"text":"so, malloc does not initialize the actual memory. it just simply reserves it for us","width":371},{"text":"just allocates it for us.","width":89},{"text":"we better make sure that our Link is properly initialized","width":228},{"text":"so for my first Link, I want to set its value to something","width":353},{"text":"and I need to set its \"next\" pointer to something","width":225},{"text":"so for example, I can set it to NULL","width":107},{"text":"or if I, oops, let me change that to put a one","width":271},{"text":"or if I wanted to make it point to itself, I can say \"ptr1\"","width":355},{"text":"if I had two links, let's do that","width":347},{"text":"then I can again set up the values. be very careful when copying and pasting code that you've actually edited it correctly","width":543},{"text":"I can now make my first link ptr1 its next point to next ptr","width":407},{"text":"and the next link, its next pointer can go nowhere","width":440},{"text":"so, there's my simple linked list","width":205},{"text":"more complicated links might have a previous pointer as well","width":246},{"text":"so you can navigate both in the forwards and backwards direction throughout the linked list","width":506},{"text":"okay, so, let's now finally compile this and check that it works","width":403},{"text":"our program compiles correctly, but to be a well-behaved program, really we should free up the memory as well","width":720},{"text":"so don't forget for every malloc you do, we should responsible for freeing up that memory once and once only","width":566},{"text":"so free(ptr1) and free(ptr2)","width":324},{"text":"also, a more robust version of this program would check that malloc actually succeeded","width":377},{"text":"that we actually really got the bytes","width":143},{"text":"that would be something important to do if your program ran for a very long time","width":322},{"text":"or needed very large unknown amounts of memory","width":319},{"text":"so that's how we make linked lists in C","width":184},{"text":"now it's time for you to play. bye!","width":161}],
  // Video 15
  [{"text":"Okay so let's talk about how we can make it easier to create links and destroy them","width":335},{"text":"so i've changed my link class a little bit so now each link can have a key and a value","width":297},{"text":"in addition to the next pointer","width":129},{"text":"the pointer to the next link","width":106},{"text":"okay so let's make some methods to create links and destroy them","width":440},{"text":"we'll do the create one first","width":123},{"text":"so it's going to return a pointer to a link","width":227},{"text":"and i might call it say link_create and I'll expect a key and I'll expect a value","width":721},{"text":"so that'll give me two pointers","width":159},{"text":"if i wish to debug this I could have a printf in here saying hey creating link and I could have what the key and values are for example","width":737},{"text":"right so i need to get some memory","width":165},{"text":"let's get some memory from the heap because we want our link to last for a long time until we decide to destroy it","width":445},{"text":"so i'll say malloc give me some memory and how much well i better ask for how big is my memory structure link_t","width":545},{"text":"and i will cast that return type as a pointer to my link object","width":445},{"text":"why do i do that","width":63},{"text":"well i want to be able to reference the sub parts","width":170},{"text":"the components of my struct","width":119},{"text":"and i will call that say result and i need to initialize my pointer","width":481},{"text":"so now i've got that I can set the key to be a key and the value to be the value","width":499},{"text":"now when i do this i am copying the pointers i'm not creating new strings","width":444},{"text":"so in other words i've now got a pointer called key and it's looking at exactly the same string array as the parameter is","width":499},{"text":"i haven't made any new string arrays","width":203},{"text":"so let's remember that when i return this","width":214},{"text":"that those pointers better be valid for the lifetime of the link","width":288},{"text":"well that's fine if I knew for example that this will always be used with string constants or I am taking control of those values that I send in and I happen to know that their lifetime is longer than the link's lifetime","width":1068},{"text":"so if that's the case then my code is relatively simple like this","width":214},{"text":"and destroying the link is also relatively simple","width":225},{"text":"so let's write a link destroy method destroy","width":205},{"text":"which takes a pointer to the link that is going to disappear so we can call that just p","width":437},{"text":"and what do i need to do in here","width":104},{"text":"well i can simply return the memory back","width":190},{"text":"okay so this works we could do a little better than this","width":253},{"text":"we could actually do some defensive programming here","width":150},{"text":"where we also destroy the information inside that link","width":381},{"text":"so for that i can use memory set","width":190},{"text":"so memset where I give it a pointer that I want to use","width":325},{"text":"the value will be zero the number of bytes can be the size of my link","width":279},{"text":"so this assures that i don't have any dangling pointers","width":258},{"text":"i have destroyed the key and value pointers","width":232},{"text":"i've set them back to null and anything else inside my link has been set to null","width":247},{"text":"so if someone happens to have a pointer to this link and they try to use the contents straight away then it will fail it will be null","width":521},{"text":"and secondly we are freeing it to say okay this memory can now be reused for other purposes","width":356},{"text":"so that's my link destroy method","width":158},{"text":"now suppose we discover that our strings we don't control the lifetime of these string arrays","width":483},{"text":"and that actually we should make copies of them","width":186},{"text":"so how can i do that","width":89},{"text":"well there's a method called strdup so let's do that strdup and this gives me back a pointer to a new string ","width":697},{"text":"a new character array that has been created on the heap","width":223},{"text":"and it's just a copy of that existing character array that we passed it","width":296},{"text":"so let's create our new string arrays and use those","width":296},{"text":"if we do that then when I destroy the link I better free up the memory associated with my key and value","width":470},{"text":"so before ending here I should free up those pointers","width":344},{"text":"so I should call free on my key and free on my value pointer as well","width":641},{"text":"okay so there's my code now to start working with a link","width":780},{"text":"with my main method I will need to always know the beginning of my linked list","width":448},{"text":"so that sounds like a great thing to actually have as a global variable here","width":312},{"text":"so let me have my link pointer here and I can call it root","width":327},{"text":"and so the first link I make I can initialize root to that","width":316},{"text":"to that very first link","width":157},{"text":"okay so that's it for now, it's now time for you to play with creating more links","width":389},{"text":"bye","width":70}],
  // Video 16
   [{"text":"hello welcome","width":63},{"text":"let's talk about how we can get single characters and print them out in c","width":267},{"text":"so here's some functions defined in std.io","width":232},{"text":"i can say give me a single character for example and why don't I just keep calling this","width":400},{"text":"so i could just say while getchar is not equal to a special constant called end of file (EOF) keep going around in a loop","width":590},{"text":"but if I actually want to print them out I better actually store the value of getchar","width":232},{"text":"so let's have an integer value called c and inside my while condition I'm actually going to assign the result into c","width":544},{"text":"so you'll often see this pattern inside systems programming where we take a systems call or a library call and we store the results inside a variable","width":643},{"text":"but because that may also signify an error condition or a termination condition we use it immediately to check inside part of a while loop or an if statement","width":641},{"text":"so we've got a little character loop here that is going to keep going until it gets to the end of the file","width":254},{"text":"so now I want to print it out","width":92},{"text":"guess what i can call putchar and we'll see that running ","width":217},{"text":"so let's run this little program","width":264},{"text":"ABCD","width":90},{"text":"it prints back ABCD","width":147},{"text":"okay so we don't have to display the character just as a character","width":273},{"text":"we can display it as a character an integer and hexdecimal values","width":255},{"text":"so let's use printf for that","width":94},{"text":"so I've got %c %d and %x for character integer and hexadecimal value","width":376},{"text":"alright so let's run this","width":324},{"text":"and you can see that the letter A corresponds to sixty five which is in hexadecimal forty one","width":385},{"text":"right so why don't we use our little program to print out the contents of another file","width":433},{"text":"so if I cat my source code I can see the contents of that","width":292},{"text":"great so I'm going to pipe it into my program","width":273},{"text":"so i'll do ./program and it reads every byte and prints it out as a character","width":526},{"text":"great so let's encrypt our file now so I'm going to modify our value of c if it's not a newline character","width":533},{"text":"so what we'll do is say if c is at least thirty two in other words at least a space an ascii space","width":470},{"text":"and if it is we will change the lowest bit","width":382},{"text":"we'll flip the lowest bit","width":61},{"text":"how can we do that","width":64},{"text":"let's xor it with one","width":169},{"text":"right and then we'll print it out","width":147},{"text":"okay so we'll run this","width":172},{"text":"CDE for example and it changed the C to a B","width":281},{"text":"and if I do 135 I get 024","width":254},{"text":"so to say that I've got to the end of the file when I'm just typing you by the way you can do control d","width":374},{"text":"now see this working on some actual source code","width":226},{"text":"so let's here some text my program.c and i'm going to pipe that into my program to use as its input","width":524},{"text":"and you can see great we've garbled the program","width":264},{"text":"so if I want to I can then take that output and pipe it into my program again","width":444},{"text":"so now i'm going to unencrypt it because i flipped the lowest bit back  ","width":259},{"text":"so we get back our source code","width":133},{"text":"so that's getchar and putchar i can also work with whole lines","width":372},{"text":"i can let's get rid of the loop here i can say puts hello or any pointer to a character array provided its terminated by a zero byte at the end","width":997},{"text":"and that is equivalent to printf by saying %s and \\n at the end","width":560},{"text":"so i've got some character pointer here","width":279},{"text":"right so it's a little bit shorter to type than writing printf","width":480},{"text":"there is the opposite which is to get some input","width":225},{"text":"but this has a problem and we'll see why in a moment why this function actually call is being removed from the c standard","width":392},{"text":"i'm talking about gets so let's call gets and we will have a little buffer here","width":648},{"text":"so let's put a little buffer on the stack here","width":187},{"text":"i'll make it twelve bytes today ","width":109},{"text":"and remember when we call gets with buffer if you use the array name you are talking about the very first byte of the array","width":432},{"text":"and rather than printing out hello","width":175},{"text":"we will print out our buffer value","width":137},{"text":"so let's run this and we can type something in and it echos it back to us","width":509},{"text":"fantastic but what happens if we enter more than twelve bytes","width":262},{"text":"so in other words could something bad happen to our other variables","width":247},{"text":"well yes it could because if we go past twelve bytes we start writing into memory which is used for other purposes","width":353},{"text":"for example in my little program the integer is immediately after the buffer","width":378},{"text":"let's prove this let's set our hex value of c to be ten twenty thirty fourty","width":422},{"text":"let me print that out after we've called gets i'm going to print it again","width":584},{"text":"so we've got to remember that what we store is going to be our letters plus a null byte","width":475},{"text":"so in this case if I do ABCDABCDABCD I've already overflowed because the thirteenth byte is now going to be written into my integer","width":796},{"text":"but i am going to do just a few more I'll do ABCD there we go","width":295},{"text":"and we'll see that I've managed to change my integer value to 41424344","width":412},{"text":"so the last ABC that I wrote in there actually overran my buffer","width":277},{"text":"i've got a buffer overflow and I've corrupted the contents of another variable","width":300},{"text":"so that's why gets is dangerous","width":107},{"text":"there's no way to tell gets that we shouldn't accept input that is too long for it","width":420},{"text":"so in a future video i'll tell you about getline and also fgets which don't suffer from these problems","width":586},{"text":"okay that's it for me thanks for watching and i'll see you in another video. bye!","width":269}],
  // Video 17
  [{"text":"Hello! Let's talk about how we can use scanf and sscanf and fscanf to read some data and convert that into say integers or floats or strings","width":739},{"text":"so we can actually use those values inside our variables","width":232},{"text":"alright, so, I'll start by using sscanf","width":207},{"text":"which can parse data inside a string","width":184},{"text":"inside memory","width":109},{"text":"so for example, let's have a little bit of data here","width":136},{"text":"I'll have my data be my name and a score","width":454},{"text":"and I want to take that and pull it apart into a string and an integer","width":385},{"text":"so I'll have a little buffer here, say, up to twenty characters","width":343},{"text":"and a little integer here","width":102},{"text":"and I could set this to be equal to some arbitrary value. we'll see why in a little bit","width":434},{"text":"and then I'm going to say \"okay, sscanf please read from this string array and what I'd like you to do is convert that into a string followed by one or more spaces and then an integer value\"","width":1146},{"text":"alright so scanf is going to look at our memory starting at wherever our data is pointing at","width":359},{"text":"and, it's going to first of all look for a string until it comes across one space","width":357},{"text":"and then there can be actually multiple spaces in our data","width":155},{"text":"and then after that, it's going to treat the rest of the string as an integer","width":287},{"text":"okay, now, our format specifiers say the kind of data that we want to interpret and also the number of bytes that should be written to when it is trying to parse its data","width":730},{"text":"so we better tell it where to exactly put these things","width":154},{"text":"so for our string, we want it to write it into a buffer","width":234},{"text":"and for the score, we want to write it into our score variable","width":199},{"text":"but hold on a moment","width":114},{"text":"when we say \"buffer\" yes that gives us the beginning address of our array","width":372},{"text":"but not for score","width":63},{"text":"score is just going to give us whatever value score happens to hold","width":170},{"text":"in this case, negative forty two","width":124},{"text":"that's not what we need","width":69},{"text":"we actually want the address of this variable","width":132},{"text":"so we're going to say ampersand score","width":239},{"text":"so, lets read that and we'll print it out","width":271},{"text":"so here's the result and we'll say %s %d and we'll print the contents of the buffer and print the value of score","width":592},{"text":"so notice that scanf and printf, the arguments don't always look the same","width":266},{"text":"when we want to print out the values, we don't actually want to just print out the address of score","width":389},{"text":"we actually wanted to know what the value is","width":106},{"text":"great so that read that correctly","width":202},{"text":"scanf actually tells us something else which is how many arguments it correctly managed to parse","width":428},{"text":"so let's make a note of that and we'll print that out","width":299},{"text":"so, we'll say %d here","width":313},{"text":"print out the result in our printf statement here","width":183},{"text":"so now when we run it, we'll see that sscanf managed to read both iterms","width":384},{"text":"I got result two","width":90},{"text":"fantastic. so that's useful. now we can write robust programs to check if we really did write into both variables","width":521},{"text":"now you might be worried that scanf could result in a buffer overflow","width":286},{"text":"and, in fact, in our current code, you'd be right","width":168},{"text":"so if I had a very long name with no spaces here","width":419},{"text":"then that's longer than our buffer","width":229},{"text":"so what we need to do is tell scanf just how big our buffer is","width":209},{"text":"so in this case, it should be nineteen","width":207},{"text":"because we're setting scanf how many character to read from the input","width":321},{"text":"and our buffer, of course, if going to need one extra one to hold the terminating byte for this string","width":397},{"text":"so let's run this now","width":483},{"text":"and you'll see that first of all the name is truncated and that secondly, the return value of our scanf call here was one","width":538},{"text":"and it only managed to read into the buffer","width":259},{"text":"it gave up trying to read the integer because our buffer wasn't long enough","width":190},{"text":"and, in fact, our score variable still contained its original value","width":305},{"text":"of negative forty two","width":123},{"text":"so good defensive programs must check that the return value is reasonable","width":389},{"text":"also, when writing scanf or sscanf or fscanf, it's always a good idea to carefully check to see whether you should be looking at the address of the variable or if the variable itself actually is a pointer","width":783},{"text":"and is already going to give you the memory address that you'd like scanf to change","width":532},{"text":"alright so we've read data from a string ","width":263},{"text":"we can also parse data from a file stream and how can we do that? well you can use not sscanf but fscanf","width":663},{"text":"and if you did that, you better give it a file stream","width":182},{"text":"there's one called stdin already","width":209},{"text":"if we didn't want to use that, then we could open up a file using fopen and then pass in the file handle here","width":564},{"text":"and reading from stdin is such a common occurance that in fact there's another form of this which is just say scanf","width":699},{"text":"and if you do that, that means \"hey, just read from stdin\"","width":188},{"text":"so now, let's run our program here","width":555},{"text":"and, now it's waiting for input","width":99},{"text":"so let me typing something","width":130},{"text":"I'll say \"Angrave one hundred\"","width":324},{"text":"great! and it managed to parse both variables","width":177},{"text":"okay so that's enough introduction to scanf","width":188},{"text":"remember this next time you're trying to read 3d data and points and you want to say convert those ASCII numbers into actual floats and doubles","width":640},{"text":"and also remember that its important to read exactly how scanf uses these format specifiers because its not quite the same as printf","width":624},{"text":"alright, that's it for me. time for you to play. bye for now","width":278}],
  // Video 18
  [{"text":"hello welcome","width":111},{"text":"let's talk about getline","width":93},{"text":"so it's very very common to read in a single line of text either from the user or from a file","width":438},{"text":"and we would like it to be very easy to say hey \"let's not worry about making sure my buffer is large enough\"","width":384},{"text":"I just want to get the whole line","width":95},{"text":"and thus getline was born","width":130},{"text":"this is being adopted into the posix standard","width":215},{"text":"if you are working however with older standard and an older compiler we have to ask gcc to explicitly enable it","width":463},{"text":"so before doing our includes with stdio we need to define _GNU_SOURCE","width":575},{"text":"so if we do that we would like the gnu source additions to the standard functions","width":473},{"text":"right so if we do that now we have got a getline declaration included as part of the #include <stdio.h>","width":478},{"text":"so here is how we can use getline","width":228},{"text":"with getline we actually set up two variables","width":284},{"text":"we get getline to manipulate these directly ","width":287},{"text":"we are going to have a pointer to a buffer","width":319},{"text":"and a little int to say how big is our buffer","width":369},{"text":"well let's just check to see really if it is an int or if we should be doing a different type","width":226},{"text":"so let me pull up my favorite manpage on getline","width":362},{"text":"see that actually the correct type to use is size_t","width":398},{"text":"which is essentially an unsigned int or larger on some systems","width":259},{"text":"so let's just make a note of that","width":99},{"text":"that is the declaration that we are going to be using","width":210},{"text":"and so we will have not just a buffer to our character array","width":377},{"text":"but also size as well to say how big is our buffer","width":328},{"text":"and i will call this say capacity","width":168},{"text":"right so we could start calling this and we could say okay","width":256},{"text":"get me a line and oh i need to pass in a pointer to my buffer variable","width":441},{"text":"right and notice that the declaration here is star star asteric so it's a pointer to a pointer","width":513},{"text":"right so how did i get that","width":97},{"text":"i say okay give me the address of my variable","width":223},{"text":"and similarly for the capacity as well","width":150},{"text":"the size of the variable","width":126},{"text":"so give me the address of my capacity","width":317},{"text":"and getline is going to modify those two variables directly","width":222},{"text":"essentially if my buffer is not large enough","width":189},{"text":"it is going to free up the old buffer and then call malloc so that we get a larger buffer","width":518},{"text":"okay technically it might call realloc but let's not worry about exactly which library call it calls","width":335},{"text":"we just know that it's going to do all that buffer maintenance for us automatically","width":266},{"text":"and now we need to give it a filestream so why don't we use say stdin","width":413},{"text":"now right now our code suffers from a terrible flaw which is that we've assumed that our automatic variables buffer capacity will be set to nothing","width":546},{"text":"so the getline knows that it can't reuse what it happens to be pointing to","width":264},{"text":"so we actually need to set these to explicitly to null and the capacity to zero","width":403},{"text":"so the first time we call getline getline will see that the buffer is certainly not large enough and will allocate enough space","width":502},{"text":"we can now find out what the result is which is the number of characters getline has managed to retrieve","width":519},{"text":"or a negative value if it failed","width":127},{"text":"so let's make a note of that","width":146},{"text":"and we'll print this out","width":125},{"text":"so i'll print it out as an integer and let's have a look to see what we can find inside our buffer","width":445},{"text":"so we want the result and we want the buffer","width":227},{"text":"and lastly let's put a newline here","width":169},{"text":"okay so we'll run our little program here","width":385},{"text":"and now it's waiting for me to type something","width":368},{"text":"okay great so it says i have got six characters","width":218},{"text":"wait and i printed ABCDE","width":102},{"text":"actually the last character might be a newline character","width":355},{"text":"and quite often we don't actually need that","width":152},{"text":"so why don't we overwrite the very last character with null with a terminating byte","width":439},{"text":"so let's write the code for that","width":160},{"text":"first of all we only want to do that if we get at least one character back from getline","width":289},{"text":"so let's check that the result was positive","width":300},{"text":"and also we only want to do this if we are going to overwrite the last character which truly is a newline","width":385},{"text":"we could imagine for example reading from a file where the very last byte is not actually a newline","width":363},{"text":"so we should just check to see what we're going to write here","width":233},{"text":"so let's look inside our buffer and where do we want to look?","width":275},{"text":"well if we read one character that would be at the beginning of the buffer","width":403},{"text":"so we need to look at result minus one","width":129},{"text":"so if that is equal to the character of a newline","width":352},{"text":"then let's truncate the string","width":262},{"text":"the easiest way to do that remember is strings are just terminated by zero","width":190},{"text":"so let's just put a zero directly into that byte","width":188},{"text":"so we are going to say at the same spot set that equal to zero","width":356},{"text":"right so let's run our program again","width":534},{"text":"okay so this time it read it correctly and in our printf we didn't get that unwanted extra newline","width":570},{"text":"alright our program right now is allocating memory on the heap","width":270},{"text":"we don't do it we let getline do it","width":127},{"text":"but it's actually up to us when we finish using getline to free that buffer","width":362},{"text":"right so let's do that","width":121},{"text":"let's at the very end here we can call free on the buffer","width":316},{"text":"we don't need to do that every time we call getline because getline by default will try to for performance try to reuse the buffer for each line it gets","width":576},{"text":"so for example we could call getline twice and it would try to use the same buffer","width":511},{"text":"but the big take home message for getline is first of all","width":186},{"text":"you are going to need a pointer to a buffer and a capacity variacle which getline itself is going to change the contents of","width":470},{"text":"as you call it it can make the buffer as large as","width":304},{"text":"each time you call getline it might change that buffer to point to some new memory if the buffer needs to be larger","width":439},{"text":"secondly it's a great idea to check the return value of getline to see how many characters it managed to read","width":469},{"text":"and also to see if there was an error or not","width":138},{"text":"and the return type for that is ssize_t for a signed size integer type","width":469},{"text":"and finally it's good practice to don't forget to free the memory that is pointed at by your buffer variable","width":546},{"text":"okay that's it for me","width":87},{"text":"have fun playing bye","width":78}],
  // Video 19
  [{"text":"Hello welcome","width":135},{"text":"so this video is a little introduction to signals","width":222},{"text":"so signals are like a software interrupt","width":198},{"text":"we can use them to control our processes and even do things asynchronously","width":322},{"text":"so let's have a look at a little program i have written so far that doesn't use signals yet","width":333},{"text":"all it does is ask for the environment of home","width":181},{"text":"in other words the user's home directory","width":172},{"text":"and then we have a little loop that prints it out and sleeps for three seconds","width":314},{"text":"so every three seconds it is going to print out my home directory","width":211},{"text":"and on this machine i am root so it just keeps on printing out slash root","width":387},{"text":"so of course we can stop this program by pressing control c","width":383},{"text":"and when you do that you actually are sending a signal","width":195},{"text":"sigint or sig interrupt to the process","width":261},{"text":"now it maybe that our process doesn't like being interrupted","width":198},{"text":"why don't we catch that signal and install our own little handle for that","width":319},{"text":"so here is how we will do this","width":158},{"text":"i am going to say at the beginning of my program that if you get a certain signal say sigint ","width":797},{"text":"rather than having the default behavior which as we know is to stop the program or quit the program","width":367},{"text":"let us run my code instead","width":113},{"text":"so i will call it say nothankyou","width":227},{"text":"so what is nothankyou","width":113},{"text":"it has to be a pointer to a function","width":252},{"text":"how do we do that","width":61},{"text":"easy just write a function","width":75},{"text":"and in this case the correct type is something that doesn't return anything","width":310},{"text":"but does take an integer","width":136},{"text":"in fact it is the signal that is being sent to our program","width":253},{"text":"and so that we know that this is being called let's write something out directly to standard output","width":342},{"text":"so i can say write and i can say no","width":219},{"text":"so what is that that is a little message of three bytes to send","width":228},{"text":"so let's run this now","width":155},{"text":"okay so here is my program every three seconds it is going to print root","width":248},{"text":"but now i am going to press control c","width":359},{"text":"and it prints no no so it's refusing to quit","width":405},{"text":"you might also notice that the sleep also immediately returns","width":242},{"text":"more about that later","width":99},{"text":"it is still possible to stop our program here","width":180},{"text":"if we do control backslash then we force it to quit","width":382},{"text":"so sigint is one common signal that we send our programs","width":259},{"text":"there are many others","width":92},{"text":"just for fun let me show you one called sigalarm","width":239},{"text":"so this time i am going to say alarm seven seconds","width":498},{"text":"and so when you call alarm you are going to say give me a special signal called sigalrm in this many seconds","width":626},{"text":"in seven seconds","width":82},{"text":"and we better install then","width":112},{"text":"well let's just run it and see what happens to begin with","width":795},{"text":"so the default behavior of this sigalrm is to actually stop our program","width":299},{"text":"it quits the program","width":103},{"text":"that's a pretty aggressive alarm clock i think you'll agree","width":175},{"text":"and it also as you see prints out alarm clock on the shell","width":233},{"text":"perhaps we don't want our alarm signal to be so menacing","width":308},{"text":"so this time instead of sigint i can say look for a certain signal called sigalrm","width":452},{"text":"please call my function instead","width":515},{"text":"okay so there we go our alarm went off after four seconds and this time we asynchronously ran our code that printed out no to standard out","width":704},{"text":"so this is pretty exciting right","width":98},{"text":"you probably thought about interrupts on the hardware level","width":228},{"text":"now we can do interrupts at the software level and we can respond to things which happen in our environment very quickly","width":459},{"text":"so we will find signals to be very useful when we start dealing working with more than one process","width":381},{"text":"we can control our programs and we can also work with very large amounts of data coming in","width":371},{"text":"alright that is enough for me","width":106},{"text":"bye","width":36}],
  // Video 20
  [{"text":"so usually we think about our programs as just turning into one single process","width":299},{"text":"now i am going to show you some systems programming magic","width":187},{"text":"where actually we can turn our single process into two","width":217},{"text":"here is how we are going to do it","width":105},{"text":"let us have a very simple program that says hello world","width":216},{"text":"and here it is","width":138},{"text":"so between these two lines however","width":198},{"text":"i am going to call fork","width":426},{"text":"and here's a surprise","width":91},{"text":"we get hello world world","width":90},{"text":"yes we get two worlds","width":129},{"text":"why is that","width":65},{"text":"well at the beginning there was a single process","width":117},{"text":"but then we called fork and now our single process is actually being cloned","width":340},{"text":"it has been split into two","width":111},{"text":"so both the processes print out world","width":164},{"text":"and so we see both their output on our little terminal here","width":297},{"text":"okay what else can we do with this","width":97},{"text":"well let us first of all show that there really are two different processes","width":192},{"text":"i am going to look at their processor id","width":351},{"text":"and we will print it out","width":168},{"text":"so i will call getpid()","width":102},{"text":"and you will see that yeah i have got two different processes","width":258},{"text":"both trying to run at the same time","width":191},{"text":"in fact i have got a parent child relationship here","width":289},{"text":"i have got the original process","width":128},{"text":"the parent","width":63},{"text":"and you can think of fork as saying let us clone this original process right here right now","width":375},{"text":"so that i get a child that looks just like me","width":153},{"text":"or at least almost like me","width":111},{"text":"in many many respects","width":63},{"text":"it is the same memory","width":152},{"text":"it has got it's own variables","width":63},{"text":"but because its got its own address space","width":251},{"text":"what the child now does in terms of its memory is seperate from the parents","width":369},{"text":"okay so let's show you what we can then do with this","width":330},{"text":"first of all fork actually returns something here","width":154},{"text":"it actually returns back an id","width":192},{"text":"so let's make a note of that","width":188},{"text":"and we'll print it out","width":124},{"text":"so we'll say %d and we'll print out just here","width":552},{"text":"okay so here is what we see","width":166},{"text":"that the process id 681 has fork value of 682","width":562},{"text":"and process 682 has a fork return value of 0","width":386},{"text":"so the fork value is different for the parent and the child","width":290},{"text":"and in fact fork","width":173},{"text":"if it returns a positive number is talking to the parent","width":238},{"text":"and is telling the parent here is the id number for your child","width":333},{"text":"so let us make a note of that","width":162},{"text":"let us call this","width":75},{"text":"here is my child","width":63},{"text":"so i can call my child","width":149},{"text":"and then i can write an if statement to decide if i am the parent or the newly created child or not","width":466},{"text":"so we will say look if the child id what i return from fork is actually greater than 0","width":470},{"text":"then i am the parent","width":194},{"text":"so let's put something like hey i'm the grouchy parent","width":575},{"text":"if it is zero however then hey I'm the carefree child!","width":905},{"text":"so we will let's remove this ","width":254},{"text":"i'll get rid of that line now","width":83},{"text":"okay so now we have a little program where the parent and child are going to do two different things","width":381},{"text":"and in fact it is standard for the parent to wait for the child to finish","width":438},{"text":"we don't have to but quite often we need the child process to do something for us","width":436},{"text":"perhaps in the background","width":112},{"text":"but we don't actually want to continue until the child has finished","width":234},{"text":"so let us do that","width":88},{"text":"what i am going to wait for my child to finish","width":262},{"text":"so i am going to say waitpid and i need to say okay what is the id i need to wait on well here is the childid","width":566},{"text":"and later on i can ask for some status information about my child","width":345},{"text":"and for now the last argument i am just going to put as 0","width":189},{"text":"so i need to have a variable called status just a little integer","width":299},{"text":"and in fact we are going to pass not just the value of status but the address of our little variable","width":400},{"text":"and later on we can use that to find out say did our child exit normally or was it terminated in a surprising way","width":492},{"text":"so let us run this now and what we will expect to see is that we'll wait for the child to finish before we print","width":519},{"text":"I'm the grouchy parent","width":63},{"text":"so let's run this","width":393},{"text":"okay so this time the child process got to print out I'm the carefree child","width":442},{"text":"then it exited","width":119},{"text":"meanwhile the parent was waiting for the async condition and when that happened","width":342},{"text":"the parent is able to continue and is able to print I'm the grouchy parent","width":416},{"text":"so i want to finish on a common programming error that can really bring down a server","width":564},{"text":"and that is suppose we made many many many processes","width":406},{"text":"so it is one thing to create a few","width":142},{"text":"let's call say fork a couple of times and perhaps you can guess how many worlds we'll see here","width":971},{"text":"that's right we see four worlds","width":146},{"text":"and in fact the parent finished early so this is the hash of the terminal saying what would you like to do now","width":540},{"text":"but we had four processes all printing out world","width":212},{"text":"and if we had three forks now we have eight","width":311},{"text":"okay so let us make something now called a fork bomb which is where we keep creating lots and lots of processes","width":550},{"text":"and this often happens by accident by people who are new to systems programming","width":326},{"text":"but just for fun because i am just doing this inside a browser it doesn't matter if i bring my little virtual machine to a halt","width":582},{"text":"i can always just reload the page","width":114},{"text":"so let's print out my id","width":630},{"text":"i will put this in a little loop that says while one let's fork","width":327},{"text":"let's print out my process id","width":347},{"text":"and then i will sleep two seconds","width":460},{"text":"so initially i have two processes","width":111},{"text":"and then each of those processes calls fork","width":209},{"text":"so we got four","width":51},{"text":"and then each of those processes call fork","width":171},{"text":"prints it out and sleeps","width":93},{"text":"and so every two seconds i am doubling the number of processes that are in my system","width":291},{"text":"so that's a lot of processes","width":124},{"text":"and in fact pretty soon the kernel will run out of space","width":324},{"text":"it won't be able to keep track of any more processes","width":138},{"text":"and fork will stop working","width":220},{"text":"and now we see here's the kernel printing out all sorts of debug messages","width":248},{"text":"desperately trying to make the system stable again","width":190},{"text":"as it arbitrarily starts to kill processes in an attempt to recover some memory and space in its process tables","width":539},{"text":"so amazingly my little kernel here has managed to recover to the point to where i have a working system","width":500},{"text":"but that is fork bombs and you should avoid from accidentally doing this","width":346},{"text":"otherwise you will have a system administrator telling you that you cannot log onto that machine anymore","width":286},{"text":"okay have fun and i'll see you in the next video","width":194},{"text":"bye","width":39}],

  // Start Lecture Video 0
  // Video 21
  [{"text":"okay, good morning class, how are you","width":367},{"text":"I'm good thank you","width":103},{"text":"alright, for those of you that weren't paying attention, cs241 has started. good morning class, how are you?!","width":373},{"text":"alright, great. so, in the next 15 minutes the game of course is for you to leave this room with more passion for system programming and maybe some more knowledge about how to do it as well","width":668},{"text":"and maybe some knowledge about how not to do it as well","width":210},{"text":"so one of the intents here is cover gotchas and common programming mistakes","width":280},{"text":"so, if you have a burning question, there's probably someone else in this room that has the same question","width":321},{"text":"I will endeavor to answer as many questions as possible without derailing the lecture","width":238},{"text":"so feel free to speak up","width":135},{"text":"if it's not appropriate, I will tell you","width":115},{"text":"and, just stay, come down and talk to me afterwards","width":147},{"text":"also, I hold office hours usually three times a week immediately after lecture","width":265},{"text":"because I figured thats the best way to reach most of the students","width":238},{"text":"so feel free to stop me","width":150},{"text":"I may not be able to stay for a full hour every time","width":157},{"text":"for example, there's a faculty meeting today where we're talking about how to take over the world","width":276},{"text":"uiuc style","width":83},{"text":"but most times I'm there to help you","width":286},{"text":"and I love to see people progress. its fantastic stuff when you start from the beginning of this course when you don't know anything","width":397},{"text":"till the end where you can actually do some pretty cool things","width":187},{"text":"and by the way, last semester many students came to me to say \"hey! you know what? I just had an interview and they asked me to explain X\" where X is a cs241 thing","width":657},{"text":"such as, what's the difference between a process and a thread?","width":223},{"text":"whats the difference between stack memory and heap memory?","width":136},{"text":"how would you do that?","width":55},{"text":"what's a common gotcha with this?","width":104},{"text":"why would a C program crash? that kinda stuff","width":265},{"text":"so you might find that the knowledge you gain in this class actually has an immediate impact for you outside of this class","width":413},{"text":"and if it does, wonderful!","width":160},{"text":"alright, so, let's get started with a couple of trick questions","width":333},{"text":"that we have here, wanna go to overhead, right!","width":292},{"text":"okay! how do you look up information for C library calls and system calls?","width":228},{"text":"easy! okay, here's the beautiful thing. with POSIX, POSIX includes many things","width":605},{"text":"it includes an API (application programming interface) in other ways, instead of calls, you can call","width":392},{"text":"and also, a manual of man pages about those calls","width":374},{"text":"so guess what? we're actually going to look up different calls","width":227},{"text":"the art of course is knowing which calls you should use","width":329},{"text":"and the POSIX man pages aren't going to tell you that","width":202},{"text":"you already have to have a basic idea of \"oh yeah! I need to use open\" or \"or yes! I need to use write or stat or lstat or fork()\"","width":629},{"text":"so that's the main thing you're going to get out of this course is the vocabulary","width":264},{"text":"with the then end expectation that you would actually then start to use this stuff and look it up","width":320},{"text":"so we've got two different kinds of things. we've got C library calls and system calls","width":463},{"text":"the C library is the part of your process","width":188},{"text":"okay, what's the difference between a program and a process?","width":153},{"text":"well, the program is the code that you've written turned into bytes which say you stored on disk","width":339},{"text":"and then when you actually execute it, or actually run it, it becomes a process","width":274},{"text":"and of course you can have multiple processes running for the same piece of program code","width":310},{"text":"but part of that process is the C library","width":146},{"text":"it comes kind of bundled with or loaded at runtime and it's a set of code and maybe some constants too that just runs as part of it","width":524},{"text":"so what kind of C library calls do we have? well for example, perhaps you want to do a string copy where you want to say \"okay, copy all the bytes into a destination from a source\"","width":787},{"text":"and we're gonna pass two pointers and it will keep copying those bytes starting from source into destination until what?","width":666},{"text":"until it reaches a zero byte","width":156},{"text":"because that's the definition of a C string","width":192},{"text":"of course, bad things might happen if you accidentally put these in the wrong order","width":312},{"text":"alright, if you tried to copy from some arbitrary place into a different place, who knows how many bytes its gonna copy before it gets to zero? oops.","width":512},{"text":"who knows where its going to immediately crash your program?","width":171},{"text":"for example, it might be that you try to write into some read only memory","width":306},{"text":"and the hardware say \"ah ah excuse me? excuse me? you see that process over there? it's being a baaad baaaaad process\"","width":483},{"text":"ok lady gaga I might","width":107},{"text":"so, look I enjoyed that joke personally","width":296},{"text":"so, let's um, this is an example of a C library call. it doesn't need to go into the system to run this","width":635},{"text":"we can do this entirely inside the process space","width":218},{"text":"inside the virtual memory of our proces","width":226},{"text":"ok, what about system calls? well, here's an example of one, you've already seen it: \"write()\"","width":412},{"text":"we want to get outside of our system. we want to break out of our system and get the system to break outside of our process and do something","width":444},{"text":"to the rest of the world","width":123},{"text":"okay, so, the system itself needs to handle that particular call","width":361},{"text":"and in fact it does that using a hardware interrupt","width":262},{"text":"that's the red pill, if you follow the matrix movie","width":218},{"text":"that's how you escape out of the box. out of the sandbox that your poor little process is stuck inside","width":508},{"text":"anyway, so we want to look up say some information about these and so for that we can use \"man\"","width":420},{"text":"which reads man pages","width":154},{"text":"which are incredibly terse and utterly useless if you dont have some basic knowledge","width":322},{"text":"but pretty useful if you already know something about what you intend to do","width":369},{"text":"so let's try one","width":276},{"text":"box pc","width":392},{"text":"okay so let's try looking up for example \"printf()\"","width":317},{"text":"there it is","width":44},{"text":"and it's in section 3 of the man page","width":96},{"text":"okay yeah, we want to open it. there it is","width":125},{"text":"now what do we see about these man pages? well the things I want to show you is that first of all it tells you what includes you better have","width":448},{"text":"it also includes a whole load of function calls which do similar things","width":300},{"text":"so, as well as printf, we've got sprintf or snprintf","width":367},{"text":"and, then we've got some really terse information on what it's gonna do","width":286},{"text":"and usually its got a return value as well","width":299},{"text":"so they might return say the number of characters printed","width":316},{"text":"excluding the NULL byte used to end output strings","width":192},{"text":"notice how those display little parenthesis here as if its not that important","width":325},{"text":"as if the number of bytes written is not that important to you","width":189},{"text":"as if that could never cause a big program to fail","width":239},{"text":"accidentally, you might assume that that is the actual number of bytes written","width":218},{"text":"no no no, it excludes it and it's an off by one error","width":172},{"text":"it's actually going to ignore the fact that it may have written a zero at the end because it's the end of a C string","width":394},{"text":"oops! that's exciting.","width":107},{"text":"you may have not had enough memory. you may have overwritten something else","width":306},{"text":"so, when you read man pages, read them slowly and try to understand everything they say","width":443},{"text":"and of course, it's always useful to find an example","width":266},{"text":"oh, this one actually has one, look at that! amazing","width":194},{"text":"most of them don't bother with an example","width":101},{"text":"so you end up doing any google search to say \"okay, easy example of blah blah blah blah\"","width":339},{"text":"but yeah so they're a good reference material","width":220},{"text":"now you'll notice we had different sections","width":137}],
  // Video 22
  [{"text":"Let's do another one","width":182},{"text":"Let's look for fork - create a child process. Yes, that's right, you create children by forking","width":922},{"text":"I knew you'd remember something from this lecture. We'll play more with this later because it's an amazing thing you can do with posix. You're first process can actually clone itself, at that very moment to become two separate processes","width":1221},{"text":"It's like you pull a switch and suddenly you've got a doppelganger","width":347},{"text":"If you're a physicist and you think about the many worlds theorem, it's a bit like that. The world from a process point of view splits into two. Suddenly you've got two processes for the price of one","width":681},{"text":"OK, so we'll see that. But again, notice we had different sections","width":265},{"text":"The sections you're going to see are.... can you see this? let's see if we can make it bigger","width":721},{"text":"section two, alright. This is where all the system calls live","width":368},{"text":"section three, this is where you'll find the C library stuff","width":275},{"text":"and section seven, you'll occasionally find there's actually longer articles. I hesitate to call them tutorials, they're not that useful","width":668},{"text":"but more long winded articles that have some better practices. it's worth reading at some point during this course","width":472},{"text":"you might find some useful information there. for example, when we talk about signals, but most of the time you'll be using these as reference","width":496},{"text":"unfortunately, let's go back to here and look up stat. some words appear in multiple places and if I make a new window here","width":970},{"text":"and I do man stat, then I get the wrong one. I get the one that would happen from the shell. So i have to say 'no, no, no I really wanted section two'","width":942},{"text":"so sometimes you have to force it to find the right section","width":411},{"text":"that's enough about man pages. you will be using them. when it comes to quizzes, i'll talk more about that later, but i will have expected you to know something basic about the return values, some of the common gotchas of using different calls","width":1074},{"text":"do you remember how to allocate memory on the heap?","width":398},{"text":"if your neighbor said 'malloc' congratulations, you made a good seating choice","width":356},{"text":"yes, malloc is one way to say 'hey, I need some memory and it's mine until I what?'","width":855},{"text":"free it, yes! ","width":216},{"text":"when you call malloc you are going to point to some bytes. will those bytes be zero?","width":788},{"text":"do you feel lucky punk? the answer is maybe, but it's not guaranteed. ","width":411},{"text":"if you get a brand new, fresh page of memory from the OS it's likely to have been zeroed out by the OS to make sure you don't accidently get any information from another process","width":831},{"text":"remember, we're trying to keep our processes separate, so you can't accidentally read someone else's password, or secret key, or something else that's secretly happening inside another process","width":550},{"text":"the OS makes sure to usually give you some zeroed memory","width":315},{"text":"however, if it's reuse of your own memory, it's quite likely there's just garbage in there","width":493},{"text":"it could be that because it's zero it lulls you into a false sense of security, you assume memory is zero","width":607},{"text":"why did C do this? sounds like a terrible thing to put the onus on programmers to make sure their programs always work. why didn't they always zero out the memory?","width":941},{"text":"time consuming, yes! C is all about trying to be as efficient as possible and if you can't cope with that, get a different major","width":725},{"text":"That is C's attitude, maybe we can find tools to spot memory errors, but it's very much a case of we're trying to write a language which is just a little bit above assembler. it's meant to be that it's almost as efficient as assembly code, just a lot easier to read and write","width":1409},{"text":"malloc has to be very efficient because we use it a lot. think about your java programs, OK I'm sorry. I know that was a bad experience, but think about all the times you've made new objects, etc.","width":832},{"text":"underneath that we're saying 'OK, I need some more memory'","width":276},{"text":"so malloc's job is to find some bytes. you say 'oh quick, I need another thirty two bytes and I need it right now. I can't continue my process untiil you give me thirty two bytes fo rme to play with. And, yes, I promise to free it later when I'm finished with it.'","width":960},{"text":"some processes are allocating a lot of memory all the time. so malloc tries to be efficient and when you free some memory, we can put it back into this pool of bytes that we can use later again. That's why it's called a heap, it's just going to be a big disorganized mess of allocated space and unallocated space","width":1346},{"text":"And, in fact, it's tricky to write malloc and free, so we are going to ask you to do it in 241","width":491},{"text":"we've got malloc and free. later on you'll also see halloc and realloc, but let's not talk about those now","width":580},{"text":"you can just implement those on top of malloc","width":389},{"text":"suppose we wanted to write our own string copy function. here it is!","width":562},{"text":"because these are character pointers, I should mention, how big is a character in C? ","width":638},{"text":"the size of a single [byte]","width":221},{"text":"if I do sizeof character,the answer is one. everywhere, at all times, before I even compile the code. it's a definition that the size of a character type is one","width":1079},{"text":"sizeof gives you the number of bytes","width":416},{"text":"so a character is always one byte. If i put a variable name in there I'd get one","width":618},{"text":"when I add one to these pointers, it is going to be incrementing along one byte at a time. I read one byte and I add one to the source pointer and add one to the destination pointer","width":902},{"text":"this code is slightly broken. perhaps you and your neighbor can figure out how it should be fixed. i'll point out the following","width":742},{"text":"what does this do? while star source","width":363},{"text":"thank you, yes! remember star means dereference, follow the money, take this expression and use it as a memory pointer and actually tell me what's in there","width":649},{"text":"because we're talking about a character pointer, we are asking memory to read just one byte. if we had an int pointer we might be reading four or eight bytes","width":553},{"text":"but, no, we're reading one byte. while this is non-zero, do something. with C, anything which is a non-zero value is true","width":679},{"text":"what a wonderful simple world","width":185}],
  // Video 23
  [{"text":"my love for you is 42","width":170},{"text":"so this means this is going to continue until we get that null byte","width":386},{"text":"alright that's enough hints","width":107},{"text":"let's fixed that code","width":185},{"text":"right so see if you and your neighbor can fix this code faster than your other neighbor that you're not talking to","width":724},{"text":"it's not copying the string, that's one of the bugs","width":3769},{"text":"copy the bytes so actually we didn't just want to copy src into dest ","width":331},{"text":"all this would do is whatever the value of src is whatever the value of src is i is just some memory location, we set that into dest","width":456},{"text":"but dest is just a local variable so that would actually do nothing, it would actually just change src into dest","width":419},{"text":"what we want to do is just use src as a pointer","width":226},{"text":"so we need to put a star in here","width":168},{"text":"there we go","width":38},{"text":"right so we should have read the value at src hey go back to memory and then use dest as a pointer","width":424},{"text":"we wanted to dereference it ","width":75},{"text":"we wanted to say okay now write that value into whatever dest is pointing to","width":269},{"text":"so we've done that, we've copied one byte and we increment both pointers","width":251},{"text":"and then we go back around the loop so we're going to keep writing bytes until we get to the null byte","width":335},{"text":"is my function finished?","width":141},{"text":"no, what's wrong with it?","width":284},{"text":"yes thank you, yes we forgot to copy the null byte","width":289},{"text":"so this function is broken it forgot to copy the null byte","width":266},{"text":"but it might work if you test it if you happen to test it with memory that was already zero","width":417},{"text":"and you think aha I finished my mp","width":162},{"text":"right, no your code is broken","width":178},{"text":"because is forgot to terminate the C string","width":172},{"text":"and then some future function would start reading this and it wouldn't come across a null byte because there would be garbage after it","width":453},{"text":"and it would start printing random characters","width":274},{"text":"until it eventually got to a null byte","width":183},{"text":"of course if it didn't get to a null byte maybe other bad things would happen","width":192},{"text":"anyways so let's fix this","width":123},{"text":"we needed one more line to say after the while loop ","width":157},{"text":"alright the src should be a null byte which I could write like this","width":926},{"text":"okay here's another example of a classic C error which is when you've got two pointers you're probably using the wrong one","width":629},{"text":"okay so make sure that we change the very last byte at the end to be a zero byte","width":372},{"text":"so we terminate it","width":113},{"text":"we could have also fixed this by using a do while loop instead of a while loop","width":506},{"text":"so we would have only done the check at the very end","width":137},{"text":"we would have copied at least one byte","width":128},{"text":"alright so that was my string copy","width":156},{"text":"how about something that actually duplicates strings","width":424},{"text":"right so we want something that takes a character to some memory and we are going to make a new memory object","width":642},{"text":"and we're going to copy the contents of the original into our new piece of memory","width":347},{"text":"right so how do I get some new memory? easy I remember what I said ten minutes ago and say malloc","width":610},{"text":"so I've got malloc I've got the right size I copy.. whoops wait a moment I've got two pointers am I using them in the wrong direction?","width":673},{"text":"if in doubt, yes I probably am right?","width":159},{"text":"how do we check? easy go back to the manpage alright","width":293},{"text":"man let's try strcpy and BSD kindly calls them s1 and s2","width":906},{"text":"okay copies a string from s2 into s1","width":155},{"text":"yes we managed to do it the wrong way round","width":163},{"text":"what we should have done is swap these around","width":664},{"text":"by the way is this text large enough to see at the back?","width":182},{"text":"can you give me a thumbs up if it is?","width":200},{"text":"alright so most of you","width":104},{"text":"alright I'm assuming the people who didn't are going to sit closer to forward in the future","width":260},{"text":"but seriously let me know if it's not","width":190},{"text":"okay right is our code finished? okay we run it and it doesn't work, it might crash","width":764},{"text":"here's one problem, what's the size of src? what will this give us?","width":461},{"text":"one, we've managed to allocate enough space for one byte","width":221},{"text":"and then we try to write into that one byte","width":295},{"text":"okay that's fine if our string is very short, just one byte long","width":366},{"text":"not so fine if our src strings were longer","width":207},{"text":"so we shouldn't have done this right?","width":175},{"text":"what we wanted to know was the number of characters at the src","width":301},{"text":"so how can we do that?","width":219},{"text":"call strlen of src","width":500},{"text":"so now we test it and it almost works but it still crashes","width":218},{"text":"here's the issue, strlen tells us about the number of characters excluding the null byte at the end","width":380},{"text":"look C is trying to help you give off by one errors","width":292},{"text":"what a polite language, if it's not my fault it's your fault","width":283},{"text":"alright look we only need to add one to that","width":198},{"text":"that's just evil huh? who came up with this","width":254},{"text":"alright so when you write a language don't do this","width":442},{"text":"make your strlen actually say how many characters, how many bytes it actually took","width":288},{"text":"okay so we've got now we're calling malloc and we copy from the src ","width":539},{"text":"so this should be p, this should be from the src into our memory and finally we return p","width":379},{"text":"is it okay to turn p because look p is an automatic variable","width":252},{"text":"it's a local variable","width":53},{"text":"is that a problem? no because we are not returning a pointer to p itself","width":299},{"text":"we are running the contents of p","width":123},{"text":"and p is just looking at this memory that we've malloc'd and that memory that we've malloc'd will exist until we free it ","width":473},{"text":"now malloc itself returns a void pointer and if we wished we could cast that changes type into a character pointer","width":562},{"text":"in practice you don't need to","width":411},{"text":"that if you have a void pointer it's okay, it's allowed to cast it implicitly to a different type","width":526}],
  // Video 24
  [{"text":"alright so, is our code any good?","width":185},{"text":"yes, question?","width":629},{"text":"okay, so, this was discussed on piazza. it makes the code a bit more cluttered. if you do too many casts, you're forcing your way, you're saying: \"hey compiler, trust me I know what I'm doing\"","width":1076},{"text":"which is fine until the day you don't know what you're doing","width":166},{"text":"and you've just casted something which is incorrect","width":159},{"text":"maybe you're casting a pointer to a pointer to a pointer.","width":271},{"text":"and you would've potentially gotten a compiler error but by explicitly casting, you won't get any error","width":551},{"text":"so that's probably the biggest issue","width":76},{"text":"yes","width":411},{"text":"oh, I'm so, yes, you're right. I forgot that it's a character pointer. it would not have returned 1. it would've returned say 4 or 8 or however big your pointers were on your platform","width":958},{"text":"so, if its a 32 bit platform","width":323},{"text":"then how many typical bytes do you need?","width":406},{"text":"well, 4 bytes to hold 32 bits","width":134},{"text":"if its a 64 bit machine, then you'd need 8 bytes","width":594},{"text":"right, so, our code looks pretty good except one little issue. if you read the manpage of malloc, you can discover that malloc() can fail. and when it fails, it returns","width":686},{"text":"quick! read the man page!","width":77},{"text":"right, when it fails to give you any memory, it returns NULL","width":322},{"text":"so, we should check for that","width":100},{"text":"because right now our code would attempt to write into that 0 location","width":358},{"text":"if malloc fails","width":48},{"text":"so what we should do is, here is, we should, if p or not p which is another way of saying \"hey, is p zero\"","width":1196},{"text":"I didn't give any memory so no new string duplication for you","width":285},{"text":"and hopefully the code that calls my code actually bothers to check to see whether it got a valid pointer or not","width":517},{"text":"alright, okay, any other questions?","width":288},{"text":"alright, what's a double free?","width":438},{"text":"okay, so, let's say we free pointer, and then for some reason later, we free the same pointer","width":703},{"text":"in other words, we called free twice on the same memory block","width":241},{"text":"is that a bad thing?","width":148},{"text":"yes, that's a bad thing","width":144},{"text":"okay, here's why","width":118},{"text":"when you call free, the memory allocator says \"oh, look!\" he or she is finished with that memory so I can put it back into my free pile","width":717},{"text":"and I might allocate it again when someone asks for more memory but I'm going to update my linked list structures and whatever internal structures I have to keep a count of what memory is free","width":871},{"text":"so if you call free again, bad things may happen to those linked list structures","width":403},{"text":"bad things may happen to other code that's already actually using that memory space","width":467},{"text":"alright because between you freeing it and freeing it again later, it could be that another malloc has come in and been given that memory","width":589},{"text":"so when you double free, really exciting things can happen","width":217},{"text":"you have no idea what's gonna happen next. you have broken the universe at this point","width":369},{"text":"because, artibrary things can happen to your heap memory and who knows what the rest of your program is doing to your heap","width":538},{"text":"so, how can you avoid it? well, there's a couple of ways. first of all, don't write this code","width":368},{"text":"secondly, it's a good practice in production code to set your pointer to zero","width":393},{"text":"in other words, don't have, what are these pointers called now?","width":497},{"text":"the dangling pointer!","width":67},{"text":"it's a pointer to some memory address that is no longer yours to play with","width":308},{"text":"because say you free'd it","width":128},{"text":"and you don't want another piece of your code to accidentally use that pointer","width":461},{"text":"so, when you free memory or decided to use memory for some other purpose, it's good practice to set pointers to that memory to zero","width":901},{"text":"this of course looks very easy and trivial to avoid. in practice, these two frees could be somewhere arbitrary in your program. maybe someone kind of tries to free your data structure twice","width":833},{"text":"and then you end up calling free on some memory twice","width":453},{"text":"right, okay, let's have an example of a buffer overflow","width":466},{"text":"well a buffer in C can be anything. for example, it could be just a simple array","width":298},{"text":"so, let's make an array myData","width":722},{"text":"and this says, \"okay, I need space for 8 bytes or 8 characters\" and","width":1022},{"text":"let's set one of those entries to p. is that allowed in C?","width":681},{"text":"okay, so that's a trick question. yes, the compiler will compile that for you, it might give you a warning, it might get an error if you've racked up enough options","width":772},{"text":"but remember, what are we doing here is we're just simply saying \"okay, take whatever data's pointing to, add 8, times whatever the size of each entry is, and then use that to change some memory\"","width":737},{"text":"we actually want a bit representation in our p","width":360},{"text":"but, when we did this, we only asked for enough space for 8 entries. and we're trying to write a 9th entry. oops!","width":723},{"text":"we could also have run into the same problem if we had string copy","width":555},{"text":"one two three four five six seven eight","width":386},{"text":"ahh, I did it the wrong way around","width":409},{"text":"okay, so there's two things wrong with this code. first of all, the arguments is the wrong way around","width":534},{"text":"second of all, how many bytes is this going to write?","width":272},{"text":"into memory?","width":98},{"text":"nine!","width":51},{"text":"I've got the digits 12345678, and the NULL byte at the end to say \"hey! my string is finished\"","width":457},{"text":"but we only made space for 8","width":230},{"text":"so that ninth byte. what's that ninth byte being used for? maybe it's being used for another variable in which case we've just overwritten the value of another variable","width":636},{"text":"and that is how many C programs are vulnerable to buffer overflow","width":407},{"text":"that is how you could hack into say, a web application which didn't put enough space on a buffer","width":735},{"text":"and you could then overwrite nearby variables","width":290}],
  // Video 25
  [{"text":"let's do our last little thing here. what is typedef?","width":553},{"text":"it's just an alias","width":213},{"text":"we've got some basic types in C, but you can use the keyword typedef to say 'hey I need something else'","width":625},{"text":"I might have an unsigned int","width":428},{"text":"OK, that's a lot to type. I'm just going to call that my u int or I'm going to use an unsigned int to represent process identifiers for example. So don't be scared when you see typedef, it's just being able to alias a particular type so that you can have a short name for it","width":1430},{"text":"questions? yes!","width":426},{"text":"because writing struct x is painful and people don't want to have to write the keyword struct everytime","width":1247},{"text":"let's say I have a struct called poem","width":989},{"text":"now I'd have to say 'right suppose i wanted some memory'","width":203},{"text":"I want a pointer to a poem, so struct of poem pointer malloc sizeof struct poem","width":769},{"text":"it's kind of annoying to keep writing struct everywhere, yes? so instead you'd say typedef and that can be my poem struct","width":1168},{"text":"And then you might go further and say I want a poem pointer, so poem_s star poemptr","width":824},{"text":"then you might write this code and then you might write this code and that would be wrong","width":722},{"text":"whoops, look, i just tried to get the size of my pointer. that's going to be four bytes or eight bytes","width":322},{"text":"I didn't want that, I wanted the sizeof my original structure. be careful when you start playing with typedefs","width":932},{"text":"you'll see typedefs commonly used with structs and for things like unsigned ints","width":1041},{"text":"let's not compile this code for now","width":674},{"text":"instead let's print some things out here. how can I print strings out and single characters? well you've seen printf, fantastic. guess what? there's also","width":773},{"text":"putchar sixty five and that's going to print","width":565},{"text":"a single 'a'","width":203},{"text":"so if you wanted to print out a single character, there are these C calls like putchar","width":607},{"text":"if you want to print out a line, there's put s","width":417},{"text":"Hello World","width":315},{"text":"'It prints a new line too'","width":407},{"text":"so that's useful if you know that all you need to do is print out a C string. it will print out a c string followed by a new line","width":658},{"text":"all of these calls underneath end up calling, what? ","width":423},{"text":"yes, they call write","width":254},{"text":"<gibberish> some point your C library says I've had enough holding these bytes, I want to get rid of them, I want to flush them, I want to send them out and when it wants to do that it calls write to the OS","width":766},{"text":"it turns out actually you don't need to print everything to stdout. your processes by default have two output streams. one called standard out, one called standard error. let's prove that","width":1202},{"text":"let's use fprintf. I'm going to say something like 'this is using printf' and we'll try to run that and it doesn't work","width":829},{"text":"we get an error because we haven't given enough arguments to fprintf and in fact the. let's look it up","width":1177},{"text":"fprintf, yeah we need the file stream first. we can say standard error","width":830},{"text":"here's the thinking, here's why standard out and standard error exist and they're not quite the same","width":293},{"text":"quite often when we want to use these tools we want to process the output of one tool and send it immediately into the input of another tool","width":505},{"text":"but what about errors? well we'd like to see them still in the terminal, we'd like to send them to a different file","width":375},{"text":"you're compiler for example, might send - ahh","width":339},{"text":"what have we done wrong here? standard error undeclared? ah","width":910},{"text":"OK, great, that really did print. This is using fprintf. We can send things to these two different output streams and you too can make your own output strings by using fopen","width":1145},{"text":"And also they have different bufferings","width":716},{"text":"What've we got here? I've shown you things like puts and putchar","width":730},{"text":"how do I print - use fprintf, for example, I can send it to standard eror, blah blah blah","width":672},{"text":"is standard error buffered like standard out? no! standard error immediately calls write, it doesn't try to do any buffering","width":986},{"text":"standard out is a little bit diferent. standard out tries to have better performance, so rather than writing every single byte, let's collect a few up and once we assembled enough bytes then we'll call write and make it appear","width":964},{"text":"standard out by default when you're just looking at things in terminal buffers until you see a new line","width":672},{"text":"so if we see a new line, let's flush that buffer!","width":340},{"text":"in other words, call write on the whole buffer and out it goes","width":248}],
  // Video 26
  [{"text":"let's prove this while one do nothing ","width":2336},{"text":"right so we got the very first line over here","width":285},{"text":"from printing to standard error but we did not get the standard out line","width":346},{"text":"so look at my code, I said \"hey this is using printf and this is using printf exclamation point\"","width":272},{"text":"the difference between the two is that one of them went to standard error","width":163},{"text":"and we saw that straight away","width":102},{"text":"standard out that text is still sitting inside my process","width":286},{"text":"inside the c library because we didn't include any new lines and now my process has got stuck inside this infinite loop","width":575},{"text":"so now when I control C the program never has a chance to flush that buffer","width":401},{"text":"it never has a chance to write it out","width":225},{"text":"if I did just exit normally, if I did just say return 0 here","width":729},{"text":"then as part of the exiting, the C library says oh look I've got some open file descriptors","width":484},{"text":"I will make sure that my buffers are flushed","width":184},{"text":"so it does that at the very end as the program is finishing","width":425},{"text":"right oh and one last thing here, if you actually want to print into a C string","width":259},{"text":"the best thing to use is sfprintf but I'm not going to talk about that today","width":267},{"text":"but that's assemble things into, yes quick question","width":439},{"text":"there is two different streams so it's up to the terminal at the end to combine it into one and display it","width":465},{"text":"but we could make it so that the standard error goes to a completely different file or goes somewhere else","width":320},{"text":"let's have a look at page two","width":414},{"text":"okay when you free a null pointer, nothing happens, it's a safe operation by definition of the spec","width":727},{"text":"being thinking beings, you want to see errors as soon as possible","width":233},{"text":"you can actually change it there's a call called setvbuff if you want to change it but that's the idea","width":421},{"text":"right okay so which one should we do here","width":539},{"text":"let's do these three, these are the funnest ones","width":341},{"text":"the first three questions on this you can see on the wiki book","width":419},{"text":"I want to kind of go through these, first of all let's write our most exciting system program today","width":603},{"text":"I'm going to use this fork and for that we need to include unitstd.h so let's do that","width":1257},{"text":"so let's print something out in our little program here, let's find out what our process id is","width":512},{"text":"so I'll just do %d for now, that's good enough for this lecture","width":303},{"text":"let's call getpid to mean get my process identifier so we'll run this","width":684},{"text":"and next time I run it I'll have a new line as well so when I run it this time my program was process identifier 61","width":577},{"text":"and in fact if you do ps on a command line you can see all these different process little numbers","width":308},{"text":"and we'll use that later because we'll control them","width":198},{"text":"this little virtual machine doesn't have much going on","width":226},{"text":"right but if I was to run it again, I'd probably get a different process number","width":525},{"text":"one hundred and seventy five, okay","width":100}],
  // Video 27
  [{"text":"so now let's do something exciting","width":461},{"text":"let's call fork()","width":614},{"text":"look, I get two different numbers, 188 and 189","width":258},{"text":"I've actually got two processes running","width":216},{"text":"here's what happened: the moment you called fork(), your little process gets temporarily stopped for a nanosecond","width":624},{"text":"so the CPU's not going to execute anything in your code","width":231},{"text":"and we duplicate it","width":135},{"text":"we now have two nearly identical processes running","width":373},{"text":"and then we'll let them go","width":157},{"text":"so remember when I said, you pull a switch and you get an immediate doppleganger","width":207},{"text":"there's immdiately two processes","width":119},{"text":"now one thing you've noticed already is that they have different process identifiers","width":455},{"text":"another way that they're different is that one of them is the parent of another","width":1154},{"text":"let's get that back to result, and let's say...fork gave me the following","width":1102},{"text":"My pid is that","width":135},{"text":"okay, let's run that","width":585},{"text":"so, look at that! I got two processes running at the same time. one of them says \"hey! fork() gave me nothing. it gave me zero. and fork() gave me 203!\"","width":825},{"text":"so these two processes are now running in slightly different worlds. one of them had a different return value. one of them had a non-zero return value","width":533},{"text":"and in fact, the return value is the child process!","width":296},{"text":"so as a parent, if you wish, you could create a child by forking and then immediately kill it","width":403},{"text":"but I'm not going to show you how to do that today","width":157},{"text":"instead, I'm going to show you what happens when we fork() too much","width":732},{"text":"while 1 is greater than 0","width":505},{"text":"let's print that, let's not return, and let's sleep for one second","width":536},{"text":"just so we can kind of follow what's going on. actually, let's sleep for two seconds","width":351},{"text":"Are you ready? let's see what happens now","width":358},{"text":"okay! I've got two processes. OH! how many have I got now? FOUR processes. now I've got eight processes. now I've got 16. Each process, remember, sleeps for a second and then forks. it makes a copies of itself.","width":875},{"text":"so I've got all these running processes because say, I had 4 of them, and all 4 of them called fork(). oh dear, my system has crashed","width":682},{"text":"alright, eventually, my poor machine of course runs out of memory and it's unable to continue. alright.","width":1117},{"text":"so, actually, at this point, the system does its best to preserve itself","width":345},{"text":"it does its best to say \"ahhh, I don't want all these children!\"","width":203},{"text":"I cannot cope","width":98},{"text":"and so it prints out all the debugging information and then decides at random to start killing user processes. the idea being that that's the least bad thing that we could do in this case because we want to preserve the actual main operating system (the kernel running)","width":1101},{"text":"and maybe we'll have a few processes left that are still useful","width":181},{"text":"so let's see if I've even got a- no, I don't got anything do I?","width":216},{"text":"no, it's dead","width":64},{"text":"but that is an example of a fork() bomb. as you can see, it's pretty mean to everybody else that happens to be logged in to the system at the time","width":789},{"text":"so, when you start using forks for the MP, good luck!","width":378},{"text":"and try not to write fork bombs","width":133},{"text":"and with that, we'll finish there and I'll see you on Wednesday!","width":204}],


  // Start Lecture Video 1
  // Video 28
  [{"text":"your laptop before we release the official instructions ecetera","width":664},{"text":"but that is it. that is coming up","width":175},{"text":"alright, so, next question, who here is ready for section this week?","width":464},{"text":"and actually got a little working editor?","width":217},{"text":"alright, who here is still working on it?","width":214},{"text":"okay, who here is procrastinating and has not started yet?","width":266},{"text":"alright, okay, so note that if you raised your hand on that last question, you are definitely the minority.","width":336},{"text":"remember, the purpose of this work is for you to be on top of using these calls, understanding how memory works, understanding how to put them together so make sure you're ready","width":886},{"text":"and it's gonna be great prep for when we do the harder MPs","width":359},{"text":"right then so today here's what we're going to do. we're gonna talk a little bit more about C programming. I'm going to show you some more gotchas","width":382},{"text":"i'm gonna talk about getline I'm gonna talk about assert(), I'm going to show you some fun little demos and as usual, feel free to interrupt me and ask a question or two","width":654},{"text":"and as usual, most of this material is also in the wikibook. which was created last semester. So most of the lecture content, you'll see inside the wiki book","width":590},{"text":"alright, also, these lectures are now recorded so feel free to review them as well","width":337},{"text":"right so, let's have a look at our little handout. overhead!!...","width":605},{"text":"doo doo doo doo doo","width":489},{"text":"right! so here's something you can put inside your C programs. if you write line underscore and undersore or file underscore and underscore, something magic happens","width":665},{"text":"they get expanded by the C preprocessor into a number, as if you actually typed it, and a string, as if you actually typed in the file name","width":768},{"text":"that's currently being compiled","width":164},{"text":"so the value of line actually changes and the preprocessor knows which actual file line it is currently compiling","width":575},{"text":"so that can be useful for putting in debug information, so we can discover for example which part of our program is executing by printing this stuff out","width":758},{"text":"so, let's have a look, box pc","width":324},{"text":"okie dokie, so for example, I could say \"hey!\" or, let's just print it out. I'll do printf \"bad stuff happened in file %s at line %d\"","width":1293},{"text":"we'll put in, let's see I need the file and the string so that's a underscore. oops. can't get it back inside. thank you. file and line number.","width":771},{"text":"alright, so we will put a new line there...let's say exit our program so nothing else happens. okay, let's run this","width":1121},{"text":"alright, so there we go, bad stuff happened in file program.c at line 14. that's pretty useful if we want to open our editor and go back to that particular point. so that happened at runtime.","width":829},{"text":"and in fact that idea is used by another macro called assert","width":404},{"text":"so you can imagine we want to be able to say things like \"look, if my pointer is non-zero\" so I could say \"not equal to null\" or I could say \"not equal to zero\" or I could just say \"if not p\"  in other words, if its not a valid value","width":1270},{"text":"print an error message and quit","width":241},{"text":"right? that's a pretty useful thing to do during debugging. just do a quick test. before I start using p, I may be crashing in really strange ways so I just want to check if the following expression is true","width":647},{"text":"so that is actually what the assert macro does. so, I can say things like \"look, I want to assert that 2 is greater than 1\"","width":856},{"text":"let's check that. let's assert that 3 is less than 7 times 0","width":573},{"text":"right, let's run this","width":698},{"text":"we didn't get anything, did we?","width":750},{"text":"and, I'm wondering why","width":317},{"text":"let's see, we compiled asserts","width":415},{"text":"include assert.h and we don't seem to be. AH. we want to compile it in debug mode","width":537},{"text":"okay there we go, right","width":79},{"text":"so this time we, haha, yes! this time we remembered to include the assert.h and assert is actually a macro. it expands to include that underscore underscore line thing","width":837},{"text":"and underscore underscore file","width":86},{"text":"so now, here we go, when we run this, it prints out program.c at line 15 inside my function main assertion 3<7*0","width":578},{"text":"it's pretty useful. it actually shows you the expression","width":163},{"text":"it's a nice simple development thing to use asserts","width":329},{"text":"because then you can check that people that are calling your functions are actually giving you say valid arguments","width":317},{"text":"and you can check that your assumptions are correct before you try to write complicated code","width":344},{"text":"and, it kills your program. it aborts","width":203},{"text":"so that's assert","width":302},{"text":"now then, pretty easy to use, remember to include it, include...assert.h and then, and then inside your program you just say assert and write an expression you expect to be true","width":1181},{"text":"like \"Hey! its wednesday!\"","width":184},{"text":"if that expression is true, nothing happens","width":206},{"text":"and in fact, when you make a release build, this expression isn't even tested","width":464},{"text":"this compiles to no code","width":176},{"text":"so it's good for performance","width":230},{"text":"but then you realize that you've been living on the edge. it doesn't actually check it.","width":384},{"text":"and it's a macro, because we want to be able to print out the actual contents of the expression we're going to test.","width":405},{"text":"and also we want to print out the line number. and also it's a macro because we can make the contents of the macro disappear when we do a release build","width":718},{"text":"so, with that, let's see if you can write a version of string cat. and what you want to do for strcat is append the contents of another string onto the end of the first string.","width":1066},{"text":"but, we're not sure that people are giving us valid arguments","width":281},{"text":"so how would you write this so that it aborts if either one of these were NULL ?","width":385},{"text":"what would you write?","width":65},{"text":"so see if you and your neighbor can finish this","width":303}],
  // Video 29
  [{"text":"this function it should at the end simply return a pointer to the beginning of the target","width":495},{"text":"and i'll give you a hint, how do you actually determine where a string finishes?","width":464},{"text":"You walk along the string until you find a null character","width":286},{"text":"so the plan should be walk along with a little loop until you find a null character and then start copying the bytes from the source at that point to keep copying them across","width":561},{"text":"until you get across a null character in the source and then you know you're done copying","width":284},{"text":"and then before you finish make sure the very last thing you put at the end is a null character to terminate your string","width":515},{"text":"see if you can finish that code in about five minutes and I'll walk around answer any questions you have","width":519},{"text":"questions? ice cream? popcorn? yes?","width":16070},{"text":"if you wanted to check that these are valid pointers, we want to check that they're non null","width":344},{"text":"so actually we could just say assert dest","width":548},{"text":"you could even say dest and source, however, that wouldn't give you very much debugging informationÃÂ all you'd discover is that one of them is broken","width":698},{"text":"so personally I wouldn't do that, I would write it as two different things on two different lines","width":300},{"text":"so that when it does it break I can discover at least whether the problem was with the source or the destination address","width":615},{"text":"OK, right, so if I get past that I know that both of those pointers are non null. my next challenge then is to walk to the end of the dest","width":868},{"text":"I could do that using a little loop. I could say things like while star dest ","width":731},{"text":"keep incrementing dest","width":247},{"text":"so that would work, in other words whilst - when I read the contents that dest is pointing to - whilst that's non null keep walking","width":600},{"text":"and it will keep doing that until I end up on a null byte. I also heard people doing things like, let's just add into dest strlen dest","width":1034},{"text":"in other words find out how many characters excluding the null byte, are pointed to at that destination and add that to dest","width":424},{"text":"so both of those would work","width":126},{"text":"now we want to copy. OK, how could we do this? well maybe I call string copy, but if I wanted to write this in a loop, let me write this little do while loop","width":1025},{"text":"going to dest and do I want to go into there, the contents at source","width":484},{"text":"I can't spell source, nevermind. whoops, and then increment both of those. dest plus plus, source plus plus. there we go","width":943}],
  // Video 30
  [{"text":"alright and keep doing this while either one of these is valid","width":624},{"text":"okay what do you think about that code?","width":370},{"text":"hold on hold on you can't see it","width":200},{"text":"is this code correct?","width":128},{"text":"does it copy the null byte at the end?","width":1104},{"text":"okay alright if your neighbor thinks it copies the null byte get a new neighbor","width":524},{"text":"right why does it not copy the null byte?","width":543},{"text":"because we've incremented the source pointer","width":215},{"text":"right so we copy a byte, we keep copying characters and then we increment the source pointer and then we say while source","width":446},{"text":"so we are checking the next byte, the byte that we haven't yet copied","width":496},{"text":"so no, that code doesn't actually coy the very last byte","width":263},{"text":"you see, C program is easy","width":226},{"text":"or actually C programming with bugs is easy, writing correct programs is harder","width":369},{"text":"and we wouldn't have spotted this if our destination memory had all been zeroed by some fortuitous accident","width":448},{"text":"so that is incomplete, we still need to copy the byte at the end","width":373},{"text":"so at the very end I need to put a null byte in","width":374},{"text":"so I could write that as zero, I could write that as backslash zero","width":421},{"text":"that means the null byte","width":115},{"text":"and then finally return dest","width":471},{"text":"okay what do you think about that code","width":273},{"text":"yes, so if source is just an empty string what would happen?","width":866},{"text":"correct, we put two null bytes at the end","width":268},{"text":"so that's dangerous right? our code would actually copy more bytes than say the standard specification","width":540},{"text":"so now we've got a bug that only happens when we copy empty strings","width":537},{"text":"what else? there's another bug as well. yes? I'm writing memory that isn't part of dest or source","width":833},{"text":"okay, so I haven't malloc'd a new buffer yeah. okay so let me first mention the error I was going to point out","width":368},{"text":"which is actually the specification of strcat says we should return the beginning of the string","width":267},{"text":"we are actually returning the end of the string","width":150},{"text":"whoops, so we probably should have kept a copy of what the original value of dest was","width":363},{"text":"as it happens, most people don't tend to use this return value","width":225},{"text":"and so your code might work in most places until the day it doesn't","width":379},{"text":"now let's get back to that question of oh we haven't malloc'd any memory","width":225},{"text":"so strcat actually assumes that the destination is big enough for all these bytes that we are going to copy","width":536},{"text":"it doesn't do any mallocing itself, it just says okay give me a pointer, I'm going to assume that there is enough bytes available for me to copy whatever is available at source","width":610},{"text":"and if that is not true, well let's hope this code isn't actually driving a car or an expensive robot or flying a plane","width":568},{"text":"or something inside your bloodstream","width":332},{"text":"so strcat is dangerous, you have to promise that you've got enough bytes allocated at the target","width":597},{"text":"and for that reason many people avoid it and use strncat instead","width":393},{"text":"which I'm not going to talk about today","width":99},{"text":"and that saves you from some of these gotchas","width":248},{"text":"so it's better but it's still not perfect","width":186},{"text":"you can still have problems with strncat but I don't have time to talk about it right now","width":491},{"text":"okay right so for your next serving of C, I've got some code down here that uses strcpy and strcat and arrays and pointers to stuff","width":687},{"text":"what errors do you spot? if this was say a code review or in an interview and they said \"hey look at this code, what can you tell me about this?\"","width":602},{"text":"what can you and your neighbor find? what errors?","width":338},{"text":"what kinds of errors and how would you explain them?","width":284},{"text":"[long pause]","width":9735}],
  // Video 31 part 3
  [{"text":"okay, alright! so, what do we got here","width":354},{"text":"I got three variables: var1, var2, and arrrrrayyy!!!","width":287},{"text":"alright, just to point out that this is an array. and they all initialized to \"hello world! bounjour!\"","width":557},{"text":"now, there's a big difference between these and to point it out first of all let's talk about this very last line","width":404},{"text":"no, it is not possible to do this","width":548},{"text":"what this line is trying to do is say \"hey! I've got a pointer called array. make it point to the same thing that var2 is looking at\"","width":390},{"text":"no, you cannot do that. if you use just the array name here, it's treated as a pointer but there's a couple of big differences","width":780},{"text":"first of all, you can't change it","width":128},{"text":"this variable is the beginning of the array","width":384},{"text":"you can't make it point to a different piece of memory","width":278},{"text":"secondly, if you ask the size of array, you'd actually get back the number of bytes of the actual array","width":446},{"text":"unlike a pointer where it would tell you the number of bytes required to hold a pointer","width":253},{"text":"so no, you can't change array and make it point to something else","width":225},{"text":"you can, however, make a pointer to a character point to a character array. that's okay!","width":427},{"text":"now you've got var1 holding the same address that array hold","width":572},{"text":"alright, now, what about these other things up here?","width":192},{"text":"okay, strcpy! I want to copy into the array var1","width":251},{"text":"is that okay?","width":189},{"text":"if you said it's okay, you're correct!","width":276},{"text":"okay, why is that?","width":189},{"text":"well, here's what happens. we're actually saying \"I need an array and I need it to be big enough to hold the following data\" (bonjour)","width":582},{"text":"and when we run our program, when we start the process, we have a little array, here it is, and bonjour is copied into this array","width":1099},{"text":"so, our array lives in memory that you can read and write","width":233},{"text":"so if you want to copy other stuff into the array, yes, go for it. it will work. just remember that the array isn't an infinite length. it's fixed size. so you better make sure you accidentally copy too many bytes into this data structure","width":845},{"text":"so we're fine, we do strcpy into var1","width":191},{"text":"so that's okay, what about strcat var2 into array one?","width":209},{"text":"that looks fine too, ary is mutable, we can change it","width":456},{"text":"okay, here's the exciting part. yes, we're calling strcat so we are appending characters onto our array","width":480},{"text":"but you and I know that this array is not going to be big enough to hold whatever it is","width":442},{"text":"\"hello world\"","width":119},{"text":"we're gonna write the data w-o-r-l-d and a NULL byte past the end of the array","width":479},{"text":"who knows what's going to happen? woohoo. we don't know!","width":233},{"text":"it depends on how things are laid out in memory but I'll show a little demo in a moment just to show what happens","width":355},{"text":"whoops, what we have here is a buffer overflow. we had a buffer which is just our little array and we went past the end of it","width":579},{"text":"we wrote into memory that we should not have been writing into. we didn't own that memory. oops.","width":411},{"text":"and, I want to point out that this can happen not because you were just thinking about. you didn't think about memory slides. it can happen through typos.","width":623},{"text":"when you intended to say strcpy and instead your fingers wrote strcat","width":592},{"text":"bad things could happen. alright. especially if your pointer happens to point to arbitrary data at this point","width":365},{"text":"strcat is going to say \"okay! I'll copy this data for you. I just need to walk along this data and find a NULL byte\" and off he goes! bye!","width":581},{"text":"so be careful when you write strcat strcpy, just take a moment to check you actually wrote the intended one. of course, I've never had that mistake hahaha.","width":653},{"text":"and, what about strcat var1 var2? can I copy from what var2 points to into what var1 points to","width":849},{"text":"if you said yes, at least say it confidently because you're incorrect","width":381},{"text":"no you can't. var1 and var2 hold the memory address of this constant","width":560},{"text":"so yeah, you can change var1 you can make var1 point to something else. here we go. var1 equals hey, point to this other thing.","width":466},{"text":"hey, hold the value NULL","width":128},{"text":"ecetera. I can certainly make the contents of var1 be different","width":412},{"text":"but in this particular case, what it's pointing to is memory that is read only","width":502},{"text":"so if you try to start writing bytes into that address var1 points to, ah ah ah! no, you won't. the hardware will detect that and say \"you can't do that\" I'm only giving you read access to those bytes","width":950},{"text":"alright, any questions? yes! yeah. yes. the compiler will spot that","width":754},{"text":"so array names are special","width":387},{"text":"uh, it can be treated as a pointer. if you need a pointer, the compiler will turn that name into a pointer.","width":497},{"text":"and the pointer is at the beginning of the array","width":250},{"text":"alright, so, if you do things like ary+3, that will add 3 times however big each element is","width":576},{"text":"so if you point to an integer array, it will be array + 12 bytes","width":265},{"text":"if you're on a 32-bit machine with 4-byte integers","width":247},{"text":"alright so, remember, the compiler is just turning this into assembly code so it uses the type information","width":447},{"text":"and if its trying to get a pointer, it turns into a pointer","width":330},{"text":"okay, other questions. yes! uh, so var1 the variable itself is mutable. we can make var1 point to anything else. but yes, you are correct. I could now write strcpy var1 after this","width":1870},{"text":"okay, so, this is okay now. because var1 is pointing to the array. so of course I can copy okay into the array","width":754},{"text":"alright, we should talk about uh, I forgot to free memory. we do not need to free these memories. these are not on the heap","width":574},{"text":"you've actually got more than just the stack memory and heap memory","width":300},{"text":"you've got static memory where you'll discover these constants go","width":487},{"text":"where also our global variables go as well","width":178},{"text":"so you see heap memory when you call malloc. alright, that's how you get heap memory","width":564},{"text":"we haven't done a whole lot of malloc-ing yet","width":111},{"text":"and you see stack memory when you make a variable inside a function","width":556},{"text":"alright so here we go","width":154}],
  // Video 31 part 4
  [{"text":"that is going to be inside my heap","width":517},{"text":"well we're not doing that right now. we're playing things which are either constants or declared outside of functions","width":570},{"text":"let's do a quick demo. right, good","width":514},{"text":"here is the code we've got. I don't want this right now","width":683},{"text":"but I've done one extra thing, is I've made another array called demo. It's got the characters 1 2 3 4 5 6","width":594},{"text":"and I'm going to print it out twice. so we should see 1 2 3 4 5 6 twice, right","width":652},{"text":"but of course, because you know it's a demo, we're not going to see that. let's see what we get. oops, we have to turn off the asserts","width":856},{"text":"OK, we're not going to see that. this is what we saw instead. 123456. OK, so we've printed out the characters","width":783},{"text":"and then d and a smiley face. where did that come from?","width":867},{"text":"for some reason demo got obliterated by a d and smiley face and of course the null byte","width":633},{"text":"why? because first of all we copied var1 in and then we did a string cat and copied var2 into our array.","width":857},{"text":"but our array was not big enough to hold 'Hello..!' and 'World:-)'","width":485},{"text":"strcat doesn't know that, it merely copies the bytes until the end. and so it kept on going and it ran into the memory that is being used by demo","width":670},{"text":"and we could kind of prove that they are next to each other. let's have a look at where they are. so we can say, hey the array is at this address and demo is at this address","width":1380},{"text":"there we go. so array is at some low address and demo is at another low address, but just next door","width":670},{"text":"doing the mental arithmetic to subtract those two numbers is left as an exercise to the reader. but it's pretty close, yeah? it's about ten bytes","width":837},{"text":"right, that's our little demo. let's go back to our sheet. so let's talk about converting things","width":477},{"text":"if I've got a string and I want to convert it into a simple integer, how can I do that? well here's the easy way. use atoi","width":776},{"text":"so for example atoi of a hundred gives you the integer hundred","width":1033},{"text":"what do you think atoi of bananas is? ","width":1381},{"text":"place your guess now","width":701},{"text":"it's zero! so here's the downside of using atoi, yes it's really really quick. it's trivial to write code, but you'd better trust that what you're going to get is a valid integer that can be converted into a standard c integer because if it can't it doesn't crash, it doesn't complain, you have no way of knowing other than the fact that you got the value zero","width":1468},{"text":"so this returns a value of zero. so you don't know whether the user typed zero, entered zero, or whether it was invalid input","width":460},{"text":"so use it for little demos, quick hacks, etc., but if you actually want to check whether things are valid or not then it's time to use scanf","width":887},{"text":"because scanf will tell us how many things it successfully parsed. lets make a little scanf demo","width":1154},{"text":"OK, three integers walk into a program. there you go x y z. and I've got a string that I want to extract some values for","width":903},{"text":"maybe this is some 3D vertex data for example and I could use this function called scanf to say 'alright here's my input and I want you to treat it as an integer followed by some white space, another integer followed by some whitespace and another integer'","width":1164},{"text":"OK, how do I push that out? I need to give it the address of my variables. so remember ampersand means tell me the address of this thing","width":993},{"text":"OK and now if our program works","width":984},{"text":"tick tick tick tick, yeah! z is twelve! hooray! great, I've written a parser that can now read 3D data. watch out minecraft","width":843},{"text":"OK, what about 10 11 x?","width":571},{"text":"what do you think the value of z is now?","width":407},{"text":"well it's claiming that z is zero,but we should try something here. suppose we initialize z to be something else like 42","width":701},{"text":"z is still forty-two. so what our scanf did is it started eating, started walking along that string, it got to a point where it said this not what I expected and it choked. it just gave up and stopped","width":996},{"text":"so what we should do to write robust code is see how many things scanf actually managed to bite out of the input","width":644},{"text":"so let's have a variable here called numread and we can now check to see how many things were actually read by scanf and then we can write code that says, hold on a moment, I died trying to parse this line","width":1167},{"text":"now you can see numread equals two","width":117}],
  // Video 31 part 5
  [{"text":"extract out the x and the y and we failed when we tried to parse the third integer","width":474},{"text":"right, so scanf looks pretty easy and it is","width":268},{"text":"it is very easy to write bugs using scanf","width":281},{"text":"I've already mentioned one, okay so scanf - you saw that there are already different versions of it","width":545},{"text":"I was using sscanf because that allows me to start from the string which is good for demos","width":486},{"text":"there is also fscanf which guess what, starts from a file pointer","width":360},{"text":"so for example, I could read from stdin","width":235},{"text":"or I could read from a file that I've already got open","width":263},{"text":"and then we need the format string, okay so here's the first problem that you can run into","width":415},{"text":"this looks a lot like printf, printf's format string yes? I just showed you one with %d's","width":581},{"text":"and it is until it isn't","width":209},{"text":"it's actually subtly different, so the day that you actually need to write a scanf, open up the manpage and check the format specifiers because it's not quite the same","width":635},{"text":"for example floating points are slightly different","width":177},{"text":"so that's the kind of first gotcha. that second gotcha I've just shown you, which is that the number of items that you've read isn't necessarily all of them, so you should check that","width":819},{"text":"and then the third gotcha is guess what, we can put in addresses here and sometimes you want to put in an ampersand and sometimes you don't","width":722},{"text":"so I showed you one way we did ampersand y ampersand z because I actually wanted to know the address of my integer variables","width":904},{"text":"can you think of a time when you might not actually want to put in the ampersand?","width":492},{"text":"yeah, if you already have a pointer to the thing that you want to change","width":359},{"text":"so if you've got a pointer to an integer variable, there we go, let's put in pointer here and provided that pointer is pointing to something a variable I want to change, everything is fine","width":1612},{"text":"everything is not fine if I was to write in ampersand pointer","width":522},{"text":"because now what am I changing?","width":333},{"text":"I'm changing this, I'm not changing the thing its pointing to","width":383},{"text":"and if you think this is complicated or confusing, it is!","width":245},{"text":"so my advice is don't write scanf code until you've had three cups of coffee, you're completely awake and it's the most important thing in the world to get it right","width":470},{"text":"and even then, assume that you've got it wrong","width":211},{"text":"scanf code is incredibly hard to write correctly and you can get nasty little errors just by missing an ampersand or putting an ampersand when you don't need one","width":525},{"text":"scanf is not going to detect that, you have to be extremely clear about whether you mean to talk about the thing, the address of the thing or using the thing that the thing is pointing to","width":732},{"text":"so it's not for the feint hearted","width":118},{"text":"and with that warning, let's carry on","width":323},{"text":"I can promise you I've spent hours debugging scanf code","width":249},{"text":"that I thought was correct","width":209},{"text":"here's some other things that will kill us or get you","width":201},{"text":"gets is easy to use, you just say gets and you give it a pointer to your buffer","width":718},{"text":"to some characters","width":460},{"text":"description, never use this function","width":238},{"text":"the reason I bring it up is because people like to ask about it occasionally in exams and occasionally in interviews","width":356},{"text":"it's a classic example of how to hack a program, hack a C program because gets like strcpy has no idea how big this buffer is","width":781},{"text":"how many bytes it can safetly write into whatever address you give it","width":377},{"text":"so if the data that it's reading from stdin happens to be bigger than your buffer, arbitrary things can happen","width":431},{"text":"now someone could use this to supply data that is longer than your buffer and start overwriting arbitrary memory locations","width":433},{"text":"and those arbitrary memory locations probably correspond to other variables","width":283},{"text":"so now someone can use your program to do bad things, to do things that the program is not designed to do","width":490},{"text":"so how do we fix this? answer: use fgets instead","width":414},{"text":"right and I'm not going to talk about that because there's some more fun stuff we can do down here","width":425},{"text":"let's do environment stuff, I don't think I've shown you environment stuff yet have I?","width":441},{"text":"okay right so every program when it runs has arguments and an environment ","width":425},{"text":"so if we do env for example, you can see that my program has actually when it runs, has all of this information","width":601},{"text":"all kinds of useful stuff like the current user is root, where the home directory is for example, the current directory is probably in there as well","width":705},{"text":"so I can get access to this stuff when I write my C programs","width":405},{"text":"so let's write a little C program that does this","width":245},{"text":"for example, I'll say I've got extern, environ, now this extern means that look, this thing exists","width":806},{"text":"don't allocate any space for it, but when we finally link all the pieces of my program together","width":443},{"text":"the compiler is going to look for this variable because we've simply declared that it exists somewhere and I want to use it inside my C program right now","width":553},{"text":"so let me put the contents of the first entry of environ and then we'll exit","width":1106},{"text":"okay so you see we've just got a string","width":177},{"text":"a simple C string which is in the form of key and equals and a value","width":521},{"text":"and I could write a little loop to go through all of them and when I find once which is null at the end I know I've finished","width":666},{"text":"so if I want to enumerate all of my environment variables, I can use environ","width":385},{"text":"if I actually want to look one up that I know exists, I can use getenv, so let's getenv and say look for user okay so that will give me","width":734}],
  // Video 31 part 6
  [{"text":"uhh, an answer and I'll print that out.","width":983},{"text":"okay, so we can see that my program when it says getenv on the current user, it prints out root","width":439},{"text":"woohoo!","width":201},{"text":"so, environment variables are one way of passing useful things to your program. as we've seen, so say you can look at the current user's home directory and store your preferences there. or if you're mean, you can delete all their files","width":1117},{"text":"so that's one way to get a general general environment. the other way you've seen of course, is that our main method has two parameters. argc and argv","width":780},{"text":"which is a character pointer pointer","width":320},{"text":"so, let's all look at this. first of all, some important points about them (come back!)","width":285},{"text":"the first is that the very first entry of argv is not one of the program arguments. it's actually the program name","width":1112},{"text":"so I for example, could write a usage thing. blah blah blah blah","width":698},{"text":"and, if there are any other arguments, we can find out how many there are","width":522},{"text":"arguments %d our count","width":930},{"text":"alright so, it's program name, the way its actually executing we can actually discover from the program itself. it's the very first zeroth argument. and we've got one argument so this is like another kind of classic off by one thing again","width":913},{"text":"so if I have, you know, cats, it thinks its got two arguments","width":380},{"text":"what it means by that is that that array has got two entries","width":293},{"text":"and the first one being the program name","width":192},{"text":"the second entry being cats","width":126},{"text":"and in fact, that's not even quite correct either because it happens to be always one final entry at the end which is NULL","width":596},{"text":"so we could go through and look at all of the arguments","width":343},{"text":"so let's do that. we'll have a little pointer. let's make it point to argv + 1, in other words, we're not going to print out the program name this time (come back!)","width":882},{"text":"yeah let's get rid of that stuff","width":442},{"text":"okay, right, we'll stuff [something] we'll print everything we find at the pointer","width":587},{"text":"so I need a pointer to an array and a pointer","width":967},{"text":"while the entry is non-zero, let's print it out.","width":261},{"text":"and we'll add one!","width":959},{"text":"okay, so let's now try our little program. oh I forgot to follow the pointer. okay cats are cool","width":1330},{"text":"alright, so, we can access each of the arguments that the program has","width":482}],

  // Start Lecture Video 2
  // Part 0
  [{"text":"okay, hi. I'm gonna ask you to volunteer (student: oh okay) alright.","width":1559},{"text":"I'm going to ask you to volunteer for something in a moment","width":190},{"text":"Okay! Good morning class! how are you?","width":872},{"text":"great! so, here we go, uh today we're going to talk mostly about fork() and exec()","width":337},{"text":"maybe we'll have time to talk about signals as well","width":242},{"text":"yes there will be an in-class exam/quiz coming up next week","width":329},{"text":"we'll see when it happens","width":149},{"text":"I guarantee it won't be Monday","width":383},{"text":"Or tuesday or thursday","width":85},{"text":"alright, more details next week.","width":184},{"text":"so first of all let's just start off with a little demonstration of how fork() works","width":327},{"text":"for that, I need a volunteer, yes! thank you! please come on down","width":217},{"text":"alright, so, um, here's my process and of course [something] today you're gonna be my process, right?","width":527},{"text":"so, a process to run of course needs some instructions to execute","width":345},{"text":"here we go, stand here, you're my process, right.","width":137},{"text":"okay thank you. and, here's the code that I've already compiled right into something the CPU can execute","width":589},{"text":"okay, we've got inside the process memory you've got a pointer called neurons and an int called capacity right and we run this function called init brain","width":604},{"text":"it's kind of complicated","width":142},{"text":"it does a lot of stuff","width":39},{"text":"when we pass in the address of neurons and the address of capacity, so there's init brain when it returns will set where the neurons being held and the number of neurons that we have","width":798},{"text":"so, it looks a little like readline, yes?","width":211},{"text":"and, manage to actually return a void pointer so we can actually use that perhaps","width":252},{"text":"okay so we're running this code, okay, and the next thing to do is think of a number, right?","width":384},{"text":"so, think of a number between 1 and 10","width":185},{"text":"don't tell me! don't tell me...","width":213},{"text":"and then you're gonna print the number to standard out","width":181},{"text":"alright, so, this is my standard out here","width":270},{"text":"you can write a number...okay","width":229},{"text":"accept!","width":59},{"text":"oh you need a pen","width":64},{"text":"accept","width":81},{"text":"here's what we're gonna do, right. you thought of a number, yes? it's in your head. inside the process","width":308},{"text":"before you print it out, I'm going to change the program now","width":325},{"text":"in just here, I'm gonna call fork()","width":399},{"text":"okay? between thinking a number and printing it out","width":137},{"text":"I'm calling fork()","width":103},{"text":"so, what does fork() do? it doesn't not restart the process.","width":294},{"text":"no. here's what fork does: it says take a process that you've got and clone it","width":435},{"text":"yes? make an almost-exact copy of you!","width":272},{"text":"now I've scanned the audience and I've found the person who looks exactly like you","width":288},{"text":"I need my second volunteer. thank you, come on down","width":165},{"text":"[laughter]","width":390},{"text":"alright, so, at this point if you'd like to write down your number.","width":612},{"text":"so we've got two processes. don't show me your number","width":246},{"text":"and of course, thank you. so, we've got two processes and because we've cloned it, inside their memory, it should be exactly the same","width":773},{"text":"so if we now were to say to both of them, okay, continue executing, remember these are two completely different processes","width":330},{"text":"their own memory happen to be following the same assembly instructions here.","width":282},{"text":"the same code","width":115},{"text":"so if we asked them to print out their number, let's find out what they would say!","width":192},{"text":"here, hold them up and show the audience please","width":325},{"text":"look at that!","width":126},{"text":"alright, they're both printing out seven","width":240},{"text":"which is also what you wrote","width":183},{"text":"okay, that's a miracle. [laughter] alright so, well, a 1 in 10 miracle, not a big miracle, but we'll just leave it","width":432},{"text":"so this is how fork() works","width":192},{"text":"remember that this is what happens. it doesn't restart the process. it splits it","width":146},{"text":"so give our volunteers a round of applause, thank you very much [clapping]","width":197},{"text":"because we're going to use that now in C and remember anything you write in C could, in principle, be done in any other program as well. in any other script language like python","width":571},{"text":"python, for example, has a fork()","width":136},{"text":"but underneath, python's written in C, and underneath that, it just calls the fork() command","width":374},{"text":"okay so, I've got a little example of that in terms of code. here it is","width":852},{"text":"here we go, can we read that? okay, so here's my little example","width":220},{"text":"this srand() here thing, this says \"okay, system, tell me what time it is?\" and I'll use that to initialize my random number generator","width":566},{"text":"so remember to actually generate random numbers, we cheat. we just do some mathematical bit shifting tricks so it appears to us to be a random number","width":634},{"text":"and it appears to satisfy some basic statistical tests","width":258},{"text":"but there's not really a random source here","width":172},{"text":"it's just a mathematical stream of numbers that appears to run all over the place","width":370},{"text":"so later when we call rand() we get back a random number","width":221},{"text":"but look at this for a moment! I've called fork() this time beforehand","width":297},{"text":"so the question is, what do you think will happen here?","width":240},{"text":"will my two processes. so, I have a new job process created. will they both print out the same thing? let's run this and find out.","width":1026},{"text":"okay so what do we get? well each process is told to print out its id number","width":262},{"text":"so we get two different id numbers of course","width":128},{"text":"and look, my random number is 6!","width":258},{"text":"they both printed out the same thing! was it an accident? no. they actually both print out the same number","width":466},{"text":"so, why do you think that is?","width":359},{"text":"yes! at the back. thank you, yes, they both have the same random seed and the random state is part of the process","width":727},{"text":"so we've just cloned the whole thing","width":290},{"text":"so actually, you can use one process to guess what random number generators the child process is going to create as well","width":695},{"text":"because they are indentical","width":101},{"text":"it's like your cloned brother or sister or whatever your genetic clone knows exactly what you're thinking","width":652},{"text":"so this actually is potentially a vulnerability if you know, if you completely understand the state of a process, you can predict what it actually might do","width":695},{"text":"alright, so that's a silly example but I'm trying to show the idea that you start a process, you call fork() and suddenly, you have two processes continuing on past that fork() call","width":696}],
  // Part 1
  [{"text":"if I've got two processes how could I make the two process start to do different things?","width":513.1818182468414},{"text":"right now they've done the same thing, I want them to do different things","width":216.18181824684143},{"text":"here's how, we'll check the return value of fork because that is one asymmetry that we have to play with","width":530.1818182468414},{"text":"if child is greater than zero, so if the result is greater than zero for my fork","width":636.1818182468414},{"text":"guess what? it means I have a child!","width":460.18181824684143},{"text":"therefore I must be the parent","width":666.1818182468414},{"text":"so now our parent could just exit","width":792.1818182468414},{"text":"what's going to happen now? this time only one process gets to print out their random number, the child process","width":993.1818182468414},{"text":"we could make this more complicated and we could have our child calling another fork, for example. have many many many more children if we wished","width":720.1818182468414},{"text":"the main point to get here is the idea that you are duplicating the world at this point. you are duplicating the process by calling fork and you have two to play with","width":740.1818182468414},{"text":"let's put that aside for a moment and talk about that very first program. the very first program we've got here does quite a bit","width":570.1818182468414},{"text":"this is an example of quite a bit of system call programming. now we're actually calling system when we're making lots of different calls","width":749.1818182468414},{"text":"my question to you is can you explain every single line of this program?","width":534.1818182468414},{"text":"if you can, if you've been reading ahead in some of the manuals now's your chance to explain it to your neighbor. if you're not sure about something ask your neighbor. see if they know more system programming than you","width":819.1818182468414},{"text":"what is this program doing? ","width":221.18181824684143},{"text":"what does every line do?","width":275.18181824684143},{"text":"you want a handout? sure.","width":650.1818182468414},{"text":"this is the (cut's off)","width":329.18181824684143},{"text":"(speaking to a student) oh ok, what was the question?","width":816.1818182468414},{"text":"(still speaking directly to a student) we killed the parent process, but now the child process carries on","width":621.1818182468414},{"text":"yes, that is how we write the code. we say if I'm the parent just exit so the child carries on. yeah, sure","width":1991.1818182468414},{"text":"anybody else missing a handout?","width":5285.181818246841},{"text":"OK, let's start with a quick demo. This very first line is close one, alright, so if I print something here, woohoo 'hi!'","width":784.1818182468414},{"text":"and 'oh no'. ok, right, let's run this","width":695.1818182468414},{"text":"we're calling puts, I could've called printf as well. I get 'hi!' but that's all I get, I don't get the 'oh no!' because standard out is gone, we've closed itl ","width":778.1818182468414},{"text":"so yes, puts might eventually call write but it's just ignored, that output doesn't go anywhere. I could've for example put printf here, I could've put write into one the following the bytes","width":1010.1818182468414},{"text":"it doesn't matter, all of this stuff just goes no where, we've closed that file descriptor so one doesn't have any meaning anymore","width":488.18181824684143},{"text":"the system just ignores any attempts to send bytes to that particular file descriptor","width":433.18181824684143},{"text":"we've closed it, but then where'd my line go... we call open","width":863.1818182468414},{"text":"open says hey I'd like a file descriptor please","width":214.18181824684143},{"text":"let's see what this returns","width":331.18181824684143},{"text":"where's that return gone to, come back here","width":171.18181824684143},{"text":"and I'll print it out","width":153.18181824684143},{"text":"but I'll print it out to standard error","width":264.18181824684143},{"text":"and fd equals","width":873.1818182468414},{"text":"what error did we get?","width":455.18181824684143},{"text":"I better have some includes here. so if we check the man page for open and I need section two, we are going to need the following three includes. let's grab them","width":1224.1818182468414},{"text":"so we printed 'Hi!' and we get back from open an integer one","width":336.18181824684143},{"text":"it's opened a file descriptor for us, a stream, somewhere we can send bytes. except this time rather than making it appear in our console we're going to make it appear in a file and","width":986.1818182468414},{"text":"we gave these options to open to say 'OK, I'd like to open please this file called log.txt, I need to open it for read and write, I want to create it if it doesn't exist, I want to append to it and then finally I'm going to give some options which I also bitwise or about who can read it and who can write it","width":1188.1818182468414},{"text":"these options are saying that only I can read and write it","width":204.18181824684143},{"text":"so let's start printing some things out, like 'Hello', right and we'll run this","width":960.1818182468414}],
  // Part 2
  [{"text":"okay so we did not see hello in our output","width":327},{"text":"but if we have a look down here we'll see we've got a program called log.txt","width":237},{"text":"let's have a look at log.txt","width":215},{"text":"and it says oh okay it seems to be working, let's see if it appends to it","width":471},{"text":"and then it says hello hello alright so we're appending stuff to our log file","width":250},{"text":"we've changed the output of our process to go to this file","width":411},{"text":"now why is it that that happened?","width":118},{"text":"well if we were to read the man page carefully enough about open","width":218},{"text":"it says it returns the lowest non-negative integer","width":349},{"text":"for a file descriptor and we just closed one","width":234},{"text":"so when we do this, it's going to open file descriptor one","width":333},{"text":"which is what everything then uses when you call puts, printf, etc","width":282},{"text":"so we've now just changed our standard output to go to a file","width":512},{"text":"right then we call chdir, what does chdir do, it has nothing to do with cheese","width":686},{"text":"change directory! yes, our core process not only has memory for say the variables that we create","width":500},{"text":"we've got other things inside our process","width":90},{"text":"we've just seen one thing, which is it's got these file descriptors","width":190},{"text":"each process has file descriptors","width":171},{"text":"also each process has a current directory","width":183},{"text":"so when we say hey I want to open a file called log.txt and we haven't specified it's full path","width":334},{"text":"it's relative to its current directory","width":389},{"text":"so for example, if I had put up here \"hey chdir and let's change our directory to just kind of slash\"","width":795},{"text":"okay, let's run this","width":372},{"text":"then slash is the root directory and if we look at the root of our disk drive, now we've managed to make a file called log.txt","width":633},{"text":"here we go and it's contents is just hello hello","width":330},{"text":"right so okay what have we done? we've done chdir. so we've said chrdir to usr/include","width":832},{"text":"let's just have a quick look inside there because what is inside ls /usr/include/","width":412},{"text":"a whole lot of dot h files","width":83},{"text":"remember in your c files and your c++ files when you say #include std.io hash include this hash include that","width":405},{"text":"they are just files, here they are!","width":354},{"text":"so next time your friend walks away, why not edit one of them?","width":684},{"text":"uh do I have vim on this machine? maybe I have stdlib.h","width":307},{"text":"oh I need to be inside that directory","width":96},{"text":"okay cd /usr/include/","width":162},{"text":"let's so stdlib.h and it's a bit of a mess but nevermind","width":412},{"text":"we can say things like whoops not working, not implemented anyways...","width":688},{"text":"we can do #define if while","width":589},{"text":"so if you hash define if while, that means anytime you see an if, it's going to replace that with the letters w h i l e","width":770},{"text":"very useful if your class is curved, right","width":283},{"text":"alright so we've talked about chdir and we've talked about /usr/include","width":309},{"text":"now we can have some fun, so we have this, let's just go back to my original directory","width":536},{"text":"uh hello, alright I'll reboot the machine","width":426},{"text":"right so we have this exec exec thing okay here we go","width":625},{"text":"what does exec do?","width":1052},{"text":"alright suppose you were thinking about something, you're running a program inside your head","width":243},{"text":"exec says hey forget that program, do this other thing instead","width":372},{"text":"it's a complete mind wipe of your process","width":283},{"text":"whatever it was doing, whatever variables you created, whatever memory allocated, it's gone!","width":372},{"text":"you're saying this process will now actually be executing this other image","width":265},{"text":"right, load this other executable from disk and run that instead","width":331},{"text":"so we will run this right","width":773},{"text":"alright so when I run my program now, it actually runs ls","width":1060},{"text":"it actually gives me the contents of the current directory which is just a dot","width":404},{"text":"now here's something weird, I can understand that the last argument here might be null to mean \"hey i've got no more things I want to talk about here\"","width":480},{"text":"but why is it that I've got /bin/ls twice?","width":728},{"text":"okay, here's why: the first one is the command that you actually want to execute","width":448},{"text":"so inside /bin there is a whole load of commands","width":263},{"text":"here I think we've looked at them before","width":579},{"text":"but remember, when you run a command, you want to give it arguments","width":182},{"text":"so when I call say ls, so here it is exactly, I need to say okay what do I want to do?","width":440},{"text":"well I want to look inside /usr/include","width":176},{"text":"but that's not what the program sees","width":114},{"text":"the program sees the arguments you provide also its own name","width":353},{"text":"the name that it's running as","width":152},{"text":"so that's why you see the exec/ls twice","width":231},{"text":"because this is the program that we want to run and this is the argument zero that it will get inside main","width":562},{"text":"so we could probably change this to just say ls for example","width":293},{"text":"okay so that'e exec, notice that my program never printed hello world","width":310},{"text":"that's right, it had a mind wipe","width":101},{"text":"if exec works, we never return, we don't execute anymore code here","width":374},{"text":"so the only way to say print out hello world is to make it deliberately fail","width":352},{"text":"I'm pretty confident that that program, that image does not exist","width":234},{"text":"so exec will fail, it will return -1 and now it prints hello world","width":324},{"text":"it continued on and in fact we can actually print something useful by using perror","width":634},{"text":"my exec failed and we used perror","width":277},{"text":"it prints out your string a colon and a little message here","width":261},{"text":"so here we go, my exec failed: no such file or directory","width":309},{"text":"doesn't tell you which line it failed on but at least you have a hint as to the kind of error that happened","width":569}],
  // Part 3
  [{"text":"right so that's our program in a nutshell","width":246},{"text":"so, perhaps we can decide what its actually going to do as a whole","width":583},{"text":"time to interview you neighbor","width":69},{"text":"what do they think? see if they can describe it tersely in 10 seconds or less","width":290},{"text":"what does this whole program do? what does it create. what are the contents of that log file?","width":351},{"text":"[students discussing]","width":3593},{"text":"okay! so we know that all standard output is going to go to log.txt","width":293},{"text":"we print out \"captain's log\" to that file","width":184},{"text":"and then we run bin/ls","width":207},{"text":"let's see what happens","width":86},{"text":"I ran it, I didn't see anything on the output here, so presumably, there's something waiting for me inside log.txt","width":362},{"text":"let's have a look. oh yes! look at that! there is a whole long listing of .h files inside my log file","width":510},{"text":"how did they get there?","width":83},{"text":"well yes, when we call the exec we did a mind wipe and it's going to start executing the code of /bin/ls","width":379},{"text":"but standard out has already been redirected to go to a file","width":385},{"text":"so we change the context in which /bin/ls runs","width":395},{"text":"and we print. and because we changed the directory of this process to usr/include, when we said \"turn me the current contents of the current directory\", we got the contents of /usr/include","width":691},{"text":"so that's our first significant system program","width":220},{"text":"uses all sorts of little commands","width":118},{"text":"I encourage you to play with it","width":210},{"text":"now, I want to show you a little challenge this is one of the. this is the only algorithm I know that was actually published on 4chan","width":1308},{"text":"cesspool of the internet","width":160},{"text":"okay, so, my question is, what's it do and how's it work?","width":755},{"text":"so this is you versus 4chan. what does this program do?","width":452},{"text":"notice its got a fork() in it","width":66},{"text":"[silence]","width":8244},{"text":"okay, I think it's time for a demo. see if your expectations are matched, right. so let me give you some values","width":758},{"text":"yeah lets do that. okay, here we go.","width":798},{"text":"yes, what we have here, ladies and gentlemen, is a sorting algorithm, system programming style","width":431},{"text":"it's clearly O(n), right? all we saw is a single loop","width":333},{"text":"yes this can sort integers. here I have another example","width":881},{"text":"look at that! isn't it brilliant?","width":361},{"text":"badum badum badum badum","width":217},{"text":"it's still calculating...ok. alright.","width":145},{"text":"so how does my order n algorithm work?","width":450},{"text":"alright so it goes by the name \"sleep sort\"","width":878},{"text":"and like I said, this was invented in 4chan, it's not actually published anywhere else","width":320},{"text":"but it's a nice cute example of using fork() and atoi that we've talked about these things and sleep()","width":385},{"text":"so how does this thing work? well it makes a whole lot of processes","width":270},{"text":"in fact, remember that C tells us the number of arguments to our program","width":389},{"text":"so this is going to pause every single integer","width":216},{"text":"when it does, it makes a whole lot of processes that because we're counting down C, it makes enough processes one for each integer that we provide","width":590},{"text":"and each process gets a different value of C","width":211},{"text":"because it exits the while loop at different times","width":223},{"text":"so, each process ends up calling sleep() for the right amount and then prints out the number","width":368},{"text":"so, if you entered 1 it sleeps 1 second if you enter 100 it sleeps for 100 seconds","width":373}],
  // Part 4
  [{"text":"alright, the only other thing I want to say about this. this is the second semester I've presented sleep sort. Before that CS241 didn't have a sorting algorithm","width":714},{"text":"and it kinda felt lonely because 125, 225, every other theory class you take has a sorting algorithm. now we can proudly say, yes, system programming has a sorting algorithm","width":734},{"text":"right, so, questions about this algorithm? other than never use it!","width":578},{"text":"right so clearly it's got some limitations. sleep's going to count for a second in seconds etc","width":490},{"text":"and also it relies on the operating system to implement sleep so it's not truly an order n algorithm. the operator is just delegating all the work to the operating system to make sure the processes sleep the right amount of time. in other wrods, when you call sleep your process gets stuck, it's not going to execute anymore instructions until the operating system wakes it up. we'll be talking about how it does that when we talk about scheduling later on in the course","width":1925},{"text":"let's go back to some more serious questions. what does the child inherit from the parent?","width":509},{"text":"all the money, right, no. ","width":217},{"text":"what've we got? what've we seen so far, what does it inherit when we call fork? what do you think it inherits? what do you get? i'm sorry?","width":832},{"text":"variables, yes! so you get a copy of the memory","width":301},{"text":"all of the processes memory you get a complete copy of that. ok, what else?","width":683},{"text":"that's kind of all in the memory, yes all of your c variables etc, the state of any kind of libraries like the rand. state of the random number generator. what else might you get?","width":929},{"text":"OK, I'll give you two. current directory and open files","width":1036},{"text":"if you've opened a file you'll fork will also be able to read and write into that file. more about that more later in terms of the details in terms of what happens when both the parent and child read and write into the same file","width":1062},{"text":"what's different between the child process and the parent process?","width":290},{"text":"here's a couple of differences. first of all, guess what, if you call getpid you get different numbers","width":816},{"text":"what else is different? the return value of fork ","width":1050},{"text":"if the result is greater than zero you know you have a child and therefore you must be the parent","width":1541},{"text":"oh yes","width":149},{"text":"there's something else that's different","width":538},{"text":"what do you think getppid does?","width":325},{"text":"yes! parents! hey I want to know the ID of my parent","width":356},{"text":"so of course that's going to be different","width":375},{"text":"you could probably write out a program to print the parent ID in two different ways. in the parent if fork returns a number it's easy, it's my ID. if i'm the child then I should be calling getppid to get the parent","width":1023},{"text":"so if I've got these two processes and I've shown you that we can write an if statement so they can do two different things, how can I make it so my parent waits for the child to finish?","width":927},{"text":"easy, we call wait or waitpid. let's have a look at this","width":530},{"text":"I will write a little program that immediately forks","width":516},{"text":"if result is greater than zero..what? I'm the parent","width":584},{"text":"OK, what should we do with the parent? let's wait for our child to do something","width":501},{"text":"so how do we finish? for this we'll look up waitpid","width":917},{"text":"we'll say who are you waiting for? I could pass in minus one to say 'hey I'm waiting for anybody', but actually I care about my child finishing","width":559},{"text":"then I can find out what happened to them, so I can basically do a post mortem on my child here and I can pass in some options but I don't need them for this lecture so I want to put zero","width":922},{"text":"let's have an integer and notice that I'm passing in the address of the integer","width":360},{"text":"if I do that waitpid can write it's notes into that integer because I've given the address of the integer","width":725},{"text":"now we could print something out about the child. percent d... waitpid said","width":1186},{"text":"ah, didn't save it","width":642},{"text":"our program get's result. what does our child do?","width":402},{"text":"our child does nothing. well actually it just gets to the end of the program, it finishes","width":432},{"text":"so the child says 'oh my result is actually zero so let me do what's down here. OK, nothing, I'll just finish, I'll just quit'","width":462},{"text":"we could write some special code for the child though. why don't we say sleep for a little bit like two seconds and then quit","width":928},{"text":"byeee","width":248}],
  // Part 5
  [{"text":"okay so if this works, then what we should see is the child will sleep for two seconds and our parent will then be paused also for two seconds","width":801},{"text":"because it had to wait for the child","width":361},{"text":"okay, so one, two, bye and then our parent can continue right?","width":389},{"text":"so we've made the parent wait for the child","width":312},{"text":"now there's a little bit more to using waitpid","width":321},{"text":"that actually there are some macros down here ","width":389},{"text":"here they are, that actually to put useful information out of this, I should use these macros","width":380},{"text":"so for example, we can find out the exit value of the child but only the lowest seven or eight bits","width":702},{"text":"sorry, eight bits, so if your child return a value 42, great we can see that","width":495},{"text":"if it returns a value 304, I'm sorry you won't see that as a value, you only get the lowest eight bits","width":426},{"text":"we can also check to see if it was terminated by a signal","width":224},{"text":"right, how can you generate a signal?","width":291},{"text":"pull our a whistle from your pocket, yeah but you could also press control c on your keyboard to interrupt a process","width":448},{"text":"and when you interrupt a process, you are sending that process a signal","width":428},{"text":"there's other signals that can happen as well","width":159},{"text":"so if your process tries to write into read only memory, your process dies","width":438},{"text":"how does it die? it gets sent a signal that in cannot ignore","width":285},{"text":"so as you can see, we can actually find out some things about our child","width":303},{"text":"and you'll be using that in this week's little assignment before section","width":488},{"text":"alright so let's make it print something out, right so in this case what we'll do is we will say","width":706},{"text":"if it exited, so let's check the value of status","width":373},{"text":"then we'll print out the exit value","width":528},{"text":"WEXITSTATUS we'll get those lowest bits and we'll make the child return 42","width":1515},{"text":"did it run? one error, what's my error?","width":811},{"text":"oh, okay so I have not included something..","width":1038},{"text":"one two yay, okay great","width":168},{"text":"so this time you can see our waitpid got some arbitrary value","width":288},{"text":"if you actually want to pull out the exit value then you should use those macros","width":453},{"text":"alright so if exited, then we know that we can actually pull out an exit status as well","width":410},{"text":"right, so how do I wait for my child to finish? waitpid!","width":351},{"text":"and on here how do I find the exit value? you should use the if exited then we can use the WEXITSTATUS macro","width":1113},{"text":"and all these macros do is just pull out the relevant bits and do some bit shifting from that original integer","width":697},{"text":"okay, right so are you ready? page 2","width":413},{"text":"how do I start a background process? well a background process is something that we want to run in the background","width":379},{"text":"right we don't care about interacting with it","width":365},{"text":"maybe I want to actually say compile a program in the background","width":227},{"text":"let's do it from the command line here so","width":404},{"text":"for example if I want to look at the contents of /usr/include/stdlib.h","width":522},{"text":"right, I could say that actually I just want to send that to a file","width":609},{"text":"but I don't want to wait for this to finish well I can just put an ampersand at the very end","width":318},{"text":"that means run it in the background","width":206},{"text":"and I can continue doing this whilst that copying happens","width":392},{"text":"we could do the same thing in C by not bothering to wait","width":650},{"text":"so I've got my fork here and I could do other stuff in the background ","width":476},{"text":"sorry I could do other stuff inside the parent and not wait for the child to finish","width":313},{"text":"so this is why fork is very powerful right? now I can fork and start a process to compile something. I could fork and start another child process to connect to the internet","width":563},{"text":"and I don't have to wait for these things to complete","width":164},{"text":"I can do things in parallel yay","width":201},{"text":"right, so now if you've got 4 CPUs you can use all four at the same time to compile different parts of your program for example","width":557},{"text":"there is a problem though","width":397},{"text":"good parents don't let their children become zombies","width":437},{"text":"suppose you created a child process and off it goes and it starts compiling stuff","width":439},{"text":"and then you the parent process finish, you quit","width":252},{"text":"what happens to the child process?","width":142},{"text":"it's still alive! ha ha ha compiling alive, it's still going right!","width":449},{"text":"but it has no parent","width":198},{"text":"uh oh, right, so, uhm, so here's what happens, if nobody is around to wait for the child when it finally finishes","width":1095},{"text":"if you don't call wait on a finished process, you get a zombie","width":277},{"text":"so a zombie is a dead process","width":150},{"text":"that no one cares about","width":228},{"text":"so waitpid is like going to the gravestone and saying yeah I remember you let's do a postmortem ","width":228},{"text":"if you don't do that to a process, the system says well actually somebody might want to know about that process","width":392},{"text":"they might want to know its exit value for example","width":138},{"text":"so it's going to take up some system resources, not a lot, but a little bit to remember what happened to that child","width":557},{"text":"so that's what a zombie is, it's a dead process that nobody cares about","width":506}],
  // Part 6
  [{"text":"alright, doesn't sound too bad, right? but what would happen if we had too many zombies?","width":607},{"text":"eventually, the system says \"I'm not creating any more processes for nobody\"","width":294},{"text":"yes? I will kill another process so your fork(), for example, would fail or another processes fork() would fail.","width":960},{"text":"okay so, you can do that. the child will continue and the child will do what it wants to do. okay?","width":380},{"text":"um, so, uh, the system has one thing it will try to do to prevent zombies. which is that in this situation if the parent finishes, and the child is left running","width":982},{"text":"that child is re-parented","width":265},{"text":"given a new parent","width":51},{"text":"so if it called get ppid(), it doesn't crash, it doesn't explode, no it has a new parent.","width":521},{"text":"I'll tell you who the parent is","width":181},{"text":"process 1","width":253},{"text":"the ultimate of processes. the first process in your system. the first process that ever existed when you booted up: process 1","width":473},{"text":"well, kind of the first process","width":109},{"text":"the first process with a process number anyway","width":206},{"text":"the ultimate of processes","width":78},{"text":"right? which classically has been initially or just initiate or just init","width":614},{"text":"goes by various names","width":213},{"text":"and it calls wait","width":173},{"text":"on the poor little orphans","width":114},{"text":"alright, to ensure that we don't get zombies.","width":292},{"text":"so, life is not too bad if your parent dies right? the children as they finish, they will get reparented onto init. then init will make sure it calls waitpid on any future children that die","width":1190},{"text":"so, we run into problems, though, when we have a long-running parent.","width":494},{"text":"so let's say you made a webserver","width":468},{"text":"well the parent tries to live forever, wheeeeee, it's going to keep going around, hey! lets just run forever, right?","width":525},{"text":"and I'm going to serve the web request. and for each web request, I make a new child","width":604},{"text":"so if we have it so that the child does the work, each web request, each HTTP request we might run into a problem now","width":602},{"text":"because the parent is making all these children and never cleans up after them","width":463},{"text":"so in this scenario, when you've got a long-running parent, you've got to remember to call wait() or waitpid()","width":634},{"text":"because if you don't, you'll have a whole lot of zombies","width":220},{"text":"you'll have a whole load of exit values and other meta information about the process thats still just lying around inside this system","width":593},{"text":"okay, so, you must remember to call waitpid() to clear up or to prevent zombies","width":1215},{"text":"okay, alright, so, we won't talk about signals today. instead, let's see if I've got some notes","width":804},{"text":"okay! right!","width":440},{"text":"just a heads up, we'll shortly be publishing this","width":324},{"text":"so, your assignment for this week is two-fold","width":299},{"text":"first of all, time to jump into android","width":282},{"text":"get the SDK and the NDK installed and working on say, your laptops","width":325},{"text":"or start using the lab if you don't have a laptop","width":307},{"text":"we want you to basically make something simple and [something] to get as many people as board with actually using the NDK/SDK if possible","width":566},{"text":"secondly, you'll be using fork() and exec() and the stuff we've seen today to make your own simple \"make\" program which we've called \"fake\" instead of \"make\"","width":783},{"text":"so, let's have fun with learning to program fork() and exec() and enjoy your weekend! thank you very much! Questions come and see me now or find me in the coffee shop.","width":642},{"text":"questions come down and see me now or 5 minute coffee shop","width":128}],

  //Start Lecture Video 3
  // Part 0
  [{"text":"good morning cs241 people. how are you this morning?","width":1248},{"text":"great, how's everybody else?","width":225},{"text":"alright, let's try this again. okay, alright, yes, good morning! you've enrolled in cs241, for better or for worse, you'll learn a little bit about systems programming","width":470},{"text":"and for the next 50 minutes, we are going to talk about some new stuff, some old stuff, some [something] stuff, some blue stuff","width":286},{"text":"I lied about the blue stuff","width":94},{"text":"alright so, all I have to do is open my mouth and talk and type. all you have to do is open your brain and think","width":403},{"text":"how hard can it be?","width":66},{"text":"let's try again: good morning people, how are you?","width":178},{"text":"great!! good morning class.","width":64},{"text":"alright, so, the reason I do that is because maybe we'll get a few brain cells working before we actually dive into this stuff, okay?","width":448},{"text":"so, here's the exciting news. yes there are exams in this course. there's no single midterm. instead, there are multiple choice exams scattered throughout the course","width":674},{"text":"and the first one will be on Friday","width":321},{"text":"yes, so, please come on friday, bring your icard, bring a pencil, and look forwards to multiple choice questions which go over the things we've covered so far","width":601},{"text":"anything we've done in lectures or you've done in previous sections, it's fair game.","width":424},{"text":"okay, so I'm looking to make sure basically that you understand the basics of C programming","width":314},{"text":"so as a result, some of the questions we've got today are to do with [something] in C.","width":313},{"text":"alright so, where's my handout?","width":281},{"text":"okay, let's have a look at this first question then, right","width":461},{"text":"I've written a C process, or any kind of process really, that runs for a long time and it's creating other processes","width":555},{"text":"so for example, it might call fork() and then the child process that you've just created calls exec","width":479},{"text":"but we never wait for our children to finish","width":296},{"text":"but they do. but we never call wait on them","width":161},{"text":"what have we created?","width":160},{"text":"zombies! yes! we've created dead processes, processes that have finished but no one's cleared up after them","width":492},{"text":"now, if you see any zombie movies, you'll discover there's different ways to kill them. right.","width":314},{"text":"but, running away is usually what's recommended in most zombie movies","width":275},{"text":"but fortunately, what we do in C programming is just call wait, and when we do that, the system can kind of clear up the mess left by the zombie","width":617},{"text":"if we don't do that, then eventually, we're unable to create new processes. the system runs out of space","width":539},{"text":"alright so yes, we've created a zombie in this case","width":342},{"text":"so a zombie's a dead process where all we're returning essentially is it's exit status. but it's still taking up a little bit a system resources because we haven't finished cleaning up after itself","width":768},{"text":"and it only happens if no one ever calls wait","width":193},{"text":"so for that, I need a long running process","width":335},{"text":"so let's see what happens in the other case where my child outlives the parent. would you like a handout?","width":461},{"text":"we have a question","width":479},{"text":"that happens when the parent dies. okay?","width":199},{"text":"so that's why the question up there says \"long running parent\". the parent hasn't died. it just doesn't care about its children","width":422},{"text":"the children have finished, alright, perhaps they've called \"exec\" and done an \"ls\", perhaps they finished doing a computation, perhaps they finished serving a webpage to a client.","width":511},{"text":"the point is, the child processes, once they finish, they're still taking up space","width":466},{"text":"alright so, let's not have a look at a zombie. let's have a look at the other case that you just brought up","width":359},{"text":"which is what happens when the parent finishes first?","width":382},{"text":"ok, so, I've got a little bit of code here, and uh, first of all you could ask, what's it actually print? the answer being nothing! because actually if you look at it, you'll see this #if #endif","width":740},{"text":"those are preprocessor directives to tell the preprocessor to say \"well if this expression is true, then include this, otherwise don't\"","width":586},{"text":"and, so of course right now, there is no main method. compiler would never actually see the code we wrote in here","width":379},{"text":"right, I could write garbage in here. like, alright, you know I could write \"superbowl\"","width":492},{"text":"um, and it's not gonna find an error in there because the actual compiler doesn't check for the syntax. it keeps going until there we go","width":520},{"text":"alright um, so let's fix that, let's just say #if 1","width":295},{"text":"okay, right, and we'll run this and a question for you is, before I run it, how many times is it going to print \"I am process\"","width":759},{"text":"cuz you see it happens before fork()","width":102},{"text":"and secondly, who's sleeping? is it the child that's sleeping or is it the parent that's sleeping?","width":674},{"text":"if you made up your mind, tell your neighbor. see if they agree with you","width":483},{"text":"if you're not sure, at least have a guess","width":2192},{"text":"okay! alright! so, who's sleeping? is it the child or the parent?","width":429},{"text":"the child! remember, fork() returns twice, if you like. because, when we call fork, after it executes, we've now got two processes. we've got the original process, and the clone","width":767},{"text":"the doppleganger","width":64},{"text":"that believes it really is the same original process because it can look back in its mind and say \"yes, I was born in kansas\"","width":335},{"text":"right? it remembers all the variable states but its actually got a copy of everything (well, nearly everything)","width":461},{"text":"but there's one asymmetric difference which is that, if you're the child, your return value of fork() is zero","width":436},{"text":"so we are asking the child to sleep()","width":272},{"text":"okay, meanwhile then, both processes carry on independently, you can imagine them running on two different CPUs","width":482},{"text":"they're completely different processes. just like you can be running Minecraft and working on your chemistry homework at the same time","width":513},{"text":"and we print something out. we print out our pid and our parent's id. so let's run this...see what happens","width":576}],
  // Part 1
  [{"text":"alright, so, the first surpise is that we see 'I am process' twice","width":956},{"text":"that's weird, why did that happen? let's talk about in a moment","width":177},{"text":"and then second thing is one of the processes said:","width":248},{"text":"and my parent is 1","width":289},{"text":"okay, how, why? well remember we made the child sleep. we made it sleep for an extra second. in that second it's original parent finished","width":686},{"text":"it exited. so now what are we going to do with the child now? who's parent should it be?","width":231},{"text":"and now's where the system says 'I know what! we will reparent you back to the ultimate process' parent process id one","width":643},{"text":"so that's what happened there. if we didn't have this sleep then we have a race condition. maybe the parent finished first, maybe the child would've finished first","width":495},{"text":"we cannot say for sure who would finish first so that's why we put the sleep in","width":286},{"text":"okay, but why is it that we saw 'I am process' twice?","width":321},{"text":"OK, if you think you have the answer wave your hand in the air like you just don't care. you care","width":415},{"text":"alright, very good yes. okay! so, a few people know. i'll give you a hint","width":528},{"text":"I'm going to change the program very slightly by putting '\\n' in there","width":802},{"text":"and now you only get 'I am process' once. so by putting ","width":439},{"text":"'\\n' in there I changed the output of the program quite significantly. what does '\\n' do?","width":784},{"text":"yeah! thanks. in our little example here, C decides to flush the buffers. so there's abuffer inside the process and it's just collecting bytes. just collecting the characters to print out","width":920},{"text":"but it didn't bother to actually write them out to the system yet. it only decided to do that when we saw the new lines. so in this example we ended up callling write(), we printed it out, before we called fork()","width":931},{"text":"in the first example it was still inside the process so when we forked it was still there inside the child as well. the child says 'oh yeah,I've still got these bytes to print out. I haven't got round to it yet'","width":798},{"text":"so be wary about this. the other thing to note is that at the very end of the program part of the clean up that the C library does is says 'hey ok any open file descriptors if you have something to write out do it now because this process is closing. it's time to flush all the buffers' so it does that as part of the standard clean up process","width":1464},{"text":"right, so that's a little example there. how much buffering actually happens depends partly on wheter your trying to send it to a terminal or a file","width":1059},{"text":"if you're sending stuff to a file it will actually keep buffering beyond the '\\n' so it tries to have even better performance by buffering stuff out to a larger amount before writing them","width":952},{"text":"questions about this example?","width":207},{"text":"yes?","width":288},{"text":"right, so if we choosed fprintf() ","width":382},{"text":"aha, OK, right, so puts() is equivalent to printf() %s \\n. OK so that would've actually flushed it as well","width":1170},{"text":"and so if I used fprintf() the same thing would've happened if I sent it to standard out because the buffer of standard out by default when I'm sending it to the terminal is to wait until I say new line","width":714},{"text":"if I send it to standard error, well lets just do it. we would have seen it once because the default for standard error is just to push things out. we don't want to wait, we're not trying to get high perforance. you want to know your error messages as soon as possible just in case the process dies very quickly","width":1427},{"text":"alright, so, if we wanted... remember how I said we've got somewhat of a race condition? I've just put in a sleep for a second and that kind of works on this particular system","width":727},{"text":"if we wanted to actually wait for our child ","width":550},{"text":"then I can call waitpid(). so how's waitpid()? let's check the old man page. waitpid","width":1273},{"text":"so, you see we pass in the pid we got from fork. we can get some status information and there's some flags as well that we don't need today","width":872},{"text":"so what we'll change now in our output? ok, what's our little error here? ","width":649},{"text":"oh I didn't declare a little variable. there we go","width":832},{"text":"OK so this time the parent of the child is still the, huh. OK.","width":1420},{"text":"why would that be? so the parent is waiting for the - oh. okay, yeah we called waitpid() on two, we should only be doing that inside the parent, so let's do that for the parent. so if I'm the parent then ","width":1435},{"text":"we'll wait for our child to sleep","width":399},{"text":"OK yeah now thats sorted, that makes sense. right, so, what've we got there? the orignal one is 198 and it's parent is 43 which is probably this little shell program here that's running and the child is 199 and it's child is 198 so we should have two numbers right which are the same","width":1367},{"text":"this is the child saying 'oh look here's my parent 198 and this is our original program 198 saying my parent is 43'","width":624},{"text":"so, you can actually discover all the processes running on your system. this one doesn't have that many and I don't know if you've got pstree involved","width":728},{"text":"you can use ps and pstree to kinda get a hierarchal view of all the processes that a process has. there's different options to say OK, I want to know about my process or everybodys processes but don't worry that's not on the test, okie dokie...","width":1056}],
  // Part 2
  [{"text":"so, now it's time to talk about signals","width":240},{"text":"unless anybodys got any last minute burning questions","width":263},{"text":"ok, right, signals are called. there's a lot to signals we're just going to do an introductory part today","width":446},{"text":"but signals are the software equivalent of hardware interrupts","width":379},{"text":"so, think about hardware for a moment ","width":208},{"text":"i can have things like a clock timer that goes off every say hundred milliseconds ","width":414},{"text":"and interrupts what the CPU is currently doing","width":173},{"text":"and when the CPU sees that it says 'oh I'd better stop doing what I'm currently executing' and run some additional code thats gonna cope with the fact that my little clock timer has gone off","width":692},{"text":"or I've got some bytes from the disk which are ready to read and I want to stop what I'm doing and execute some different code","width":434},{"text":"or some information on the USB bus has arrived like someone plugged in a USB keyboard or typed something and I need to handle those bytes","width":564},{"text":"right, so interrupts allow us to stop doing what we're currently doing and process some different code","width":384},{"text":"we could do the same thing with hardware and that's signals","width":183},{"text":"and, we can send signals to our children and we can get a signal back evern when one of our children dies, which is useful","width":663},{"text":"and we can have a lot of fun with them because they can do differnt things","width":488},{"text":"so, first of all, that's a list of all the processes","width":436},{"text":"let me send a signal to one of these processes","width":299},{"text":"so, uhh, ok, do I have a pid variable here? no I don't. okay so, let me just send -9","width":559},{"text":"to say process 43. what've I just done?","width":548},{"text":"yeah, I've killed myself","width":145},{"text":"ok, the kill command says 'send a singal' and -9 is the ultimate of signals - hint hint - terminate this thing with [something] it can't stop this signal","width":992},{"text":"if you send this signal to a process that process is gone","width":422},{"text":"there's no way to protect against this signal","width":296},{"text":"this is the big weight falling on top of a signal. this is how you can kill processes","width":232},{"text":"so if you know - if you are a superuser and you know a processes id, you can get rid of it","width":645},{"text":"OK, so fortunately I have another processes here. let's see if this one works","width":493},{"text":"unfortunately I can't actually write any code so it's time to reboot my machine","width":896},{"text":"okay, so! we can do something similar in our programs as well","width":391},{"text":"let's pull up some example code here","width":2347},{"text":"alright, we won't do that straight away, ok, so here's some typical fork exec() code","width":375},{"text":"the child decides to run /bin/ls and the parent will do something else","width":758},{"text":"so, let's first of all just start off with this. there's nothing new in this code, I just want to prove to you that the child runs exec() here and should print something out","width":773},{"text":"here we go, so yeah we'll move on it. the child runs","width":205},{"text":"okay now, what we'll do this time is I'm going to make the child sleep for one second because now I'm going to call kill() from my program here. I think you can guess what's going to happen here","width":701},{"text":"alright so, we'll check kill() on section 2 and you'll see that we can send a signal to a process","width":734},{"text":"alright so, we have the id that we wanted to call, there it is, it's called child, and what should we send it? well let's send it signal 9","width":1114},{"text":"oh, we had a sleep there. so this time you'll see the poor child never got to run /bin/ls, we klled it and it didnt' stand a chance","width":637},{"text":"we could also send a signal called SIGINT, in fact, rather than send it to the child, why don't we send it to ourselves","width":893},{"text":"let's do it straight away","width":249},{"text":"I wonder what SIGINT stands for","width":478},{"text":"ok, so the SIG is a standard thing you'll see prepended toward the singal of different names","width":446},{"text":"INT stands for interrupt","width":188},{"text":"remember how you can press ctrl+c and the program stopped? this is how it works","width":441},{"text":"the shell says 'oh look, look, someones trying to press ctrl+c, I will send SIGINT to the running process'","width":488},{"text":"and that's how we break our processes","width":594},{"text":"well, this is where the fun begins. I don't have to see my processes die when you press ctrl+c","width":572},{"text":"we can do other things for the SIGINT and for that we're going to look at SIGACTION","width":649},{"text":"SIGACTION allows us to register a callback function that's going to be run when the signal is given to this process","width":690},{"text":"ok, so, here's how sigaction() works. I didn't want to use sigaction(), I was going to use the simpler version","width":1042},{"text":"yeah, let's use signal() ","width":994},{"text":"we'll talk about sigaction() later on in the course","width":297},{"text":"ok, this is what I wanted to show you. so our typedef here. is that large enough for people? can I make it larger?","width":685},{"text":"can you read that at the back?","width":256}],
  // Part 3
  [{"text":"okay alright so, we've got a typedef that say \"typedef void (*sighandler_t)(int)\"","width":404},{"text":"and then this sighandler underscore t. let's talk about this for a moment. as to how to parse this","width":868},{"text":"alright, so we know that typedef just really means \"hey! I'm an alias\" I'm just defining a new type and in this case, this is a function pointer","width":752},{"text":"so, we can [something] this by unpacking it from the inside out. so, we can have a function that takes an integer","width":586},{"text":"and returns nothing","width":271},{"text":"and, our type goes in the middle (between the parenthesis)","width":196},{"text":"so have a pointer to a function. in other words, just, where do we want to send the CPU to actually execute some code? here's our little function that's gonna happen","width":584},{"text":"and then I can install this handler for a particular signal","width":260},{"text":"so should a certain signal happen, run this handler","width":246},{"text":"alright, so, let's do that","width":513},{"text":"I'm gonna have a signal handle then. and I can call it noway. I can call it anything I want, really.","width":559},{"text":"remember it takes a void. call it agentsmith alright, you'll see why in a moment. and remember it takes an int","width":858},{"text":"so, at this point, we'll write something out. like, \"you can't stop me!\"","width":549},{"text":"okay, how many letters is that? who knows? about 13","width":363},{"text":"and, we want this to run anytime someone tries to stop this program","width":214},{"text":"so, let's use that signal() thing","width":153},{"text":"so we'll say signal when I get a SIGINT, run agentsmith","width":675},{"text":"and, then i'll have a little loop that does a. keeps itself busy. while(1) loop forever","width":460},{"text":"so, while true, keep going","width":117},{"text":"alright so, let's run this little program here","width":851},{"text":"okay, off it goes, and let's try and press Ctrl-C","width":479},{"text":"oh no! alright, you can't stop agent smith here. anytime you press Ctrl-C, that signal is delivered and fortunately, you can press Ctrl-\\ and that should","width":876},{"text":"okay, there we go, alright. I can at least Ctrl-Z it so I can actually stop the program. so something else to show gives me the ability to pause the program.","width":506},{"text":"and if I wish, I could actually put that into the background. does it support it? okay, yeah, it does and now its in the background","width":617},{"text":"and now it's just running and using up my CPU","width":181},{"text":"if I do \"ps\", there it is. it's running. it's used up 32 seconds, now its used up 34 seconds of CPU, I'd better kill it.","width":502},{"text":"okay, kill minus 9 106","width":235},{"text":"it's gone! remember, SIGINT you cannot stop. so you could try to. sorry, SIGKILL or SIGTERM you cannot stop SIGTERM","width":784},{"text":"alright let's go back","width":195},{"text":"right, so let's first see what it's going to do with child processes. here's the whole thing. let's change our message to say \"child finished\"","width":631},{"text":"and this time, we will make our message a string here so char mesg","width":736},{"text":"I can get a signal when one of my children dies","width":325},{"text":"so strlen(mesg)","width":270},{"text":"okay, right, so, write out the number of bytes that's in that message","width":536},{"text":"so now, rather than doing SIGINT, guess what, there's something called SIGCHILD","width":364},{"text":"and let's make this a little larger","width":354},{"text":"and this time rather than looping forever, we'll do our fork() and now when the child is finished running ls, why did it, oh, aha!","width":1672},{"text":"that's not gonna be very useful, okay.","width":329},{"text":"we'll get rid of the sleep() there as well","width":341},{"text":"so, this time, the child runs ls hopefully, oh, no.","width":367},{"text":"SIG, oh, I can't spell","width":195},{"text":"yes, for some reason, CHLD is spelled without the I","width":272},{"text":"I guess bytes were expensive in those days? okay, alright so, hooray! here's what we've got","width":769},{"text":"the child ran and then the parent was notified asynchronously that the child finished","width":506},{"text":"so if you wanted to do some stuff in the background and you're worried about zombies, this is the perfect place to put that waitpid","width":475},{"text":"to say \"hey! I need to clean up my children\"","width":156},{"text":"so that's in fact a very common convention with these kinds of programs","width":334},{"text":"is, if you don't want to just fork() and then wait() immediately, just write yourself one of these signal handlers and then we can put our waitpid in here","width":595},{"text":"so, we'll need to know the child id, we have a status variable, and a zero here, okay","width":724},{"text":"the last thing I need to do here is that child itself [something] out of scope here. so instead, let me declare as a global variable","width":723},{"text":"now, global variables in large programs considered [something] programming practices. however, you will often see them in small, single-file system programming examples","width":943},{"text":"because it's an easy way to communicate with signal handlers","width":401},{"text":"alright so now, okay, well, you can imagine if I was actually able to type, you can see that we're being good citizens and we're cleaning up our children using a signal handler","width":896}],
  // Part 4
  [{"text":"right, so, let's go back and up. what've we got?","width":615},{"text":"alright, what is a signal? It's a software interrupt. it interrupts what the current process is doing","width":801},{"text":"how do they work? that's a good question. there isn't a quick explanation of that that's any good","width":424},{"text":"I suppose a short answer would be 'hey we'll cover more in later lectures' but a slightly more useful answer would be that the kernel delivers a signal to the process ","width":875},{"text":"and I've shown you two kinds of examples","width":146},{"text":"an example where a signal where we can register a handler for that signal and we can change the default process","width":534},{"text":"the default example of the SIGTERM where you cannot register a handler and instead the system will actually destroy your process. will actually quit your process","width":876},{"text":"right, how do I send signals programmatically?","width":369},{"text":"remember?","width":376},{"text":"OK, so it's not signal(). if you call signal() - it's not the right answer - if you call signal() this registers a handler","width":777},{"text":"instead what you need is to say kill()","width":531},{"text":"seems pretty mean, right. all of a sudden we're having a bad day when they designed these things","width":362},{"text":"my assumption is that the very first signal that was developed that was useful was the ability to kill other processes because they got out of control","width":455},{"text":"and then this interface was extended to include other signals like ","width":391},{"text":"'hey my children finished' or 'hey I've got some bytes that need some processing'","width":326},{"text":"so with kill we pass in the process identifer and then a signal name such as SIGINT or SIGTERM","width":1108},{"text":"how do I send a user defined signal? easy! we can call kill and ister them","width":654},{"text":"sigusr1 and sigusr2 ","width":650},{"text":"why should I use signal symbols not the constants? well because the actual constant value varies from operating system to operating system","width":527},{"text":"exception being the early signals that were defined way back in the history before I was born","width":517},{"text":"and the one that everybody knows is that nine is the same as SIGTERM, just kill a process","width":553},{"text":"so it's a common idiom to say 'hey kill -9' meaning this process cannot escape, we're going to stop it","width":663},{"text":"and finally what's the alarm signal? ok, this is fun. when I make a process","width":1098},{"text":"we can set up a process so that it gets a signal in so many seconds. so it can say 'ok I won't have an alarm in 3 seconds'","width":985},{"text":"so now I can have a little program here for - let's do it the old fashion way of C","width":539},{"text":"for i is zero, i less than something, i plus plus","width":615},{"text":"printf %d, i and we'll sleep a bit","width":661},{"text":"OK, so, we've set an alarm and then we just start printing out the numbers to start counting","width":1007},{"text":"this is the evilist alarm clock you've ever seen. it kills your process!","width":442},{"text":"um, most alarms don't do this","width":233},{"text":"yeah, the default behavior for the alarm system is to kill your process","width":300},{"text":"and, where does the word alarm clock come from? that is actually the shell saying I'm going to call waitpid() on the program and then I'm going to use those wait macros that you've seen to determine why my program finished","width":1050},{"text":"or what happened to it. oh look my program finished because it got a signal alarm clock. and so the shell prints out something useful to alarm clock","width":443},{"text":"we of course could do something different form that. we could register a handler for this","width":549},{"text":"ok, so SIGALRM - if I could spell it correctly","width":355},{"text":"ok, and I'll call it thanks","width":338},{"text":"void thanks() takes an int and I'll write one \"Thanks!\"","width":579},{"text":"and how many letters is that? I don't know, about six, right?","width":332},{"text":"so let's run this now and if it works then in three seconds we'll get thanks","width":536},{"text":"hooray! good and now you see our program continues","width":248},{"text":"and now I need to get out of it","width":227},{"text":"so that's the alarm signal","width":98},{"text":"you could use this for example to give a child so many seconds to complete","width":247},{"text":"if it doesn't complete you could deliver the alarm signal to it","width":508},{"text":"questions? ok, page two!","width":128},{"text":"<pause>","width":576},{"text":"alright, so we did this. we did this, right? we talked about how this is inside the process","width":576},{"text":"it's inside the C buffer for standard out","width":576},{"text":"because there's no new line","width":128},{"text":"so when you call fork we end up with two processes which now continue and they both have I'm a process sitting inside the buffer waiting to be flushed, waiting to be sent","width":704}],
  // Part 5
  [{"text":"right, now then, let's say I want to review some C code","width":650},{"text":"let's say that you're trying to write a function called your version of strdup","width":311},{"text":"and it's purpose it to take a pointer to a C string and create a new C string by allocating some memory say on the heap","width":869},{"text":"or yeah, let's say on the heap","width":232},{"text":"and so let's have a look at the following code, perhaps we can figure out what's wrong with this code","width":358},{"text":"so, here's the code so far, we call assert() on source then we write a line of code which is going to be a, b or c","width":534},{"text":"then we say 'ok character p equals result' and then we have this idiomatic C loop here","width":467},{"text":"by idiomatic I mean here's a comon way that you see C code written where we want to copy things written from one side to another","width":532},{"text":"what's it do? and then finally we'll return p","width":145},{"text":"so, here's what it'll do, here's where you come in. I've got three different versions","width":319},{"text":"and also do you notice any errors? ","width":233},{"text":"anything you want to change in this code?","width":208},{"text":"ok, and two other kinda questions down here","width":371},{"text":"alright, have a go with that for five minutes. see if you can answer those questions. what happens for a, b and c","width":413},{"text":"and those other two questions. question two, question three. I'll walk around in case anyone's got any questions","width":18098},{"text":"ok, so, that assert() call at the beginning. the nice thing about assert() in production code it disappears, there's no performance overhead. it's not even evalutated","width":693},{"text":"the macro compiles to nothing, so the purpose of this is during debugging I want to catch early if someone gives me a bad pointer","width":585},{"text":"right, so if we say character result, then anytime we use the variable result in the future it will point to the beginning of the array ","width":432},{"text":"sounds great, we can use up to 256 bytes, in other words a string with 256 pics, 255 letters and a 0 byte at the end which fits","width":490},{"text":"however, this is an automatic variable stored on the stack, which means it's scope is only for the length of this function","width":627},{"text":"and, if we try to store anything in here, that's ok, but it becomes meaningless after the function returns","width":537},{"text":"so, yes, we can return a pointer to this array, but don't expect that memory to be valid after the function returns","width":444},{"text":"so, that's no good. we need memory that's going to exist for longer than that","width":307},{"text":"so we turn to malloc() to say 'hey give me some memory on the heap please'","width":239}],
  // Part 6
  [{"text":"right, okay uh, couple of problems here. one is, size of source","width":316},{"text":"so this tells me the size of a pointer","width":182},{"text":"so that's either going to be 4 bytes or 8 bytes","width":240},{"text":"oops. I didn't want that. I didn't want the size of a pointer.","width":203},{"text":"I wanted the actual number of characters stored at the pointer","width":370},{"text":"so, okay, let's fix this, oh yeah, that should be a pointer in there of course","width":282},{"text":"I want result to be a pointer to some memory.","width":177},{"text":"so let's call strlen on source","width":150},{"text":"hey! keep walking along until you find that zero byte. what's wrong with that code?","width":322},{"text":"yes, we're not going to reserve enough memory. so, in doing the copy, we will put that zero byte into some memory that we don't own","width":677},{"text":"that memory might be being used for something else","width":268},{"text":"so, we have a buffer overrun there","width":142},{"text":"alright, so, and then, the rest of this code walks through copying bytes","width":398},{"text":"and it might seem a little unusual to put an expression like this inside that while(), but this is kinda of a common example in C","width":534},{"text":"where we copy a course of bytes from source to the pointer, we increment both, and we keep going until we've copied the zero byte","width":488},{"text":"and when we've copied the zero byte, the result of this expression is zero, so the while loop terminates","width":384},{"text":"many compilers, by the way, would require us to put an extra set of parenthesis around this. otherwise, it would give us a warning","width":382},{"text":"you will also see similar code inside if() as well. where we assign a result to a variable and we also use it to [something] an if-expression","width":616},{"text":"alright, how are we doing on time, okay, we should keep going.","width":152},{"text":"so what's the purpose of 2? to check that the argument is non-null. when will it have no effect? well, when a macro is a defined so its when no debug happens to be defined...whoops, and you can set that as part of an option to gcc","width":1277},{"text":"and if you do that, then assert compiles to nothing","width":256},{"text":"alright so if malloc returned null, where would our program crash? would it crash at line 4?","width":420},{"text":"if result was null, would this crash?","width":238},{"text":"no, it wouldn't. p would just simply hold the result of 4","width":204},{"text":"we haven't tried to follow the money","width":140},{"text":"okay, so we've got an address (think of an envelope) and we haven't written a valid location on it, but we're not trying to read that memory","width":520},{"text":"we're just pointed something bad. we haven't actually followed the pointer yet","width":222},{"text":"so, it would actually crash when we try to dereference it. when we try to write memory in. so, its when we actually try to write to that location, our program would crash","width":690},{"text":"so how do we fix this? we could say \"well look, if the result is not valid, in other words, if it is 0, then maybe print out an error message and exit or perhaps return nothing\"","width":853},{"text":"just say \"okay, I'm sorry, I could not duplicate this\"","width":165},{"text":"and hopefully whoever calls this code is checking to see if the value is also NULL","width":517},{"text":"right. so. okay. did I ask a question for this one?","width":453},{"text":"right, what will this print?","width":254},{"text":"let's see if we write this out.","width":69},{"text":"so we've made an array of ten bytes","width":350},{"text":"and we, copy in 'ab'. so we've got the following: we've actually copied three bytes: we've got an a, a b, and a NULL byte or a zero byte at the end to mark the end of the string","width":1012},{"text":"and then we make a new variable called p2","width":242},{"text":"which is p1+1","width":69},{"text":"okay, so what type is p1? it's a character pointer. so p2 is pointing at this memory location, where we copied the b into","width":500},{"text":"now we do strcpy into p2 and we copy 1 2 so we're going to copy 3 bytes","width":312},{"text":"we're going to copy the 1, the 2, and a NULL byte","width":481},{"text":"so when we try to print this out, we're going to print a12 and then stop because we get to the NULL byte","width":900},{"text":"alright, oh I've got a few minutes, we'll be okay. alright, what about the next one? is the following code valid? what have I got?","width":733},{"text":"so I've got a pointer a and it's going to point to xyz","width":285},{"text":"I'm not copying it","width":96},{"text":"so think about this for a moment. when you load your program in, and it starts running this process, at the bottom of the memory that we've got, we've got the code!","width":762},{"text":"and then we have our constants","width":428},{"text":"okay so a is pointing to some memory inside this constant. the stuff that we've loaded off disk. the xyz. those bytes. a is looking at that address in there","width":769},{"text":"and then we say \"I've got a pointer to a pointer to a character\"","width":213},{"text":"in fact we read this backwards, so b is a pointer to a character pointer","width":319},{"text":"and it holds the address of a","width":305},{"text":"so b hold the address of a. it holds the memory location of a.","width":498},{"text":"so I could use that, I could use b to change what a is pointing to, and that's what we do here","width":381},{"text":"so, why didn't what b is pointing to \"uvw\" ?","width":373},{"text":"so what have we done? we've changed a. so now a is pointing at a different location","width":409},{"text":"it's now looking at a different constant","width":225},{"text":"inside our memory","width":102},{"text":"so we didn't actually copy any strings. we're just changing pointers around","width":574},{"text":"right, we'll do this one. what's special about sizeof(char) ?","width":565},{"text":"it's defined to be 1.","width":133},{"text":"a character in C is always one byte","width":480},{"text":"yes, uh, oh yes yes, I'm sorry I forgot to, yes, there is one bug in here. which is, we should've returned result","width":1072},{"text":"not p","width":368},{"text":"okay, last two things: printf puts putchar and all those other C macros end up calling write() on stdout","width":535},{"text":"which is 1","width":172},{"text":"and the final question for today: what will the following code print?","width":450},{"text":"we malloc 128 bytes. if it failed, if it gave us NULL, we just exit","width":323},{"text":"so lets assume it didn't fail, and then we do puts","width":162},{"text":"what will it print?","width":432},{"text":"okay, so we can answer this and say \"here's the most likely thing it might do\"","width":235},{"text":"it's the very first byte of this might be zero","width":232},{"text":"so, that's just an empty string","width":192},{"text":"so, all that's going to happen is that it'll try to print an empty string. what does puts do? it prints out the string followed by a new line","width":355},{"text":"so that's probably the most likely thing to happen","width":136},{"text":"however, does malloc zero bytes for us?","width":334},{"text":"no! that could be anything in those bytes. it could print \"I love [insert your worst football team in here]\"","width":665},{"text":"whatever! it could print anything! it could print out more than 128 bytes","width":486},{"text":"it could print \"I am agent smith\"","width":185},{"text":"arbitrarily, what is in those bytes. and with that, have a wonderful week! and I'll see you on wednesday!","width":576}],

  //Start Lecture Video 4
  // Part 0
  [{"text":"alright, good morning class, how are you?","width":4527},{"text":"oh! good! great! how's everyone else?","width":275},{"text":"okay....fine...ehhh...middle of the week blah blah","width":198},{"text":"okay so here we go. in blehh","width":307},{"text":"try again","width":35},{"text":"so, in the next fifty minutes here's what we're gonna do: we're gonna make sure you have a good understanding of fork exec wait, we're gonna look at a couple examples. we're gonna start about some common gotchas","width":732},{"text":"and a reminder that some interesting things are due for tomorrow's section!","width":354},{"text":"so, you might say well hold on a minute, this week's section makes me jump into the deep end with android and commit somehow to subversion. no explicit instructions. yeah, welcome to the real world","width":892},{"text":"or at least, welcome to a simulation of the real world","width":195},{"text":"as we kind of say goodbye to CS125 CS225 ecetera, we lose the training wheels a bit","width":552},{"text":"so yes, we will give you more explicit instructions in the future, don't panic quite so much. I just wanted to give you an experience of saying \"look, this is what its like\"","width":518},{"text":"yeah! It's evil it's tough. instructions are never as clear as you'd like them to be and something strange happens. people start looking at you as if you were the expert in the room","width":641},{"text":"just because you know a little bit more about say the other people working","width":227},{"text":"just because you've taken the time to say read the man pages or do twice as many google searches","width":357},{"text":"or just figure out the best way to work it","width":208},{"text":"and yes, in setting up things like android, it doesn't work first time","width":250},{"text":"so now, you need to be a hacker in that sense. of saying, what can I change? what can I break, what can I unbreak?","width":400},{"text":"perhaps I should try a different device. perhaps I should try plugging it in again. perhaps I should try turning off and on again, right?","width":342},{"text":"perhaps I should learn about uh, trying to, I've got a problem say it doesn't connect to android well. is it my device driver? how have I not set thing up correctly?","width":565},{"text":"perhaps I should I reread the instructions to see if I missed a step","width":225},{"text":"these little basic skills a software engineer has to have","width":389},{"text":"so, one one key skill that I hope you get out of this week's setting up the section is tenacity","width":621},{"text":"damnite you can be more stubborn than it","width":250},{"text":"that you can figure out ways to try and break down the problem. maybe I should try someone else's tablet. maybe someone else should try my tablet.","width":420},{"text":"maybe I should umm, uhh, do an experiment to see if something at the low level of the USB is noticing if the tablet is connected","width":495},{"text":"that kind of thing. maybe I should check to see if it's using the right version of java. etcetera etcetera etcetera.","width":360},{"text":"try to take a problem and breaking it down and using your brain cells to try to make progress.","width":372},{"text":"I didn't say it was going to be easy, yeah, welcome to the real life.","width":219},{"text":"okay, well, welcome to real life","width":105},{"text":"right, so, enough! let's put that aside. the next thing you'll need for section is to make \"make\"","width":490},{"text":"or as we fall it, \"fake\", alright","width":166},{"text":"so, why?","width":81},{"text":"because make allows us to build larger programs and at the end of the day, guess what? it's just a C program","width":450},{"text":"it reads in a set of commands to execute...and executes them!","width":312},{"text":"except it tries to do it with some sophistication","width":216},{"text":"so rather than, for example, compiling all possible programs, why don't we compile the ones which have already recently been edited?","width":574},{"text":"or let's make it so that we can make a debug version and a release version","width":247},{"text":"or let's make it so that it works not just for C programs, but with python. you can even use \"make\" by the way, to generate thumbnails of images","width":522},{"text":"so next time you change an image, you can automatically generate thumbnails","width":271},{"text":"I used it in the videos because when I exported each of the little 7 minute videos as an mp4 file, I wanted to have an old version, I wanted to have a webm version, the basic 3 formats of video on html 5 these days","width":995},{"text":"and so I used \"make\". any time I made a new version of the, uh, I, anytime I exported a new mp4 file, I produced make to say \"oh! look! this source file (my mp4) is newer than the targets (or the targets don't exist)\"","width":1087},{"text":"then I get make to run a transcoding program to generate the other versions","width":330},{"text":"so make is very powerful","width":88},{"text":"and you can also set it up to do things in parallel which is fantastic if you happen to have, say, 8 cores, or 200 cores","width":541},{"text":"you can make things go much faster","width":191},{"text":"alright so, let's turn our attention to some code here. we're playing with fork() and we've got it set up so that after fork returns, I'm going to get the parent and the child to do completely different things","width":1342},{"text":"I put them into two different functions","width":198},{"text":"so, remember, after fork returns, so let's write our little fork here","width":315},{"text":"you've now got two processes, you're writing code for two separate processes, isn't that cool?","width":386},{"text":"they happen to share a common ancestry so all of their variables currently have the same values for example (apart from the return value of fork)","width":609},{"text":"so, now we make them kind of have different futures. different histories.","width":422},{"text":"okay so, that's the kind of first important thing, first importantly to remember is that you're writing code once, but it's going to go for multiple processes.","width":748},{"text":"it just so happens that we can use return value of fork() to do two different things. okay so, I checked so that the value is greater than 0","width":562},{"text":"if it is, then I must be the parent","width":196},{"text":"if it's zero, then I must be the child","width":203},{"text":"so let's run to the code. there's actually one other case. fork() could fail. if it does, what's it return?","width":524},{"text":"negative one, yes","width":88},{"text":"so, we should print an error to say \"hey, fork failed\"","width":324},{"text":"what's the easiest way to do that?","width":287},{"text":"just use perror() !","width":267},{"text":"so print perror prints out whatever you said, followed by a colon, followed by a completely cryptic error message which is completely useless to users but hopefully gives you a little idea about at what point your program failed.","width":967},{"text":"so as you start to write more complicated programs, it becomes important to check for the return values. and in fact it's quite usual (just read the man page) to discover that it returns, say, zero, or more likely negative one","width":821},{"text":"if things fail","width":84},{"text":"so when writing more programs, when it doesn't work, say \"oh okay! when did it stop working?\"","width":406},{"text":"maybe I should actually check return values and discover when it broke","width":252}],
  // Part 1
  [{"text":"ok, so that's the beginning of my program. I've made some gaps in here","width":319},{"text":"and so perhaps you and your neighbor could fill in the necessary code on this program","width":595},{"text":"and figure out what we should write for the child and the parent","width":20311},{"text":"in the child process we want to ask for an alarm signal please","width":408},{"text":"so we can say alarm() one, which means in one second or so the operating system will deliver, will send a SIGALARM to that particular process","width":807},{"text":"and once the - what happens by default when you send a SIGALARM to a process?","width":514},{"text":"it kills it, right! that's a pretty evil alarm signal, yes?","width":329},{"text":"but that's what the default behavior does","width":136},{"text":"we could stop that if we wanted by registering a sig handler, but today we're not going to do that. instead we're merely going to sleep for two seconds","width":701},{"text":"after we sleep for two seconds we're going to print something out and then we want to exit normally","width":234},{"text":"how do I do that? i just say exit() and let's give a return value like 0","width":429},{"text":"so my child process is pretty simple","width":175},{"text":"now the parent is going to wait for the child to finish","width":311},{"text":"how do we do that?","width":112},{"text":"we can call waitpid() pass in the process id of the child","width":479},{"text":"we'd like to collect some information so status and we don't need any flags today","width":240},{"text":"ok, so how do we decide if the child has exited normally or not?","width":499},{"text":"well let's do that one, so that one was - what WIFEXIT or EXITED, I'll have to look it up in amoment","width":619},{"text":"and now we need the exit status so let's find out what it said","width":585}],
  // Part 2
  [{"text":"ok, we can also discover if the child exited due to a signal, so let's do that as well","width":562},{"text":"so let's say 'look if WIFSIGNALED then let's find out what singal it was","width":631},{"text":"okay so how do I pull out that? I think it's WSIGTERM? -TERMSIG, ah. ok","width":772},{"text":"and we can print out a helpful message right because not everyone knows those numbers so what is the number for SIGALARM? it's just this constant here SIGALARM","width":861},{"text":"right, shall we run this? let's try it. see what errors we have here","width":442},{"text":"ok, what have I messed up. SIGALARM, argh, right, let's try that","width":1147},{"text":"ok, where's the mistake? line two","width":1285},{"text":"hooray! ok, so it prints 'Hello World', starts up and then the parent says 'child exited due to signal 14 alarm clock'","width":515},{"text":"let's make another program over here that - let's see, I'll tell you what I'll have a pointer","width":802},{"text":"there we go, and it can be a random number","width":346},{"text":"just cast that into an integer pointer and into p we will write the value 42","width":651},{"text":"will it crash? who knows what it'll do","width":161},{"text":"ok, so this time we go 'child exited due to signal 11' what's signal 11? well ok it's not going to get you invited to any parties","width":474},{"text":"but it's turns out signal 11 happens to be segfault","width":303},{"text":"so, we could keep going with this and say 'look if the thing was' - I'll just write it - 11. I could spend some time - \"oops, seg fault - write a better a program!\"","width":1556},{"text":"so you see those messages like segmentation fault and an error that commonly comes up that says 'segfault write a better program'","width":384},{"text":"right, so, you see those messages like alarm clock, segmentation fault, that kind of stuff. they dont' just appear in the terminal by magic, no!","width":414},{"text":"the shell is doing what we're doing here and that's what your fake program is going to do as well. that after a command finishes use these macros to discover what happened to your child and print out the relevant information","width":1168},{"text":"so, questions about that?","width":412},{"text":"alright, so, now you actually have enough knowledge to write not only make, but a shell","width":511},{"text":"and we're going to have an MP based on that where we can take just user input, what you type onto a keyboard and then start executing programs","width":784},{"text":"so the shell that we normally see is either bash or a simpler version called just sh, but it's just a C program that reads input and then calls exec()","width":663},{"text":"based on what you typed","width":289},{"text":"ok, other questions about this?","width":278},{"text":"alright then, let's have a look at some other questions on here","width":321},{"text":"so, when I start my program and I want to find out what arguments it was given. so for example, suppose someone did this","width":917},{"text":"how would I actually discover the first argument? ","width":792},{"text":"it would be in argv[1]","width":313},{"text":"so what would we expect to see in argv[0]?","width":1301},{"text":"argc","width":592},{"text":"it's ./program and i'll make this the right size","width":380},{"text":"it's just the name of the actual program itself","width":651},{"text":"and let me show you actually how - yes? uh huh. yes. what? yes.","width":1921},{"text":"so a segfault happens because for example your program tries to write into some memory location that it's not allowed to","width":647},{"text":"and this generates a hardware interrupt by the memory controller to say 'ahaha, you are trying to write into say a kernel address space or into a page of memory that doesn't exist. this doesn't look good to me'","width":860},{"text":"at that point the kernel says 'this process is not behaving well, I'm going to shut it down. you never get the CPU again' and so the process is pulled away form the CPU, it's not allowed to execute anymore of your assemlby, anymore of the satemetns","width":1119},{"text":"and instead the kernel makes a note of the fact that this is a bad process. we killed it due to a segfault. yes?","width":785},{"text":"yes. ","width":237},{"text":"the alarm can go off during sleep","width":212},{"text":"all the sleep says is don't allow this process access to the CPU for about two seconds","width":496},{"text":"there are actually some possibilites where it might come back early or - there's no guarantee it will be exactly two seconds","width":395},{"text":"we're not playing here with perfect real time operating system. it's to the best it can do give whatever load the system's under","width":537}],
  // Part 3
  [{"text":"and we'll talk about scheduling later on in the course","width":249},{"text":"okay so, just a quick little bit a fun here","width":258},{"text":"let's have a look at /usr","width":192},{"text":"sorry, /usr/bin","width":167},{"text":"alright, whole load of programs","width":256},{"text":"but I want to show you something slightly surprising about these programs, umm","width":585},{"text":"they're actually, they're all fakes","width":285},{"text":"the programs like who which ls, etcetera, they're all just pointers. they all point to something called \"busy box\"","width":581},{"text":"so, the busy box program is written so to support all these different commands","width":492},{"text":"and the first thing it does when it starts up is it says \"what am I running as?\"","width":239},{"text":"am I running as ls? am I running as wc? or some other command?","width":297},{"text":"in which case execute different code","width":238},{"text":"and so you'll see this in this little example here. you'll see in router boxes. you'll see it in your android phone, because it's a way to include a lot of commands without requiring lots of large programs","width":819},{"text":"all tend to do kind of similar things","width":134},{"text":"so it's a way to save some memory","width":158},{"text":"alright, so that's one use of argv[0]","width":496},{"text":"alright, what's special about argv and argc?","width":302},{"text":"it's a NULL pointer!","width":472},{"text":"so, next time you want to scan through all of the arguments, either just use argc to find out how many are there, or just have a little loop that keeps incrementing through those pointers and when you get to NULL, you know you've got to the end","width":1003},{"text":"so typically, if this is the array, you're gonna ignore the first one because that's not a real argument","width":492},{"text":"you know the first one is the actual arguments it was sent so in this case it would be kind of \"file.txt\"","width":581},{"text":"and then we'll have some other arguments that the user might have supplied, and the last one will be NULL. won't point to anything","width":501},{"text":"so don't try to strcat that, for example, don't try to read from that location or you'll get a segfault","width":759},{"text":"okay, let's do page 2!","width":1213},{"text":"so why do shells exist?","width":451},{"text":"could we have an operating system without a shell?","width":265},{"text":"yes we could. but it would be hard to type stuff in.","width":220},{"text":"right it would be hard to execute anything and it would be hard to call things because before you could call things on the operating system, you'd have to write a C code and compile that in order to call the system calls.","width":992},{"text":"but what I want to impress upon you is that all of the commands that we might call from our shell, are really just more C programs","width":740},{"text":"well, they don't have to be C, but for the system programming stuff, they tend to be and some of those can be, tend to be, very very small","width":402},{"text":"so for example, you might stat that we'll see later to find out something about a file","width":438},{"text":"let me go back to my home directory okay, stat program","width":355},{"text":"and this tells me some basic information about a particular file on disk. when it was last modified. who owns it. where it is. what kind of file it is. etcetera. but guess what. this little program just makes use of system calls","width":1123},{"text":"and if I was to call, find out the manual of stat, uh, you discover that on section 2, there's a call called \"stat\" where I can pass in the name and pass in a pointer to a buffer to get all that information out","width":1250},{"text":"so that stat program, fundamentally just makes this call and then has a couple of printfs in order to format the information inside the buffer","width":863},{"text":"so, the shell exists in order for us to basically make, uhh, to be able to do things efficiently without having to continually create new programs","width":878},{"text":"so how would we get our shell to print \"segfault\" or \"alarm clock\" ? easy!","width":553},{"text":"see page 1","width":89},{"text":"hello let's flip back over we've just done it! alright, call waitpid, find out how the process finished, and then take an appropriate action like \"hey! your child process just quit due to a segfault\" or just quit due to an alarm message","width":1201},{"text":"or just died because uhh, you pressed Ctrl-C and we sent a SIGINT to a process","width":446},{"text":"you can do that. now, just using a fork and exec","width":307},{"text":"alright then, so, here is an attempt of implementing a shell","width":507},{"text":"it's called the lol cat's shell","width":306},{"text":"and but there's a couple things wrong with it","width":211},{"text":"perhaps you could figure out why this is not a good shell. how many errors can you see in this code?","width":392},{"text":"[long pause]","width":7872}],
  // Part 4
  [{"text":"","width":3856},{"text":"alright, so this is an attempt to write a shell","width":145},{"text":"it's attempting to get the users input one line at a time and then call exec() based on what the user entered","width":547},{"text":"the first thing you might conclude is that you need to fire this programmer and get a better one","width":305},{"text":"but let's see if we do better that. let's see if we can actually identify a few specific mistakes here","width":514},{"text":"let's see, does it even run?","width":540},{"text":"ok, so no we at least need to semicolon there","width":1137},{"text":"alright fine good so enter your command and I will exec it. ok, great we've got a shell lets try it! we'll try ls","width":736},{"text":"try cat","width":219},{"text":"ok, this is not a particularly useful shell yet","width":278},{"text":"how can we make it better? for starters let's print out an error message here saying exec() failed","width":947},{"text":"and see if we can figure out what's broken with this","width":341},{"text":"OK, ls. no such file or directory. what? well try /bin/ls. no such file - oops, come back","width":761},{"text":"now it's just sulking. it always prints no such file or directory","width":442},{"text":"what did we do wrong?","width":602},{"text":"OK, so here's a couple points from this. as you know the first argument should be the program name","width":426},{"text":"so let's change args[0] to point to the buffer","width":547},{"text":"what is args? it's an array of character pointers","width":325},{"text":"so we can change the entrance of that array. we're just changing the addresses held inside that array","width":365},{"text":"it's a very simple shell right now and it's just set up to be an array, a very simple array","width":285},{"text":"it's just set up to have two entries","width":129},{"text":"the first one initially points to a character string and then second one is null","width":282},{"text":"we want to change it to it at least points to the buffer. and we'll try this","width":506},{"text":"ok, right, ls","width":142},{"text":"no such file - ah - ok /bin/ls","width":184},{"text":"no such file or directory","width":319},{"text":"Darn <rand chars> still not working, but like what I said, part of being a systems programmer is to be tenacious","width":588},{"text":"your code is no longer the most complicated thing in the room","width":309},{"text":"and if you don't get things right it will bite you","width":167},{"text":"hopefully it will bite you sooner rather than later","width":173},{"text":"then we have a chance of fixing it","width":243},{"text":"maybe we should test our assumptions","width":324},{"text":"like what are we actually sending to execvp()","width":289},{"text":"for example let's actually have a look at the buffer","width":528},{"text":"alright, so let's run something we know exists","width":239},{"text":"look it's printing it out","width":126},{"text":"certainly we're sending it the right thing","width":956},{"text":"I'll even get rid of the fgets()","width":254},{"text":"whoops we've got an error. oh yeah I'm sorry it's an array so I have to strcpy() into the buffer","width":1292},{"text":"and that worked","width":387},{"text":"what is our error? if you think you know tell our neighbor","width":918},{"text":"ok, so here's our mistake. fgets() yes does read everything from the user including the new line","width":503},{"text":"and if I was to put a new line into here we would see the same thing and exec is very simple, it's looking for a program called ls with a new line that's part of it's name","width":766},{"text":"so this would now fail","width":194},{"text":"so what we need to do now is get rid of that new line","width":249},{"text":"okay how can we do that ","width":157},{"text":"well let's find out how many characters that we got into our buffer","width":347},{"text":"we'll assume for now that fgets() worked","width":497},{"text":"it may not, for example if someone closed standard in on us it would return null","width":274},{"text":"so we should do that when we want to write better programs","width":165},{"text":"right, so let's find out the number of characters in now the buffer","width":394},{"text":"how does it do that? it needs to walk along until it finds the 0 byte","width":320},{"text":"so for example we know that buffer[len] is the null byte","width":632},{"text":"yes?","width":236},{"text":"so we actually want to go back one byte","width":662},{"text":"and write in 0 or \\0 the null character","width":541},{"text":"will this work? let's try it ","width":566}],
  // Part 5
  [{"text":"/bin/ls hurray! finally we've got a basic shell that takes a single command","width":618},{"text":"we can't give it any arguments yet but we can execute it","width":233},{"text":"and woah hold on a moment, it stopped!","width":276},{"text":"what happened to my while loop?","width":424},{"text":"perhaps your neighbor knows why it didn't work?","width":258},{"text":"[silence]","width":2556},{"text":"okay we have another problem as well, in our assignment in running about that while loop, we've just written code which is actually kind of dangerous","width":581},{"text":"we made a assumption that the newline is always going to be there","width":363},{"text":"is that true?","width":329},{"text":"so it could appear to be true if we're testing it","width":199},{"text":"but it could be that someone is sending us data from a file and fgets simply returns because there is nothing left to read","width":595},{"text":"so a safer program might check to see what we're actually replacing","width":307},{"text":"so for example, it only make sense to do this if len is at least zero","width":311},{"text":"and the buffer[len - 1] is what we expect, a new line character","width":1284},{"text":"okay so we've now got a safer program, it still works, but our while loop never happens, why?","width":683},{"text":"yes thank you, our little process has had a mind wipe ","width":346},{"text":"its assembly language has disappeared, it's variables have disappeared","width":368},{"text":"basically everything we might have put inside the processes' memory is gone","width":271},{"text":"to be replaced by the code associated with our program ls","width":554},{"text":"so how do we make a shell? how do we make it so that it can execute more things","width":299},{"text":"fork exec, yes! so our plan is to do this","width":320},{"text":"in the child and in the parent we want to play our standard waitpid and then the exited stuff so that we can print out useful messages when our programs finish","width":938},{"text":"and that is the basis of the mp","width":544},{"text":"alright so we're well on our way to having a working shell","width":448},{"text":"in real shells, you can execute things in the background, how do we do this?","width":631},{"text":"don't call waitpid, just in your shell go around again","width":462},{"text":"go back to your line that reads input, either fgets or readline ","width":315},{"text":"and let that child process carry on","width":406},{"text":"how do we make it so that we can read from a file?","width":284},{"text":"well we've got two possible ways to do that","width":169},{"text":"you could use say fopen or if you want to go low level, you could use open","width":480},{"text":"and then when you call fgets you can pass in the file descriptor you get from fopen and you would read from that file descriptor","width":1072},{"text":"there is another way as well, which is to close standard in so you would say hey close zero","width":529},{"text":"and then call open","width":305},{"text":"and pass in the right arguments to read from a file","width":648},{"text":"and we need to read the manpage of open to look at how we can open a file readonly for example","width":496},{"text":"and when we do that, future reads at the C level will be reading from this source file","width":528},{"text":"how about this? suppose I want to execute file.c inside a child","width":488},{"text":"but now I want to redirect the output of this command to a different file","width":516},{"text":"how would I do that?","width":571},{"text":"so how do, ah right, so I'm not going to try and change cat, this is just a command, I want my shell to do this part","width":353},{"text":"I want my shell so that the output goes to a different output","width":661},{"text":"okay and where would I do that?","width":263},{"text":"here's a suggestion: you could after the fork, inside the child code, the child could close one, use open and then call exec","width":1592},{"text":"we saw an example of this in a previous lecture where we made our program send the output of ls I believe to a log file","width":610},{"text":"so all we've really done is taken that idea and put it inside the code that we're writing for the child process","width":677},{"text":"and we've put it inside the child because our parent is going to go around that loop and execute other commands","width":390},{"text":"and we don't want everything to end up inside that log file, inside say output.txt, we only want the child to execute that code","width":852}],
  // Part 6
  [{"text":"what's POSIX?","width":485},{"text":"does anyone know what it stands for?","width":238},{"text":"ok, so, a long time ago back in the '80s the standards committees of IEEE were trying to formalize a standard set of interfaces for an operating system","width":801},{"text":"or what operating systems should support","width":158},{"text":"and it went by an IEEE number which was hard to remember so at some point, i think it was Stormunds said why don't we call it the Portable Operating System Interface, or POSIX for short","width":815},{"text":"so POSIX is just a set of standards","width":264},{"text":"and what do those standards talk about?","width":105},{"text":"well they talk about system of interfaces to the actual operating system","width":544},{"text":"in others words what system calls can I make to control the operating system or request things from the operating sytem","width":464},{"text":"and also it's a set of utilites that you expect to exist","width":345},{"text":"so for example, there should be ls in order to list files or cd in order to change directory","width":582},{"text":"and also it describes what you can expect on the platform","width":254},{"text":"like I can expect to work with files,I can expect to work with the network","width":258},{"text":"so a POSIX operating system provides an abstraction of the low level hardware","width":590},{"text":"I don't need to worry about the exact way to communicate with a flash drive","width":434},{"text":"I can simply say 'oh look well let's assume theres a file system on here' and I want to be able to read or write files to this","width":434},{"text":"and the operating system provides a lot of support for those different pieces of hardware","width":479},{"text":"it also provides security. so what kind of security does an operating system give you?","width":946},{"text":"does it give you a warm blanket and a teddy bear at night? no","width":337},{"text":"so what do we mean by security?","width":115},{"text":"if you were to design an operating system today, right now, what security features would you have?","width":473},{"text":"make it memory safe, what do you mean by that? why?","width":637},{"text":"ok, so what you're saying is you don't trust his programs?","width":370},{"text":"I'm sorry, yeah it's a fact of life. what we want to try to do is provide some insulation between different user programs","width":505},{"text":" so that a malfunctioning program I'm sure you write fantastic code most of the time, but let's say a malfunctioning user program cannot bring down the rest of the system","width":801},{"text":"ok, so how are we going to do that? well one thing you've already seen is memory protection","width":586},{"text":"and if I read up on operating systems give us virtual memory","width":300},{"text":"so each little process runs inside it's own padded shell","width":368},{"text":"sorry padded inside its own padded room","width":168},{"text":"it thinks it can read or write any possible memory address it can think of","width":319},{"text":"of course if it tries to do that","width":151},{"text":"it might crash and we might just kill the process","width":255},{"text":"by the first flush one process cannot actually access another process","width":334},{"text":"they live in completely different universes so they are living in dfiferent virtual memory spaces","width":450},{"text":"ok, what else?","width":307},{"text":"yes? file permissions","width":452},{"text":"yes, so I can make it so you can't delete my file or append to my file","width":273},{"text":"but I will let you read it","width":112},{"text":"or I can make it so that my file is unreadable by anybody that's not inside a certain group","width":514},{"text":"interrupts, what about interrupts?","width":472},{"text":"ok, interrupts - i'm going to talk about processes because I thought that's where you were going to go","width":349},{"text":"that you can't kill my process","width":269},{"text":"you can't just call kill -9 on my processs","width":185},{"text":"so you can only kill processes which you own","width":187},{"text":"unless you happen to be root or super user in which case you can kill any process you want on your system","width":466},{"text":"so, yes, security in terms of process control","width":235},{"text":"the last thing here is scheduling","width":95},{"text":"try to have some fairness","width":426},{"text":"which is an open ended and debated term, but imagine your process tries to take the CPU 100% of the time and never gives it up. just has a while loop","width":729},{"text":"if we were not careful no one else would have access to the CPU, it wouldn't get any work done","width":548},{"text":"so the last thing we'll say in the closing part of lecture","width":145},{"text":"is yes there is a quiz on friday and here's going to be our next topic - how do we allocate memory on the heap","width":585},{"text":"and I will talk about this in a future lecture on monday","width":312},{"text":"alright, great, see you friday, be ready for the quiz","width":326},{"text":"thank you very much, have a good section tomorrow","width":236}],

  //Start Lecture Video 5
  // Part 0
  [{"text":"Okay, good morning class, how are you?  Fantastic, right!  So here's what we're going to start doing now, we're going to start talking about memory.","width":1536},{"text":"You could imagine if we went back into the early, early hours of computing, we had it easy, right?  Well, there's proper instructions here, and we'll use location 100 to mean this and 112 to mean that, and we won't have to worry about dynamic memory allocation; we'll just make all those decisions upfront as we actually design the program.","width":1728},{"text":"Then later, we say, \"Well actually, we want to have functions.\"  And later, we want to have functions that can call themselves and be able to recurse.  So, for that we need a stack.","width":768},{"text":"And for that, then, as we make function calls, our stack pointer needs to move.  And inside the stack we'll store our temporary variables and also our point where the CPU should go back to when it returns from the function.","width":896},{"text":"So our stack... we'll start a lot higher up in memory and as we make more recursive calls our stack will get larger and larger and larger and larger, of course - until we run out of memory.  And then we said, \"Well actually, we don't want to decide what memory we'll need upfront either, we want to be able to have dynamic memory allocation, and we don't know when we're going to free up that memory.  We don't know when we've finished with it.  We want to make that completely dynamic and it's part of our program.","width":2176},{"text":"And thus, the idea of the heap was born.","width":192},{"text":"The idea that at any point, we can say, \"Oh!  I need more memory!  And give it to me now and this is how much I want and I'm not going to tell you when I'll be finished with it.\"","width":704},{"text":"So it's very different from the stack memory.  Stack memory: you know you'll be finished with that memory when you return from the function.","width":512},{"text":"So with stack memory, you've got automatic variables.  They automatically disappear - no more work...","width":448},{"text":"With the heap, of course, now we actually have to say, \"Okay, give me the memory\" and \"I'm finished with it.\"","width":320},{"text":"So you've used the heap of course in Java and in C++ when you said 'new' and 'delete' in C++.  Typically, they go on the heap memory.","width":704},{"text":"I say 'typically' because C++ can do some amazing optimizations when you're not looking the compiler will quickly say, \"Hey!  You didn't need to write that!\"","width":576},{"text":"\"Here!  I'll optimize your code, so that actually there's no code written at all.\"","width":256},{"text":"When you write new/delete you explicitly create, well, we'll just simplify it and say \"Yes!\"  We're making things on the heap.  So we need some memory, so let's call malloc().","width":704},{"text":"So malloc() is part of the C-library.  It's part of your process.  It decides where your memory's going to be.","width":640},{"text":"If you like, it says, \"Oh look!  Table of four.  Right, I need  four seats.  You can sit over here.  This table over here is free.  You sit over here.  Oh, you've finished with that table?  Oh, great!  Get out of there because I'm going to reuse this table for something else.\"","width":832},{"text":"Alright, so malloc() has to very quickly decide where it can assign you some memory.","width":448},{"text":"It gets harder because we don't know in which order our memory is going to be allocated, and in which order memory is going to be freed.","width":960},{"text":"And even if you knew that order, it's an NP hard problem to do it well.","width":576},{"text":"Called the Knapsack Problem.","width":256},{"text":"So even if you knew exactly which order the malloc()s and free()s were going to come in, how would you do it efficiently is a non-trivial problem.","width":576},{"text":"That sounds computationally expensive, right?  If we made our malloc() perfect, it's going to take a long time.  \"Yeah, I could put this table of two here, but you know what there's a big order coming in in a moment and so I don't actually want to put them there I want to put them over there.\"  There's an infinite number of possible ways that we could arrange things in memory.","width":1280},{"text":"So malloc() has to be efficient but fast.","width":320},{"text":"So this is the basic game we have to play.","width":320},{"text":"*picture problems*","width":1280},{"text":"Don't write this down, this is just a visual.  You don't need to copy this down.","width":384},{"text":"Here's how it works: let's suppose our process has some memory to play with.","width":512},{"text":"You promise me you're not writing this down?  Good.","width":256},{"text":"So my little blocks here indicate 1 kilobyte blocks.","width":320},{"text":"And during the execution of my program it says, \"Well, I'm gonna make a linked list or I'm gonna make an image, and I need some memory.\"  So part of your code says, \"I need say 2 KB.\"","width":1152},{"text":"So malloc() now has to look through the memory and say, \"I tell you what, I'll give you these two blocks here.\"","width":384},{"text":"If anyone else calls malloc() I promise not to return any pointers that point to this memory in here.","width":576},{"text":"So malloc() is going to return the address of the first few bytes and internally it has to do some book-keeping.  It has to make a note that these first 2 KB are being used.","width":640},{"text":"And then your program decides to malloc() some more memory.  So it says, \"Okay, I'll have 2KB now please.\"  What should malloc() do now?","width":832},{"text":"Well, it can't use this area of memory.  It has a choice: it could put it here and here.  It's not going to allocate here and here, though.","width":1280},{"text":"Why does it not say, \"I'll give you some memory there and there\"?","width":576},{"text":"We've fragmented the memory, but also when malloc() returns a pointer, your assumption is that all the bytes you've been given are contiguous.  You might want to use it as just a simple array, for example.","width":1152},{"text":"So we've got a problem here.  We have to allocate memory that is in the same area so let's say we put these little x's in here.  And then of course someone says, \"malloc(2 KB)\".  What happens now?","width":1408},{"text":"We can't!  We don't have enough spare memory.","width":320}],
  // Part 1
  [{"text":"Now if this was a very small... two things could happen: our program could just crash - malloc() could just give a bad answer.  But we want to be a bit more systematic than that.  So at this point we'll go back to the operating system and say, \"Hey!  You know that memory stuff that's really valuable?  Give me some more, I need some more.\"  So actually malloc() at that point has to go back to the operating system and say, \"Hey, you know that memory you gave me?  I've run out.\"","width":1984},{"text":"I need some more.  I need more memory.  So malloc() can get some more memory from the operating system.","width":704},{"text":"How does it do that?  Well, classically it would call something like sbrk().","width":640},{"text":"What is sbrk()?  You can write this bit down if you want to.  Let's jump into the rabbit hole for a moment and think about our process where we've got all these memory addresses to play with.  ","width":1280},{"text":"So what do we find inside memory?  We've got our code, we've got our global variables or the static variables... up here we've got the environment and the stack...where's our heap live?","width":2368},{"text":"Just here.  It starts off just here.","width":448},{"text":"So it can grow, right?  We can say, \"Excuse me, system.  I actually need some more space.\"  And that's what sbrk() does.","width":768},{"text":"It says, \"Look, you've got this watermark (this threshold) of what the maximum address is.  I want to bump it up, I want to play with some more room.\"","width":768},{"text":"So this means we could write a really, really simple memory allocator.  Here it is.","width":1152},{"text":"Any time the program asks for more memory (x bytes) all we will do is say to the system, \"Hey!  I need more bytes.  This is the number I need.\"","width":832},{"text":"And anytime the program decides it's finished with some bytes, what should we do?","width":832},{"text":"Nothing!","width":320},{"text":"That's the simplest memory allocator we could write.","width":320},{"text":"It's not a very good one, though.  We're not re-using any memory.","width":448},{"text":"Because we're not keeping track of which pieces of memory are actually being allocated.  We're just simply saying, \"Oh look!  I've got some more passengers on my boat, I need a bigger boat.\"  Or, \"I've got more people on my bus, I need a bigger bus.\"","width":832},{"text":"And not keeping track of how many seats are actually unoccupied.","width":320},{"text":"So it's really, really fast but completely inefficient.  We're very quickly going to exhaust all of our memory.","width":512},{"text":"And so this sets the stage now for our memory allocator.  We actually need to start keeping track of which bytes are currently being used and which bytes are available for suitable calls to malloc().","width":768},{"text":"So we only want to call this sbrk() thing when we truly are out of memory.  When we have no way to allocate any more memory.  ","width":832},{"text":"So the MP (which will be out maybe the end of the week or maybe next week) is actually going to ask you to write an efficient malloc().  And it fact it's going to be a competition.","width":1280},{"text":"So there'll be a page with results and you can see if your malloc() is faster than your neighbor's malloc().","width":704},{"text":"So remember when they step away from the keyboard to put a sleep() call into their code.","width":320},{"text":"Okay, so what's to stop you from doing this all the time?  Easy: the competition is actually going to put a hard limit on the amount of memory that you are allowed to play with.","width":896},{"text":"So now we have to start coping with the fact that memory's being freed.","width":512},{"text":"So if we are working with writing a good malloc(), let me show you a little problem that we might run into.","width":1984},{"text":"Here's some memory that's been allocated.  Here's some other memory that's been allocated at different times.  And then our program says, \"You know what?  I'd like 2 KB.\"","width":832},{"text":"Now you can see from my little diagram that I've actually got 3 KB of memory which are unused.","width":640},{"text":"But I cannot give you 2 KB.  I cannot find any space which is 2 KB because my spare space has all been fragmented.  It's no longer in a contiguous block.","width":1216},{"text":"So why can't I just take all the contents of this memory and just move it into there, and then carry on?","width":704},{"text":"Why can't I just move that?","width":256},{"text":"Why can't my malloc() just start shuffling stuff around?","width":384},{"text":"I can copy stuff!  My malloc() can copy it to there.  However, the rest of my process is using pointers.  It assumes that the stuff that's inside here is where it is so it assumes that if I've got a variable that's pointing to a linked list that it's using this area.  ","width":1536},{"text":"So all those pointers will be invalid.","width":256}],
  // Part 2
  [{"text":"So malloc() by itself cannot do that.","width":320},{"text":"Java does a little trick here, by the way.  What Java does is its pointers are actually pointers to pointers.","width":1088},{"text":"So remember when you had a pointer to something, like an object pointer?  And next time someone says, \"But there are no pointers in Java!\"  And then you say to them, \"Well why does Java have a 'null pointer exception?\"","width":1088},{"text":"So how does this work internally?","width":384},{"text":"This pointer points to a pointer which points to the actual memory that Java's using.","width":704},{"text":"Why does Java do that?  So that it can shuffle things around.  So that it can deal with this fragmentation problem.","width":640},{"text":"So here's what we're trying to solve here is fragmentation.","width":512},{"text":"And the reason I mentioned this thing about Java is because when you are using the JNI, on the Android NDK, you are going to discover that you have to pin and release things.","width":1344},{"text":"As part of your C code.  And what you're doing is you're saying (to this intermediate pointer), \"Oh no no no, I've got a bunch of C code right now that is using this data, so you can't start moving these things around.  You can't shuffle this block of memory around right now because my C code is using it.\"","width":1600},{"text":"So Java uses a counting mechanism to note that C code is currently using these pointers and can't shuffle the memory contents.","width":832},{"text":"You'll discover this stuff when you start working on the Android NDK challenge.","width":384},{"text":"So our game then is to try to avoid this fragmentation.","width":576},{"text":"This fragmentation's bad, right?  Now we have memory that we can't use for large allocations.","width":384},{"text":"Our game is also to do this efficiently.","width":256},{"text":"Here's where we're gonna look at three little problems.","width":512},{"text":"So this is actually an exam question.  It's one of the easier exam questions.  And what we're gonna do is forget for a moment this whole stuff about sbrk() and going back to the system to get more memory.","width":1344},{"text":"We'll just say that we've got a heap initially of 13 KB.","width":320},{"text":"And we've got an order of calls.","width":640},{"text":"So as new calls come in, we can decide where to put them.  And here's three different placement strategies.","width":1088},{"text":"Best fit, worst fit, and first fit.","width":256},{"text":"And we'll see as we do this that they lead to different assignments, that our malloc() will decide to place these requests in different parts of memory and so we'll have different fragmentation so that if our program continued, we might discover that future large allocations are impossible.","width":1600},{"text":"So what do we need to know about this?","width":320},{"text":"First of all, if you've got a choice, you choose the earliest segment.","width":576},{"text":"So what that might mean is let's say with best fit, let's say I've got space here of 2 (which happens to be a perfect fit; in other words, I'm trying to find space for 2 K, then I would just choose the one with a smaller memory address.","width":1536},{"text":"Worst fit.  Oh, how contrary can you be?  The idea here is that if I've got a space which gives me the maximum amount of space after I've done the allocation, I'll use that.","width":1728},{"text":"Okay, so let's have a look at worst fit, where I've got a 2K space here and a 10K space there and I'm trying to allocate 2 KB.","width":832},{"text":"Worst fit would not put it in this spot here, it would break apart this 10 KB space and say, \"I'll tell you what: here's how we'll change.  I'll allocate my 2 KB there, giving me a remaining space of 8.\"","width":896},{"text":"What do you think first fit does?","width":512},{"text":"Pretty obvious, right, from it's name.  We're simply going to walk along our free spaces until we find the one which is sufficiently large, and use that.","width":832},{"text":"So if I'm looking for 2K, oh look!  There it is, I'll use that one.  If I'm looking for 3K, oh, it's not gonna work for me, I'll have to keep searching.","width":896},{"text":"So they're very obvious placement strategies (from their names).  Now, it's up to you to actually run them.","width":896},{"text":"So here's the actual order of calls to malloc() and free().  Where do the allocations end up?","width":320}],
  // Part 3
  [{"text":"There was a question about best fit.  Best fit will scan through, looking at all the possible holes.  Obviously we can ignore all the holes (or spaces) which are too small.","width":1024},{"text":"And it will use the space which is at least as large as the request, but hopefully no larger.  And if it so happens that there's two spaces that satisfy that search, then we use the one lowest in memory.","width":1344},{"text":"So, question?","width":128},{"text":"Anytime you've got a space, you do the allocation at the beginning of the space.","width":1472},{"text":"*nothing happens here*","width":4224},{"text":"*again nothing, class discussion, Angrave filling out sheet*","width":7296},{"text":"Okay, so.  Let's have a look at this.  So first fit: I've gotten as far as filling out A, B, and C and now I've called free() on B, and now I need to allocate another 3 KB.  Where could we put it?","width":896},{"text":"Well, we've got space here and we've got space at the end.  And we're trying to do best fit.  So best fit is going to put it in here because it's a perfect fit.  If I put it starting at 3K, I would've had a space of one left over, so that's not quite as good.","width":1088},{"text":"And then we free A, and we allocate one KB.  Where could we put this?  Well, there's only one place.  There's one big giant space over here.","width":960},{"text":"So we'll put E there.","width":320},{"text":"What happens in worst fit?","width":320},{"text":"Nothing changes at the beginning here.  C, C, C.  Okay, so.  Now we free() B.","width":1088},{"text":"And we allocate 3 KB.","width":192},{"text":"So: where's our choice?","width":256},{"text":"We could stick it here, or we could stick it at the end.  Which one is worst fit gonna use?","width":256},{"text":"B, ye!","width":192},{"text":"Because we have the largest space if we allocate it there.","width":256},{"text":"So let's put our D in here.","width":192},{"text":"And now we free() A.","width":448},{"text":"And we want to allocate one byte.  So what are our choices?  We've got a space of 3, space of 1, and space of 3.  Where's worst fit gonna put our final allocation?","width":768},{"text":"Yeah, it's a tie-up between the first few blocks here and the last few, so we'll put it just here.","width":320},{"text":"Okay, and first fit","width":192},{"text":"Okay, let's do this quick. ","width":320},{"text":"We'll do the D.  3KB.  First fit is the Scrappy-Doo of fits.  As soon as we find enough space, we'll stop.  And we've just cleared out our space of four so yes, we can put D in here.","width":1664},{"text":"And now we'd free A, and finally we allocate 1 KB.  So we run along our spaces - oh, look!  Here's our free one.  And we'll stick E in here.","width":704},{"text":"I'm sorry, yes, you're right.  We'll stick it just there.","width":576},{"text":"Okay, so this was a pretty trivial exercise.  But what I wanted to show you is the mechanics of these programs, and that they also lead to spaces in different places.  Also, there's a little thing that we did quite easily but you'll have to remember to do in code, which is: look at this, we had A and B, and at some point we freed up two allocations next to each other.  And so we had to go from thinking that this is a space of two and a space of four into think that this is just one big space of 6.  And if we didn't do that, then if somebody asked for a malloc() of 6, then your algorithm would say, \"I'm sorry, I don't have space to allocate 6B because counting will keep this as a space of 2 and a space of 4.\"","width":3840},{"text":"We could coalesce those two free areas together into a single block, and so that is a common gotcha when implementing malloc().","width":576},{"text":"That you have to look at the space beforehand and the space afterwards to see if you can coalesce them.","width":448}],
  // Part 4
  [{"text":"Right, um..","width":128},{"text":"No need to need to remember that until you actually write your own allocator","width":256},{"text":"Okay, so let's just think about some of the comparisons of these then","width":320},{"text":"So what we'll do first here: what's one of the advantages of first fit?","width":256},{"text":"It's fast! As soon as it finds some space, hey we're done! We don't need to do any more","width":576},{"text":"Okay, what's one of the advantages, say of best fit? Or any disadvantages?","width":640},{"text":"Okay, so, think it's least amount of fragmentation","width":576},{"text":"Because it's ideal!","width":960},{"text":"Okay, so that is uh, do we know that for sure?","width":256},{"text":"It appears to be from this example, right?","width":320},{"text":"But is it true? In all possible uses?","width":320},{"text":"What about disadvantages?","width":512},{"text":"It's slower than first fit","width":512},{"text":"Because we have to check all spaces","width":384},{"text":"Okay, let's do worst fit and I'll come back to this one","width":512},{"text":"Right, what about worst fit?","width":128},{"text":"Yes, it's slower than first fit again because now we have to go through","width":640},{"text":"Any advantages to it?","width":384},{"text":"Any other disadvantages to it?","width":128},{"text":"Let's think about what we're doing for a moment.","width":320},{"text":"So worst fit is always going to find the largest space and use that","width":384},{"text":"So that means in a longer-running program, if you've got a giant space, it's going to quickly be eaten up","width":320},{"text":"So with worst fit, what you find is that you end up with lots of kind of medium-sized spaces","width":448},{"text":"Yeah, we can always go back to the system and say, \"Hey, system, I need some more memory\"","width":704},{"text":"But what we're trying to do is see what our fragmentation looks like given the space we've got","width":320},{"text":"So, because we keep attacking the largest space, means that we don't have one large area should a giant allocation request come in","width":768},{"text":"Alright, now we've got these medium-sized holes, these medium-sized spaces, scattered all over our memory space","width":576},{"text":"So we cannot satisfy very large requests","width":320},{"text":"But we keep attacking that large block, right?","width":640},{"text":"I'm trying to think of a good analogy, but uhh","width":384},{"text":"You always can say, \"Oh look, I've got this really really big block at the end, I'll keep using that\"","width":256},{"text":"Now what we haven't talked about is think about the fact that our memory gets freed up as well, okay?","width":384},{"text":"So, this large block keeps getting attacked, and we end up with smaller, medium-sized blocks scattered through our memory if we run this process for long enough","width":640},{"text":"We're always attacking the largest space, we're always kind of nibbling bits off it","width":576},{"text":"So best fit seems to be, \"Hey, we're not going to get much fragmentation, we're always trying to find the perfect jigsaw puzzle\"","width":576},{"text":"The problem with, yeah?","width":192},{"text":"Yeah, yeah there are some interesting caching issues, yes","width":1856},{"text":"Okay, okay, okay, so the question's about, \"hold on, we've got virtual space, with virtual memory you can actually do some interesting mapping to real memory\"","width":1344},{"text":"Yes, that is true","width":192},{"text":"However, that mapping happens at four kilobyte chunks","width":192},{"text":"Um, so, we can't completely get away from our fragmentation issue","width":384},{"text":"So, yes, underneath this for the real memory, we can avoid some fragmentation","width":576},{"text":"Given that malloc actually has some space, you know it's got a low address and a high address, our question is how can we efficiently use this memory?","width":512},{"text":"Right, so, I want to address this least fragmentation thing","width":256},{"text":"It appears to be ideal. It can be, if you set up your simulation correctly, but when you, uh, run it under more realistic conditions, what tends to happen is you end up with lots and lots of tiny, tiny, tiny little holes. Or tiny pieces of spaces.","width":1024},{"text":"So you could imagine that you've got, say, a request comes in four 15 kilobytes and you happen to have a 16 kilobyte space free, so you'll use that","width":768},{"text":"Now you end up with this tiny 1 kilobyte unused space","width":320},{"text":"So, in practice, best fit tends to give you these tiny, tiny spaces which are difficult to reuse","width":640},{"text":"So, quite often, some variant of first fit actually turns out to be a pretty good choice","width":512},{"text":"What first fit tends to do is the size of the holes tends to vary as you walk further down your list of free spaces","width":576},{"text":"So, this is actually often a pretty good choice","width":192},{"text":"Okay, so that was placement strategies","width":448},{"text":"Let's talk about a few other things with memory","width":448},{"text":"So we talked about where it's stored in memory","width":320},{"text":"It's stored just above the code and the global variables","width":192},{"text":"And we can call sbrk to say, \"oh we need some more space\"","width":256},{"text":"So what then are the challenges of actually writing a good malloc?","width":384},{"text":"How are we going to keep track of which parts of our memory have been allocated and which parts are free?","width":512},{"text":"What would you use?","width":128},{"text":"If I said to you right now, \"Okay, start writing a malloc\", how would you keep track of","width":576},{"text":"Say again?","width":192},{"text":"An array of what?","width":128},{"text":"Okay","width":448},{"text":"A disjoint set of regions in memory, okay","width":576},{"text":"Okay, so here's what I'm going to ask you to start with is just a simple linked list","width":256},{"text":"We can start with just a linked list of what's been allocated","width":320},{"text":"And what's been freed","width":192}],
  // Part 5
  [{"text":"So if we go back to our picture that we were drawing","width":448},{"text":"To say 'Oh, look, this has been allocated, this has been freed, this has been allocated, this has been freed.'","width":704},{"text":"What we need is a way to say, 'Okay these are just entries inside a linked list.'","width":768},{"text":"And I can walk along these looking for blocks which are, say, large enough.  And then when I find a block (let's say I'm going to use this one), I need to update my data structure so that I've now got an entry to say 'Hey, this part has now been allocated, and'","width":1600},{"text":"'I've got some remaining space.'","width":128},{"text":"And we go back.  So we can choose to take a block out and turn it into some space and some remaining free space.'","width":1088},{"text":"Which of course if that's zero, you don't need to have this entry.","width":64},{"text":"When you call free someone's going to give you a pointer to one of these used areas.  ","width":1408},{"text":"And we have to go through our linked list then to update our counting - to say, 'Okay let's turn this now into some free area.'","width":640},{"text":"Remember how I gave a little advert about coalescing blocks?  Well, our work may not be done because you can imagine that, over here, I've got a free block, and on this side I've got a free block.","width":1344},{"text":"So I now need to update my counting on my linked list to say 'You know what this is now just one giant block if I've got it on both sides, a huge block of free space that can be reused.'","width":1024},{"text":"We could do this really, really inefficiently by having a linked list and then when someone says, 'Oooooh!  Free a pointer.'","width":1088},{"text":"I'll just walk through my linked list until I find my entry that corresponds to that pointer.  Oh my gosh, that'd be really slow.  Okay, I'll tell you what, I'll use a hash to speed it up.  I'll have a quick hash so that I can find my pointer and go back to my pointing structure and update my linked list structure correctly.'","width":1472},{"text":"When actually we can do a lot better than that.","width":320},{"text":"We can store our linked list structure as part of the memory that we allocate.","width":576},{"text":"Here's a clever trick.","width":384},{"text":"Let's allocate some memory and we'll allocate a little bit too much.","width":448},{"text":"So if the user says, 'Hey, malloc() 100 bytes we're going to malloc() say 120.'","width":576},{"text":"And we won't tell them, okay?  As far as the caller is concerned, they're just getting 100 bytes.'","width":576},{"text":"But the reason we did this is because we're going to store some secret information back here that's actually our linked list information (our pointer to where to go next).","width":640},{"text":"Wheeeee!","width":320},{"text":"When we return, don't return the pointer to the beginning of here.  No, make sure you bump up the return value so that the return value from your malloc() actually says, 'Okay, user program: here's a little space, here's the 100 bytes that you wanted.'  So we'll add our twenty bytes or however large you made it.","width":1728},{"text":"And when the user later says, 'Okay!  I'm done with my pointer.'  When they call free(), we have to play the other trick and go the other way and say, 'Okay now where did that block REALLY start?'  Let's subtract our 20 bytes again.","width":1152},{"text":"And if we do that, we can find our pointer.  Our linked list structure.","width":320},{"text":"So we're hiding the link information inside the allocation.  Pretty sneaky, huh?","width":576},{"text":"It gets even sneakier than this.","width":320},{"text":"We're going to do two more little things to make it really, really sneaky.","width":384},{"text":"First of all, we'll discover that we actually need to be able to go the other way.  If we start with a block over here, I actually want to be able to kind of have a doubly linked list.  I want to be able to go back to the previous block.","width":896},{"text":"So not only do I want to store the pointer to the next, I want to store the pointer to the previous.  So I'm going to put that over here.","width":576},{"text":"And I'm also going to actually store this information at the end as well..","width":576},{"text":"So if I come over here, I can always look at the previous block and say, 'Okay, where are you?  Where's your start?'","width":512},{"text":"The other thing that we can make use of is rather than storing actual addresses (pointers), we can just store numbers.  We can store the number of bytes and then use pointer arithmetic.  If you know that this is 120 bytes long, and we're looking at the beginning here, then we can just add 120.  We can just store 120 as the size of this thing.","width":1536},{"text":"And we can jump to the next entry.","width":320},{"text":"Or if we look back here to the previous value, then actually we're looking back at the previous block.  And if this makes a note of how big it is, like this one's 200, then we know that we can jump back 200 bytes.","width":960}],
  // Part 6
  [{"text":"This sounds really easy when I'm presenting it in lecture.","width":320},{"text":"Writing malloc is a right of passage","width":512},{"text":"Meaning that you too can have gray hair and fuzzled eyes and look just like me...no","width":576},{"text":"What I mean is that it's tricky because now we have to start dealing with pointer arithmatic","width":576},{"text":"Now we have to start dealing with multiple pointers","width":64},{"text":"A little error like writing pa instead of pb or adding instead of subtracting can bite you big time","width":512},{"text":"And worse it won't bite you in an obvious way","width":320},{"text":"For example suppose that you didn't actually add enough bites","width":256},{"text":"You didn't add 20. You added a smaller number.","width":128},{"text":"Then the user program just overwrites your pointer values.","width":320},{"text":"Of course it crashes","width":128},{"text":"Later when someone calls free and you try to read these values and these values are just garbage","width":384},{"text":"Like what happened to my values!","width":64},{"text":"Why aren't my values correct?","width":192},{"text":"The only thing that can bite you is...","width":128},{"text":"sizeof","width":256},{"text":"So remember if you've got a struct for example","width":256},{"text":"That you've set up to hold these values","width":192},{"text":"Or an array","width":192},{"text":"The sizeof an object or struct is very different from the sizeof a pointer to something","width":512},{"text":"Or sizeof a pointer to an array is different from the sizeof an array","width":384},{"text":"So one little character here can really really bite you","width":256},{"text":"So my advice is to get started early when we put this out and to program slower than you've ever programmed before","width":704},{"text":"Make each line a work of art that you would trust your life to","width":448},{"text":"It still won't work, but at least you've tried really really hard","width":512},{"text":"Yes Question","width":64},{"text":"sizeof doesn't work like that","width":128},{"text":"sizeof is a compiler thing that runs at compile time","width":448},{"text":"so it uses the type ok so sizeof says \"oh look I'm looking at a pointer\"","width":320},{"text":"Pointers on my machine are 4 bytes or 8 bytes","width":128},{"text":"Ok it does not do anything at run time","width":384},{"text":"Alright how are we doing for itme","width":192},{"text":"Ok","width":128},{"text":"We will finish with something really really easy. calloc and realloc","width":128},{"text":"calloc and realloc easy after you've done malloc","width":704},{"text":"These are easy. You can implement them in terms of malloc and free","width":384},{"text":"So realloc says \"guess what...I need some more space\"","width":384},{"text":"Here's a pointer that I previously got from my malloc call or calloc call","width":448},{"text":"Basically a heap pointer, a pointer to some memory. And here's how much memory I need now","width":384},{"text":"I've decided that my array needs to be larger","width":128},{"text":"Realloc will do that for you","width":128},{"text":"But be careful, here's how realloc is supposed to work","width":256},{"text":"It says \"look, I'll try to find some bigger space.","width":192},{"text":"If you're asking for more space, then if necessary I will copy everything across and return a pointer back to you","width":448},{"text":"If it fails however, it returns NULL","width":192},{"text":"So be careful when using realloc. Always check it's return value.","width":256},{"text":"Because it may have decided to shuffle things around for you.","width":256},{"text":"I couldn't extend this. I have something else using the memory just next to you.","width":384},{"text":"So I had to allocate a new block.","width":128},{"text":"But you can implement realloc directly just using malloc and free","width":256},{"text":"Calloc","width":256},{"text":"Calloc is very similar to malloc","width":448},{"text":"What calloc does is it zeroes memory","width":448},{"text":"So it's a bit slower than malloc","width":192},{"text":"Also you give it 2 parameters","width":384},{"text":"You say this is my element size and this is the number of elements","width":192},{"text":"And so the amount of memory it's going to allocate is size times number","width":320},{"text":"Why somebody thought calloc needed two arguments, I have no idea","width":256},{"text":"They should have just made it with just a single argument","width":192},{"text":"The first thing it does just multiply these two numbers together","width":192},{"text":"Except it has to do it the hard way because you could get integer overflow","width":320},{"text":"But anyway, calloc is essentially malloc plus it zeroes the memory","width":320},{"text":"Fastest way to zero memory is to use memset","width":448},{"text":"And we are out of time. Yes! And with that it's 11:50. Have a wonderful week. I will be going down to the lab now.","width":448},{"text":"After I've answered questions incase people want to help setup the android ndk","width":448}],

  // Start Lecture Video 6
  // Part 0
  [],
  // Part 1
  [],
  // Part 2
  [],
  // Part 3
  [],
  // Part 4
  [{"text":"OK. So, programmers took inspiration from miners.","width":384},{"text":"When you go down in the mine you take a canary, yes?","width":192},{"text":"The nice thing about canaries is they die before you, if there's poison gasses.","width":256},{"text":"Or at least then they stop singing as all is well.","width":192},{"text":"So here's what we can do. We can actually put some values into our heap barrier.","width":576},{"text":"And then we just check that those values are still correct.","width":64},{"text":"like there special hexidecimal values, like deadbeef, deadcode, or a value that is a quick hash of the values we want to store.","width":640},{"text":"So we can at least verify that things haven't been overwritten.","width":192},{"text":"So debug versions of malloc and free will do this. They'll take some extra space to write begging and endpoints.","width":512},{"text":"And then before they do anything, they'll check those values to see if they've been overwritten.","width":384},{"text":"So we can't stop the override, but we can at least detect it afterwards.","width":512},{"text":"Any questions?","width":512},{"text":"By the way this idea of putting the size inside as part of the allocated area, this was developed by, I think, Donald Knuth, many years ago.","width":832},{"text":"We've been living inside the user process. Now let's step back a moment and talk about virtual memory.","width":704},{"text":"What do we mean by virtual memory? We've virtualized memory. Ok, what do we mean by that?","width":256},{"text":"We mean that the addresses that our processes uses can have very little connection with the actual addresses that the RAM sees.","width":704},{"text":"That, in essence, there's a mapping.","width":192},{"text":"So ya, we can keep talking about the process address spcae.","width":256},{"text":"It goes from zero up to some high number, let's say 7fffffff.","width":256},{"text":"And we can think of it in terms of little blocks.","width":128},{"text":"And in fact, our virtual memory likes to work with pages called, and there typically about 4096 bytes, or 4","width":704},{"text":"So, anytime you read or write into your virtual memory, we've got to take that address.","width":512},{"text":"Some magic happens.","width":256},{"text":"And say ok, which piece of RAM, which physical address, should I read or write to?","width":896},{"text":"This side will have virtual memory, and and this side we have real addresses.","width":448},{"text":"And it's the MMU, the Memory Management Unit, that has to convert one to the other.","width":768},{"text":"Now today we're just doing the quick two minute version, because there's a lot more to say about this","width":384},{"text":"I just want to give you an idea we can actually step outside the matrix.","width":192},{"text":"Once we start playing these tricks, there's some amazing things we can do with this, as system programmers.","width":512},{"text":"This is a fundamental piece of any reasonable hardware that runs a modern operating system will have a memory management unit,","width":832},{"text":"in order to convert virtual memories into physical addresses.","width":320},{"text":"And here's the cool thing is that now these don't need to be contiguous.","width":192},{"text":"That this mapping can be all over the place.","width":256},{"text":"So this 4K can go to some lower memory and this 4K can go to some other piece of RAM.","width":384},{"text":"So this allows us to use our physical memory much more efficiently.","width":320},{"text":"We don't have to worry about fragmentation, now, and having holes or having spaces inside our physical memory that we can't use.","width":576},{"text":"[So if it's stored on the hard drive...] Ah yes, I wasn't going to mention that but ya.","width":384},{"text":"Here's the cool thing is that now we can now say to every process, \"Hey! you want 4GB? No problem!\"","width":192},{"text":"\"You want 4GB? No problem! You want 16GB? No problem!\" Ok my machine only has 1GB but don't tell them.","width":384},{"text":"Because what we can do is, ya, we can actually secretly store some of the information they want on the hard drive.","width":640},{"text":"It's basically like this, imagine only the bits of the world your currently looking at exist.","width":320},{"text":"Any time you turn around and look behind you, I'm going to put you on pause and quickly recreate everything that you intended to look at.","width":640},{"text":"When I finish doing that, I'll release you again.","width":192},{"text":"So that's what the virtual memory, that's what the operating system does for you.","width":320},{"text":"You think you got 4GB of space. I just promised you that.","width":320},{"text":"Promises are easy because I know you can't actually look at it all at the same time.","width":320},{"text":"I'm going to intercept any time you try to read or write memory to make sure that what you're trying to read or write actually appears to be there inside RAM.","width":512},{"text":"But it's all conjuring. It's all fake. And it's up to the operating system to do this for your process and any other process that's currently running.","width":576},{"text":"Right, that's enough of virtual memory today.","width":512},{"text":"But it's a wonderful system. It's one of the best parts of an operating system today, I believe.","width":320},{"text":"Instead, let's talk about something which is just as powerful and is going to separate your programs from mere novice programmers.","width":896},{"text":"And that is being able to use threads effectively.","width":192},{"text":"This is the beginnings of the major part of this course here, is to understand how to work with synchronization and work with multiple threads. ","width":576},{"text":"This is the coolest bit so here we go.","width":192},{"text":"Let's put on some basic ideas here.","width":192},{"text":"How many heaps does a process have?","width":384},{"text":"That was easy. One.","width":128},{"text":"Inside your process memory a heap is used for all those malloc and free calls and there's only one heap. ","width":640},{"text":"So it's just a BIG area of space that anytime you want memory from you can just call malloc, or calloc or realloc.","width":448},{"text":"But you can just say \"Hey I need some memory and this is how many bytes I need.","width":192},{"text":"It's stored in the heap.","width":256},{"text":"How many stacks?","width":64},{"text":"When we first introduced our program modal we had just one","width":384},{"text":"We said, \"What's a stack?\"  Well, anytime you call a function I need some space for those automatic temporary variables","width":320},{"text":"And also a bit of space to say where the CPU should go back to when it finishes calculating anything we need to do inside that function.","width":512},{"text":"And if the function is recursive then my stack is going to get lower, bigger and bigger, because I'm going to keep calling myself and I need more space on the stack.","width":512},{"text":"And if my function calls other functions, ya agian, my stack is going to get bigger.","width":256},{"text":"That's a stack.","width":320},{"text":"What if I had two CPUs working inside my process at the same time?","width":512},{"text":"Each one needs a stack. Yes?","width":192},{"text":"Because each one will be inside a function; that function might be calling things.","width":448}],
  // Part 5
  [{"text":"So here is the basic idea","width":256},{"text":"I going to have one per thread","width":320},{"text":"So our processes have at least one thread of execution","width":640},{"text":"And it would start in main, as far as we are concerned","width":256},{"text":"And finish when you either called exit or returned from main","width":64},{"text":"And now I'm going to show you how we can have multiple threads going inside each process","width":576},{"text":"So let's start on the stack. All the automatic variables, also known as temporary variables,","width":448},{"text":"(the reason they are called automatic is because they automatically disappear when we return from a function and our stack gets shorter)","width":640},{"text":"You'll find the return address for the CPU, in other words what code you want it to execute when it finished calculating the current function","width":832},{"text":"and the last thing we'll see is the previous stack pointer, or the previous SP","width":832},{"text":"Because we want our stack to shrink when we return from the current function","width":768},{"text":"So what happens if our stack gets too large?","width":320},{"text":"It's.... Stack Overflow. Yes! You've probably heard of Stack Overflow.","width":448},{"text":"I actually registered as the username Infinite Recursion, I couldn't believe it wasn't already taken","width":448},{"text":"So we have a limited amount of memory so in a single threaded model, our stack would meet the heap. Kaboom, and we're out of space","width":1024},{"text":"Our program crashes. In fact, by the power of Virtual Memory, what we can do is set up little pages of memory that are like quicksand","width":768},{"text":"If our program attempts to read them, then it will crash the program deliberately, we send it a Segmentation Fault. Yes? ","width":512},{"text":"[Student asking question]","width":192},{"text":"Can you sbrk more memory for the [stack]. No, no you cannot. Sbrk represents the top of the heap.","width":512},{"text":"[Another student question]","width":128},{"text":"No, but where they meet depends how big your heap is and how big your stack is","width":384},{"text":"What we're going to do is make multiple threads though, supposing we have multiple CPU's working at the same time","width":448},{"text":"So what we'll have to do is make our stack start in different places","width":256},{"text":"So there is actually a possibility of one stack hitting another stack if it gets too large","width":384},{"text":"Now let's have a look at some code, let's play with some code","width":448},{"text":"Here we go. C'mon. Great.","width":448},{"text":"We are going to be working with a thread framework called pthreads","width":256},{"text":"It's very popular, you can run it on Android machines as well","width":320},{"text":"Here's the plan: We are going to make our program do some CPU cycles","width":512},{"text":"We agree that our program will never print Hello World, it will just go around this loop forever","width":320},{"text":"But what I would like to do is have a second CPU working on my machine","width":384},{"text":"And for that, I can call pthread_create","width":256},{"text":"There's four arguments, let's have a look at them","width":192},{"text":"First, we have a pointer to pthread_t, some attributes which can just be NULL, this scary looking thing and finally an arg","width":896},{"text":"Let's talk about each of these","width":320},{"text":"First of all, this is a function pointer. It looks pretty scary, void star start routine ahhhhh!","width":448},{"text":"Here's how to read this: You see where it says start routine?","width":256},{"text":"Just interrupt that as the name of your function and then work backwards. It's going to return a pointer to a void* and it takes a void* as an arguement","width":704},{"text":"And then we wrap the name of the function with an extra set of parenthesis. Let's take this and write our function","width":768},{"text":"Cool beans","width":576},{"text":"Alright, what should we do inside cool beans?","width":320},{"text":"Let's sleep for 2 seconds, then we will print out the pointer","width":896},{"text":"And a new line. Ok, so now let's call pthread_create","width":384},{"text":"We can have a pthread id. So we pass in the address of that stack variable, we aren't doing attributes today","width":768},{"text":"Now we can just pass in the function name. If you ever pass in a function name without the parenthesis, it means \"Tell me the address of this code\"","width":576},{"text":"And finally we can pass in a void *, so we write (void *) 12345","width":960},{"text":"Let's write something in hex. I need a hex value. How about 0xdeadcode?","width":1024}],
  // Part 6
  [],

  // Start Lecture Video 7
  // Part 0
  [{"text":"Ok, it's 11 o'clock. Good morning class how are you?","width":704},{"text":"Alright how's your shpar looking?","width":192},{"text":"I imagine some of you are celebrating that shpar is finished.","width":256},{"text":"Except of course you know it's not,","width":128},{"text":"because what we expect you to do now is actually not just make code that appears to work, but code that you are proud of.","width":448},{"text":"Code that is probably commented, code that has nice variables, code that you give someone else and they could maintain it.","width":384},{"text":"Some of the worst things about writing sloppy code is someone has to come back to you and say,","width":256},{"text":"\"What was this going on here?\" \"I have no idea I wrote that yesterday.\"","width":192},{"text":"Now's your chance to put your coding skills to test, not just to make something that works, but to make something that works well.","width":576},{"text":"And we'll do a finally code review next week on Thursday.","width":256},{"text":"We'll have some other things for you to do before that, but we'll announce that via email. ","width":384},{"text":"Here's what we're going to talk about today. We're going to talk about using threads.","width":384},{"text":"Threads are cool because we can now make our single process do multiple things.","width":384},{"text":"And threads are cool because they allow multiple threads to share the same memory and the rest of the state of your process.","width":576},{"text":"So if you've opened a file descriptor in one thread, you can use it inside another thread.","width":384},{"text":"The exciting thing happens, though, when you have to wait for one thread to complete something.","width":256},{"text":"And for that, we need to worry about synchronization.","width":320},{"text":"And that's what sets your programming apart from things you've seen inside CS 225 and 125, earlier courses and other people that might have just picked up some programming.","width":640},{"text":"The ability to work with multiple threads correctly so that it always works when not just ten users are on your website, but a thousand users are on your website","width":512},{"text":"or you've got multiple CPUs inside your tablet, or your phone, or your watch, then that's where synchronization comes in.","width":512},{"text":"But anyway, let's get started. Little question, little memory question for you.","width":320},{"text":"My thread calls pthread twice, pthread_create twice, how many stacks does my process have?","width":896},{"text":"Ok, let's pick someone at random. Hi! What's your answer?","width":384},{"text":"If you said one, guess again.","width":384},{"text":"Any advances on one?","width":256},{"text":"If you said two, thanks for playing, but almost correct, off by one.","width":320},{"text":"It's three! Why?","width":320},{"text":"Thank you, yes! We get a thread for free at the beginning.","width":448},{"text":"One thread must be calling main, our CPU must be executing code at main","width":320},{"text":"All we did by calling pthread_create twice is we got ourselves two additional threads.","width":384},{"text":"And remember, each thread needs a stack. Why?","width":320},{"text":"Well we're calling functions. We have to put those automatic variables somewhere.","width":192},{"text":"And, when we return from a function, we have to remember where we're going to go back to. So again, that goes on the stack.","width":384},{"text":"So for each thread there is a stack and we have three threads in our process.","width":512},{"text":"So if my code called created twice, that means I could be doing three things at the same time.","width":448},{"text":"Ok, so I've been talking about processes for quite a bit, and talking about threads. What are some of the differences between them?","width":640},{"text":"Which is bigger?","width":128},{"text":"A process, yes. How much bigger?","width":384},{"text":"It's HUGE! Our process is a massive object!","width":192},{"text":"It's got file descriptors. It's got a big virtual memory space.","width":448},{"text":"Threads are tiny. they live inside a process.","width":256},{"text":"If you killed a process, that's it for all of your threads. They don't have anywhere to run anymore.","width":512},{"text":"So your process represents the sandbox. Everything that your threads can do will live inside a process.","width":448},{"text":"So our process has security.","width":448},{"text":"It's got virtual memory.","width":128},{"text":"It's got an exit status.","width":256},{"text":"Threads live inside a process, and they just represent what you want the CPU to do.","width":576},{"text":"They represent the code, the position in the code that is currently being executed.","width":512},{"text":"So that means if you kill a process, ha ha that's it. All of your threads are done.","width":256},{"text":"So if you send, say, an alarm signal to your process, all of your threads will disappear.","width":640},{"text":"If the process disappears, all of them have gone. This is an important point. They just live inside.","width":576},{"text":"So if we've created all these threads, perhaps we want to stop them.","width":320},{"text":"Guess what, you can do that and here's what you'd call. You'd call pthread_cancel.","width":448},{"text":"Let's have a look at pthread_cancel.","width":192},{"text":"How could I cancel a thread?","width":192},{"text":"Easy, just send in that id that we got from pthread_create and you can cancel a thread.","width":512},{"text":"I don't want to spend too much time on this because, in practice, no one bothers to use this.","width":448},{"text":"Here's why. Imagine you are making a fantastic meal for Friday night your potential boyfriend, girlfriend, dog is coming over,","width":832},{"text":"and your cooking like a storm here. And then suddenly, BAM! your activity is cancelled.","width":384},{"text":"The kitchen is in complete disarray. It hasn't been cleaned up. What a mess!","width":320},{"text":"It's extremely rare that we can just cancel something and not have to clean things up.","width":320},{"text":"So what examples might we have.","width":128},{"text":"Well let's say you have a thread that's kind of calculating new digits of pi, or discovering prime numbers,","width":576},{"text":"or trying to mine bitcoins like you've come up with a new currency called CS241coins or something.","width":448},{"text":"You can probably cancel that. It was just a CPU intensive job.","width":256},{"text":"But if there's any kind of resources, then maybe we shouldn't just call this cancel and leave everything in disarray.","width":448},{"text":"So in practice what we tend to do, actually make a variable to tell our threads, \"Oh by the way, you should stop at some point.\"","width":576},{"text":"And if you call this pthread_cancel, things don't even stop immediately.","width":256},{"text":"Typically they will stop when that particular thread makes a system call, like open or read.","width":384},{"text":"We can discover all of the calls just by looking at the man pages.","width":256},{"text":"So this will be like the moment that your chef opens the oven door we say, ","width":320},{"text":"\"ok, you're out of here, we've quit you, we've cancelled you, no more work for you.\"","width":320},{"text":"So what a mess. We don't tend to do that.","width":192},{"text":"So let's write something that can be cancelled.","width":320},{"text":"We want to call pthread_create. What do we pass in? A pointer to our little identifier.","width":320},{"text":"We don't need any parameters. What's next? Oh yes, the function.","width":320},{"text":"I called it my funct, and an initial value. Let's just pass in NULL to begin with.","width":448},{"text":"And this will go on forever.","width":384}],
  // Part 1
  [{"text":"Alright, so, this little function can say initially we are going to just sleep for one second","width":704},{"text":"and then put something like \"HI!\".","width":128},{"text":"Ok, right, so its gonna print \"HI!\"","width":192},{"text":"So, now, I've got a program that is going to use two CPU's, if I have two CPU's.","width":384},{"text":"Uh oh, what happens if I only have one CPU?","width":384},{"text":"The scheduler!  The Linux Kernel is going to say \"okay, you get access to the CPU for say 10 milliseconds or 100 milliseconds","width":704},{"text":"and after that amount of time, I'm going to take you off the CPU and let the other thread use it.","width":448},{"text":"And if we do this faster enough, like 10 milliseconds or so","width":192},{"text":"then those slow humans will never notice, that actually only one thread at a time is on each CPU core","width":576},{"text":"And if it turns out that you make a system call like \"open\" or \"read\" and it takes time for us to read that stuff from the disk","width":448},{"text":"Then you don't need the CPU because you are waiting for stuff so I can give the CPU to someone else.","width":256},{"text":"So the scheduler has to make those decisions and make them well.","width":256},{"text":"Ok, so for example this sleep, you don't need any CPU to sleep.  I can let another thread use that.","width":448},{"text":"So, what were we going to do here...","width":192},{"text":"Oh yes, let's change this so we can cancel our little \"HI\" function.","width":192},{"text":"We'll sleep for 3 seconds here and then change to something like \"please_stop\".","width":448},{"text":"And then I will just loop forever.","width":256},{"text":"So, what do were want to do here?  We want to say \"while (!please_stop)\" keep going around.","width":448},{"text":"And finally, let's have a global variable...there we go.","width":320},{"text":"We know in C that our global variables are initialized to zero.","width":256},{"text":"Let's run this and see what mistakes we made.","width":128},{"text":"(waiting)","width":576},{"text":"Ok, alright.  Whoops, we didn't declare the thread id.  So, what's that?  \"pthread_id\" I believe.","width":512},{"text":"(waiting)","width":896},{"text":"(grumbling)","width":128},{"text":"","width":192},{"text":"Oh, I just put a \"t\"","width":128},{"text":"","width":320},{"text":"How about that?","width":64},{"text":"","width":256},{"text":"Yay!.  Ok, alright.","width":128},{"text":"","width":64},{"text":"So we print \"HI!\".  Our main thread sleeps for a bit and then calls \"please_stop\"","width":448},{"text":"And our little thread that is going around the loop says \"oh, look at that global variable, I better stop\".","width":192},{"text":"Now I use global variables for a quick demonstration. Obviously we could put that inside a struct.","width":256},{"text":"We could pass something to the working thread inside here and we could use that to communicate with the other struct","width":704},{"text":"so we could have some control if we agree to share some memory.","width":256},{"text":"","width":64},{"text":"Now I can hear my CPU fan going.","width":192},{"text":"(fan noises)","width":64},{"text":"Do you hear that?  Good.","width":192},{"text":"Because the CPU is constantly doing that little while loop in the main thread.","width":320},{"text":"So let's do something better than that.","width":64},{"text":"What we would like to do of course is wait","width":128},{"text":"What we would like to do of course is wait for the other thread to finish.","width":256},{"text":"One way to do that is to say \"pthread_join\" and say \"here is the thread that we want to finished\"","width":384},{"text":"And we would like to know it's exit value.","width":128},{"text":"There we go.  We can find out what it is.","width":256},{"text":"Alright, here is my exit value and we can say return something here","width":576},{"text":"So what when we call \"pthread_join\" again, this second thread is going to not require anymore CPU time.","width":448},{"text":"Because not it is waiting for the other thread to exit.","width":256},{"text":"","width":384},{"text":"So that is one way to write this program.","width":128},{"text":"","width":128},{"text":"I can also talk about \"pthread_exit\"","width":576},{"text":"Let's write a very dangerous program.","width":320},{"text":"This is the \"_killer_monsters_take_over_the_world\".","width":768},{"text":"You will agree that we probably should not run that function, yes?","width":320},{"text":"Well that's okay, because I am going to call pthread_exit before it.","width":384},{"text":"And I do not need a return value.","width":384},{"text":"\"pthread_exit()\" says \"hey, I am the chef and I am done.  I'm leaving the kitchen for good\".","width":512},{"text":"If you call pthread_exit then, you are saying \"this is the thread's return value\" and no more code will be run by that thread.","width":704},{"text":"\"_killer_monsters_take_over_the_world\" will never happen.","width":192},{"text":"","width":320},{"text":"This stuff about having \"exitvalue\" and \"pthread_join\" in this case, that is never going to happen.","width":320},{"text":"\"pthread_exit()\" simply means \"I am done\".","width":256},{"text":"","width":192},{"text":"A little bit of knowledge for you, if you call \"pthread_exit()\" inside the main thread, the original thread, like we did just did","width":448},{"text":"the rest of the process will actually keep on running.","width":320},{"text":"The pthread library actually says \"you know what?  I am actually not going to quit this process immediately","width":192},{"text":"I am going to wait until ALL threads have finished\".","width":256},{"text":"","width":320},{"text":"Let's prove that.  Let's call \"pthread_exit()\" here.","width":320},{"text":"","width":128},{"text":"I'm going to comment this out so it compiles.","width":192},{"text":"","width":128},{"text":"Instead I will call ... nah, this is good.","width":384},{"text":"So then, what will my program do now?","width":320},{"text":"","width":384},{"text":"That's right, it is just going to keep printing \"HI!\".","width":128},{"text":"It is not going to take over the world.","width":128},{"text":"Instead what we did is we created another thread and our main thread exited.","width":448},{"text":"","width":384},{"text":"So, let's go back to this.","width":128},{"text":"","width":192},{"text":"Let's answer some of these questions.","width":128},{"text":"What is the difference between exit and pthread_exit?","width":192},{"text":"What does exit do?","width":128},{"text":"It kills the whole process.","width":256},{"text":"Yes, it says \"Hey, this process is done and here's the exit value.","width":320},{"text":"By the way, it also does a little few extra things for you.","width":192},{"text":"If you've written to the C output buffers, like stdout and stderr or anything else","width":384},{"text":"those get flushed and those file streams get closed for you.","width":192},{"text":"","width":384},{"text":"So if you call exit, all of your threads are gone.","width":320},{"text":"\"We're done\"","width":128},{"text":"Your process is done.  And it doesn't matter which pthread calls exit().","width":448},{"text":"You are saying \"This whole process is done. Wrap up the shop, close all of the kitchens.  We're gone.\"","width":512}],
  // Part 2
  [],
  // Part 3
  [],
  // Part 4
  [{"text":"Yes","width":128},{"text":"Yeah","width":384},{"text":"Ok right. So what happens if you put static inside a function?","width":384},{"text":"So the variable itself lives forever, but static makes it a secret variable.","width":576},{"text":"yes the scope of it, the name start, is only available inside that funciton","width":256},{"text":"but the actual storage of that variable is for the lifetime of the process","width":448},{"text":"thats like one of those awful interview questions","width":64},{"text":"hey whats on page 37of the C standard?","width":384},{"text":"i dont know. I didn't write it","width":192},{"text":"Knowing precisely how static works is an exercise left for the advanced C programmer","width":640},{"text":"But by defining static, the life time of the memory is for the duration of the process","width":384},{"text":"To cast an int to a void pointer, if you're sure that a void pointer has enough bits to represent the parameter you're trying to pass in","width":1472},{"text":"You can also just say, look void","width":256},{"text":"LEt me choose a different value like 71","width":256},{"text":"That means, I gotta type as a pointer to some memory","width":320},{"text":"nto going to say what kind of pointer yet","width":256},{"text":"Im going to pass in this value 71","width":64},{"text":"you can do that providing you write the code to the other end to simply cast it","width":448},{"text":"if you attempt ot read at memory 71","width":192},{"text":"oops, you'll get a segfault","width":256},{"text":"I will not talk about that right now","width":512},{"text":"How about this one?","width":448},{"text":"So what I want to do here is that I want to send","width":384},{"text":"my value of i from 0 to 9 to some new threads","width":448},{"text":"So each one can get a value","width":320},{"text":"Why does this code not work?","width":256},{"text":"So take a moment with your neighbor to review it","width":576},{"text":"Ok so here's a version of that code","width":5888},{"text":"The first thing we might comment is what might this code print out?","width":640},{"text":"It might jsut print out hello world and nothing else","width":256},{"text":"it could be that we return from our main before those other threads ahave  a chance to start up","width":512},{"text":"Before those chefs can be employed and waltz into our kitchens, the process itself is exited because we've returned from main","width":448},{"text":"How do we stop that","width":64},{"text":"Well we could just call pthread_join on every one of those tids","width":448},{"text":"But you and I know we can call pthread_exit here and leave it up to the system to finish a process when all the other threads have exited","width":704},{"text":"And this is the output we get","width":576},{"text":"Im printing out the value that's actually sent to each new thread and also the actual pointer we've got as well","width":704},{"text":"the first commment is look at all these numbers! They're all the same","width":448},{"text":"ANd it seems to work.","width":128},{"text":"If we only tested this with 6 threads, we think our code is fantastic!","width":448},{"text":"But instead I get 0,1,2,3,4,5 and four 10's","width":64},{"text":"So the for loop finished","width":1216},{"text":"So, for the early threads, what happened?","width":384},{"text":"We ran our loop, we start a thread","width":192},{"text":"For the remaining threads, we went around the loop and those threads did not start. ","width":704},{"text":"They weren't scheduled on the CPU","width":64},{"text":"They're going to be. It's just they didn't start straight away","width":576},{"text":"Eventually they do start","width":128},{"text":"ANd theyre all given the same address","width":192},{"text":"the address of i","width":128},{"text":"it just happens to be a stack variable in my main thread","width":256},{"text":"by the time they started, we've already incremented the value","width":320},{"text":"it had already been incremented up to 10","width":320},{"text":"and we saw that they really are looking at the same variable because we've printed out the variable that was given to us","width":768},{"text":"and that address, 7fe blah","width":192},{"text":"is just part of the stack of the main thread","width":256},{"text":"So to fix it","width":320},{"text":"We coudl make a struct for each of our threads using malloc","width":384},{"text":"Or we can make an array in global","width":192},{"text":"but let's do the trick that you suggested","width":192},{"text":"lets just cast this","width":128},{"text":"to a void pointer","width":128},{"text":"because we're C programmers and we know what we're doing","width":448},{"text":"Absolute garbage, yes","width":832}],
  // Part 5
  [{"text":"Ok, so time you get each address","width":448},{"text":"that was given to our program","width":320},{"text":"is valid. But we shouldnt try to dereference it. ","width":512},{"text":"We should actually just try to say, ","width":64},{"text":"look, I know you gave me a pointer to","width":64},{"text":"some memory, but I'm just kidding.","width":256},{"text":"i'm not actually interested in ","width":64},{"text":"using as a pointer to some memory","width":128},{"text":"I just want to cast it back.","width":64},{"text":"Change that current bit pattern","width":128},{"text":"you got as a pointer to a bit pattern that","width":64},{"text":"now represents an int.","width":128},{"text":"Do not pass go.","width":128},{"text":"Do not attempt to read that location","width":128},{"text":"otherwise bad things will happen","width":256},{"text":"So, here's another way of actually getting the right results.","width":64},{"text":"Now we have all of our numbers","width":192},{"text":"And something you might notice thats surprising","width":256},{"text":"is that it doesn't count up","width":128},{"text":"0 7 6 5 4 3 2 1 9","width":128},{"text":"Why?","width":192},{"text":"Does someone dare speak that hasn't spoken yet in CS241?","width":704},{"text":"Yes, in the back!","width":448},{"text":"Yes, thank you.","width":320},{"text":"There's no guarantee when that thread is going to stop.","width":256},{"text":"and in fact it might be paused half way","width":64},{"text":"the scheduler might say ","width":64},{"text":"actually, I know I was going to give you the ","width":64},{"text":"kitchen, I know","width":384},{"text":"I was going to give you the CPU, but actually I've decided to give the CPU to another thread, so ","width":192},{"text":"we don't know when they're going to get","width":256},{"text":"because the scheduler is part of the operating system","width":256},{"text":"is trying to make best use of all possible resources","width":256},{"text":"so there's no knowing what order those threads","width":256},{"text":"are going to run","width":64}],
  // Part 6
  [],

  // Start Lecture Video 8
  // Part 0
  [{"text":"[background noise]","width":4403},{"text":"good morning you gin lads and welcome to the bountiful C","width":269},{"text":"the wonderful c, the giver of life, the platform that allows us to compile our codes on new hardware","width":481},{"text":"you wanna take a program, you wanna put it on your new hardware, don't worry you just need to make a C compiler","width":373},{"text":"the wonderful C","width":83},{"text":"perhaps you've written it in python, doesn't matter, python itself is written in C","width":300},{"text":"perhaps you've written Minecraft","width":271},{"text":"ahhh,well don't worry about that, that's written in Java, well Java of course is written in, well c++, but nevermind, it's almost C","width":556},{"text":"perhaps you've written a ruby program, well guess what? ruby the interpretter is written in C","width":281},{"text":"yes, so C is underneath it all","width":201},{"text":"and that is partly why C is such a powerful and potent language","width":342},{"text":"it is also a fantastic langauge for working directly with hardware because we can create memory structure that map directly onto bytes and bits","width":688},{"text":"of our hardware","width":84},{"text":"so C gives you tremendous power because it's so close to assembler","width":344},{"text":"but a lot easier to write than assembly code","width":244},{"text":"alright, so","width":108},{"text":"we've been talking about making our c programs run with say two processes or doing two things at the same time","width":347},{"text":"well this is where things start to get interesting","width":171},{"text":"for example, let's count our gold ","width":243},{"text":"I've got a little function here called countgold() and you can see this is going to effect ","width":413},{"text":"so let me run this, i'll make a separate thread to do it","width":342},{"text":"alright, how do I do that? ","width":63},{"text":"well I need to pass in some sort of identifier and then I've got some options I don't care about","width":482},{"text":"what next?","width":52},{"text":"and then the function countgold and finally I want to give countgold a parameter of nothing, so I can just pass in null here","width":593},{"text":"and of course we want to wait for this to finish","width":213},{"text":"this time I'll call pthread_join() because I don't want to just finish at this point, I want myself to print out the value of the sum","width":600},{"text":"great, so, let's wait on this","width":301},{"text":"and I can, I'll have to put my little pthread_t type in here tid1","width":420},{"text":"and I can actually have an exit value as well","width":208},{"text":"so what did it say?","width":186},{"text":"that can just be a, whoops, void pointer and I'd better give it the address of that thing","width":523},{"text":"so let's compile this and see what we get","width":457},{"text":"arlight, argh, sum is zero","width":213},{"text":"now why was that?","width":334},{"text":"that's a good question, why was that? ","width":178},{"text":"we should've waited on this so let's first of all check that I'm using this correctly","width":533},{"text":"so we'll check the value of tid and see what it is","width":484},{"text":"and we should have ","width":503},{"text":"ok we've got a valid value","width":66},{"text":"so why did pthread_join() not ","width":430},{"text":"join terminate","width":327},{"text":"OK, alright, so at this point","width":387},{"text":"OH, yes, hahaha","width":351},{"text":"what did I pass to pthread_join()? the address of tid1","width":420},{"text":"not the value of tid1","width":193},{"text":"so, we needed the address up here because we wanted pthread_create to push the id into that variable","width":536},{"text":"but pthread_join() we just said here's your address and pthread_join() says thank you very much for that address, I'll take that as your thread identifier","width":411},{"text":"no, we wanted the value","width":250},{"text":"ok, so normally because that would take us about four or five days to discover","width":467},{"text":"good, so this time now it's waiting","width":140},{"text":"and finally it prints out the sum is a million","width":224},{"text":"fantastic","width":39},{"text":"now let's not just have one part that's going to count the gold, we want two","width":394},{"text":"so we'll have two threads going ","width":219},{"text":"they're both going to run the same function, but you and I know they both have their own threads","width":241},{"text":"so they both have their own stacks","width":207},{"text":"so each thread has it's own value of i","width":320},{"text":"OK, so, we'll, of course if we didn't do any waiting","width":591},{"text":"ah, thank you","width":290},{"text":"we didn't do any waiting, then our value is just some other value","width":276},{"text":"happens to be 56,000","width":154},{"text":"in other words we had two of these other threads running at the same time","width":195},{"text":"and our main program just decided to carry on and by the time we actually read the values ","width":482},{"text":"those other threads had already incremented it","width":196},{"text":"so we'll change this now to actually wait and any time that we copy paste code be very very careful to make sure you change everything you need to change","width":757},{"text":"I don't need two exit values, I don't care that both of them are going to write from the same thing","width":326},{"text":"so, now my program says OK,wait until the first thread is joined and then our main thread says now wait for the second thread to join","width":480},{"text":"and there we go","width":57},{"text":"my sum is about one and a half milliion","width":359},{"text":"whoops, I did not get two million even though both threads were just adding one to the sum","width":507},{"text":"perhaps you can see why","width":95},{"text":"we'll surely then we can fix this by saying rather than sum plus equal one, I'll just say sum plus plus","width":678}],
  // Part 1
  [{"text":"ok, what would our value be now?","width":503},{"text":"again, about 1.5 million, certainly not two million","width":318},{"text":"our pyrax cannot count","width":262},{"text":"OK, so why did it fail? why did my sum not get two million?","width":504},{"text":"thank you! yes! two threads are touching the same memory location","width":262},{"text":"so even though we wrote sum++, sum++ is not an atomic operation","width":413},{"text":"now life would be easy if our threads were like gorillas","width":262},{"text":"if they walked up to a memory location mine!","width":455},{"text":"they changed it, they added one to it","width":247},{"text":"they asked it any other thread","width":181},{"text":"and they threw it back","width":168},{"text":"ok, but that's not how it works of course, no instead we're copying bit patterns","width":301},{"text":"we're copying bit patterns from main memory into the CPU ","width":207},{"text":"we're running through our model adding machine and then we're putting the value back into memory","width":268},{"text":"during that time another thread may have come along and coppied the original bit pattern from memory and done it's thing inside its CPU","width":619},{"text":"and then put it back","width":112},{"text":"so hopefully you can see that it's possible that the value could be less than two million","width":720},{"text":"if it turns out that are trying to add at the same time","width":405},{"text":"in fact it's possible for  the value to be much smaller than that","width":622},{"text":"but let's talk instead about how we can actually fix this","width":392},{"text":"we've made it deliberately interesting by making sure that each threads are touching the same memory","width":457},{"text":"it would be pretty boring if they were working inside their own stack space","width":337},{"text":"or we'd give them different memory locations to play with, say if we'd give them sum one and sum two then of course everything would be fine","width":358},{"text":"life gets interesting when we actually have two threads competing and working on the same memory","width":387},{"text":"so what we'd like to do is say 'oh I've got a problem and here's a piece of my code that I only want one thread to play with at time'","width":574},{"text":"in other words, I've got a critical section","width":131},{"text":"and inside this little example here this single line is my cirtical section","width":381},{"text":"it's the piece, it's the lines of code, where you say 'I only want one process or one thread to read this memory or modify this memory'","width":639},{"text":"because if I have two threads working then they may see things or leave things in an inconsistent state","width":552},{"text":"now we're programming with a very simple exaple with integers and sums","width":224},{"text":"but now think about your other data structures you wrote in say CS 225","width":266},{"text":"where you've got multiple memory structures, you've got pointers to arrays, integers which reperesnet the number of things in an array","width":481},{"text":"if you didn't write that thing directly than the STL library did it for you","width":294},{"text":"all those things need to be in a consistent state","width":151},{"text":"if you wrote linked lists then you'd better make sure that you're sentinal value is actually present","width":432},{"text":"and there's a few nanoseconds where that's not true","width":210},{"text":"so whilst you'll updating a data structure you don't want anybody else to touch it","width":297},{"text":"you don't want anybody else to read it and you certainly don't want anybody else to try and update it at the same time","width":276},{"text":"so that's where mutex locks come in ","width":487},{"text":"so a mutex is a very valuable thing","width":360},{"text":"it's like having a girlfriend or a boyfriend or a dob","width":280},{"text":"it's yours","width":101},{"text":"and you're not going to let anybody else own it","width":199},{"text":"very objective thing","width":152},{"text":"it's mine, I'm jealous","width":113},{"text":"don't let if you are holding a mutex, you don't want anybody else","width":254},{"text":"any other thread to try to lock that mutex","width":276},{"text":"if they do they have to wait until you've finished with it","width":454},{"text":"now to be procise we are locking and unlocking","width":166},{"text":"I just wanted to give you some ideas so that in your next jealous outburst you can remember this lecture","width":586},{"text":"alright, so, let's have a look to see how we can do this, what we'd like to do is around this critical section we'd like to lock a mutex and afterwords we'd like to unlock it","width":895},{"text":"unlocking doesn't take anytime at all","width":118},{"text":"locking usually doesn't take anytime at all unless somebody else has locked the same mutex","width":384},{"text":"in which case you're out of luck","width":146},{"text":"it's a bit like trying to walk up to a counter, the clerk is currently busy, you'd have to stand there and wait and twiddle your thumbs","width":461},{"text":"in fact you might actually use up a bit of CPU time while still twiddiling thumbs, it's often called a spin lock","width":415},{"text":"which is how this thing is implemented underneath but we don't need to talk about that","width":230},{"text":"but essentially we've got a little piece of code that says ok, i have to wait i have to wait i have to wait i ahve to wait until the mutex lock has been unlocked","width":606},{"text":"but they're designed to be efficient for when you want to lock them and unlock them in the very near future","width":468},{"text":"so let's actually have a look at the code for that, how do we do that?","width":207},{"text":"we'll it's part of the pthread library","width":119},{"text":"and we can say I've got a pthread_mutex, here it is, it's a pthread_mutex_t type","width":525},{"text":"and I'll just call it my mutex one","width":360},{"text":"so now we want to lock it","width":182},{"text":"how can I possibly write that code if pthread_mutex_lock()","width":291},{"text":"what do I need to give it? the address of the mutex","width":280},{"text":"and guess how I unlock it","width":169},{"text":"you write pthread_mutex_unlock()","width":293},{"text":"OK, so now we think we've got working code","width":256},{"text":"let's try it and just for fun I'm going to reduce the number I wrote by an order of magnitute to make it run a bit faster","width":806},{"text":"tick tick tick","width":78},{"text":"suddenly we noticed even though I made the for loop to help with the speed I think it returned","width":504},{"text":"OK, heres, here's to the first surprise, it shouldn't have worked","width":448},{"text":"[laughs]","width":142},{"text":"it appeared to work, but that's just lulling us into a false sense of security","width":392},{"text":"the second surprise is that it took a bit longer","width":221},{"text":"so at least I'm sorry I took the loop down by an order of magnitude yet it still took a long time","width":427},{"text":"so this is a not free the lock and unlock are not free, it takes a certain amount of time","width":298},{"text":"especially if you look at how much overhead we're doing in this example","width":186},{"text":"we're just incrementing and getting them out of a loop. so they don't take a small amount of time to run","width":548},{"text":"the second thing is that they may not work if you've forgotten to initialize them","width":280},{"text":"and this time for a lecture demonstration i was unlucky that it did work","width":254},{"text":"what we should do is make sure that our mutex locks are properly initialized","width":338},{"text":"alright, so how can I do that?","width":127},{"text":"well before using them we should call pthread_mutex_init","width":437},{"text":"and let's look at the man page","width":275},{"text":"we can pass in a pointer to our mutex as some attribrutes if we'd like as well","width":361},{"text":"so I can say 'ok initialize my mutex and here's some additional attributes I could set up for them as well","width":410}],
  // Part 2
  [{"text":"ok there's another way to initialize them","width":393},{"text":"which is to actually set an equal to this magic macro pthread_mutex_initializer","width":784},{"text":"ok, so, if I do that then I've got an initialized mutex and now I've got this object not in a c++ cense, but in terms of something conceptually I can think of as an object","width":904},{"text":"that I can lock","width":56},{"text":"and remember, the lock means that no other thread can lock the mutex","width":399},{"text":"so I'm using it as a way to serialize who gets access to my sum variable","width":507},{"text":"if your thread comes a long and tries to lock this mutex one then it has to wait until I've finished with that mutex","width":414},{"text":"and similariliy if you've locked mutex then I have to wait","width":353},{"text":"yes?","width":334},{"text":"then we go back to the original problem we have arbitrary values","width":521},{"text":"ok, so yeah, we could do that, we could have another little loop down here for example","width":1139},{"text":"yes","width":64},{"text":"and we're back to our same problem that the CPUs are now stepping over each other in trying to read and write to this memory location","width":566},{"text":"pthread_mutex doesn't give you any magic, it's a very low level way just to stop two or more threads form continuing","width":560},{"text":"it's up to us to do some code analysis and say 'yeah, actually I've got a problem with this code'","width":331},{"text":"I forgot to put a pthread lock around that other loop","width":242},{"text":"[student question]","width":593},{"text":"correct, yes, you can just think of it as a very simple little busy loop","width":258},{"text":"the lock thing says 'hey whilst it's mutex is locked by someone else I'm going to wait'","width":385},{"text":"that's all it does","width":87},{"text":"it doesn't magically say and the code in here is amazing and bug free","width":289},{"text":"it doesn't say that other pieces of memory are especially locked, it's just a loop","width":524},{"text":"it just happens to be a clever loop to be sure that there can only be one ","width":276},{"text":"if two threads called mutex lock at the same time","width":242},{"text":"only one of them wins","width":117},{"text":"only one of them gets to go to into the bathroom","width":218},{"text":"the other one has to wait","width":55},{"text":"a bit","width":316},{"text":"but eventaully that first thread will presumably unlock the mutex at which point the waiting thread can say 'oh great, it's my turn to lock it' and continue","width":692},{"text":"so it's a busy loop, it tries to be efficient in the case that the lock is unlocked","width":473},{"text":"because most of the time there isn't a conflict","width":134},{"text":"most of the time it's pretty unlikley that two threads are reading the same data structure","width":343},{"text":"it's just that one percent of the time or .1 percent of the time we're lucky and our CPU, or two or more CPUs are trying to read the same memory when we don't want them to","width":708},{"text":"yes? [student question]","width":309},{"text":"yes, in this tiny example we would actually get a better performance if we did that","width":596},{"text":"if we just locked the whole thing for the entire time","width":281},{"text":"in other words for this silly little tiny example","width":301},{"text":"there's absolutely no point running two threads","width":162},{"text":"yes","width":62},{"text":"trying to have two threads accessing the same memory we might as well of just had a single thread that weant up to two million","width":601},{"text":"ok, so the parallelism in this case or the speed of it just isn't worth it","width":396},{"text":"the reason I've chosen this example is because it's trivial to show a problem with two threads incrementing the same piece of memory","width":811},{"text":"it would not be a problem if sum was the local variable because local variables are stored in the stack","width":395},{"text":"and the stack is per thread","width":137},{"text":"and so presumably they'd be updateding their own variables","width":612},{"text":"what happens if you forget to unlock?","width":117},{"text":"ok, imagine this, imagine the person in front of you goes into the bathroom and never comes out","width":788},{"text":"what we've discovered ladies and gentlemen","width":132},{"text":"is something called dreadlocks - nah - no, actually deadlock","width":302},{"text":"nothing to do with dreadlocks or bad hair","width":150},{"text":"or goodhair if you like dreadlocks","width":116},{"text":"so we've got a problem of deadlock","width":137},{"text":"we've got one thread waiting for another thread to unlock a mutex and it never happens","width":377},{"text":"right, our poor thread is stuck","width":560},{"text":"alright, so let's do that to our poor little program","width":619},{"text":"and you can tell me how quickly my program will finish","width":746},{"text":"three years later we're still waiting","width":356},{"text":"what happened? well I had one thread that locked the mutex and a second thread that said 'ok, i'm going to wait because i need to lock this mutex' ","width":677},{"text":"so it never proceeds, it never gets into the for loop","width":187},{"text":"meanwhile our main thread is waiting for both threads to finish","width":313},{"text":"when does that happen? never","width":318},{"text":"so if you think C code and programs have been hard to debug so far","width":390},{"text":"you ain't seen nothing yet. baby no because","width":230},{"text":"our program stalls, it gets stuck if we were to debug this we'd discover that the main thread is here, it's waiting","width":519},{"text":"it's waiting for soemthing that never happens","width":130},{"text":"we have to say while why is it waiting? what happened to that other thread?","width":185},{"text":"so like sherlock holmes you have to say look this thread ever unlocked a mutex","width":623},{"text":"yes?","width":1139},{"text":"are you taking about the mutex or the sum variable?","width":253},{"text":"so in the - we had the code before","width":398},{"text":"ok, so the code, the code as written right now allows one thread to work through the whole for loop","width":447},{"text":"and the other thread is just spinning there waiting for the mutex to be unlocked before it can lock it","width":317},{"text":"so it doesn't do anything","width":458},{"text":"now you've got the case where each thread before they can increment the sum had to lock the mutex","width":382},{"text":"has to own that mutex","width":108}],
  // Part 3
  [{"text":"ok, only one of them will win that fight if they happen to try and lock at the same time","width":560},{"text":"one of them still wins and the other one has to wait","width":159},{"text":"if the other thread comes around and tries to lock it whilst you've got the lock it has to wait","width":508},{"text":"and it keeps going around, yeah, so you take the lock, you increment it and give the lock back","width":689},{"text":"goes around again, yes","width":233},{"text":"yes? [student question]","width":661},{"text":"yeah, it's not a very good program I agree","width":334},{"text":"correct, in some cases the only reason to do parallesism is simply to add it to your resume","width":352},{"text":"it may not actually give you a speed up","width":167},{"text":"and this is an example of that. it's just a silly little example","width":374},{"text":"we'll get to to more complicated examples soon in the course where we talk about multiple threads spawning to read and one thread wanting to write","width":658},{"text":"now, I'm showing you code but I want you to stop for a moment and think about this conceptually","width":353},{"text":"we're talking about threads, but this could apply to real life. this could even apply to processes","width":509},{"text":"now I'm not going to show you any code with processes but there are certainly times when multiple processes are asking the operating system to do things at the same time","width":591},{"text":"'hey I'd like to write to disk at the same time' sorry, I'm not going to let you do that","width":303},{"text":"'oh I want to open a file descriptor at the same time as someone else'","width":191},{"text":"now the operating system has to play these same kinds of tricks to make sure that the data structures are valid whenever a different process tries to read it","width":668},{"text":"so the operating system is full of code like this to make sure that we correctly work with our data structures even when different processes are trying to run, or use them or read them or write to them at the same time","width":1076},{"text":"right, so, the other thing we can do is talk about this pthread_mutex_lock()","width":318},{"text":"yes, it's just a little data structure here pthread_mutex_t but behind it there's additional resources","width":738},{"text":"this elusive thing I just called a spin lock is behind it","width":252},{"text":"and so we're tying up system resources in creating a mutex lock. not much, just a tiny bit","width":349},{"text":"so good C programs will free up a mutex when they've finished using it","width":761},{"text":"OK, so, down here we can call pthread_mutex_destroy() and pass in our mutex","width":952},{"text":"that doesn't do anything to the C variable, but it does say to the pthread library 'hey any resources you've connected to my little C variable can be released and reused'. a question? [student question]","width":1185},{"text":"aha, that's a great question","width":275},{"text":"if one thread locks a mutex, can another thread unlock it?","width":341},{"text":"no","width":106},{"text":"this is where the bathroom analaogy is great. if you lock the bathroom door you don't want anyone else unlocking it","width":430},{"text":"no, the idea of a pthread mutex is that you lock it and then a few nanoseconds later you've finished updating your data structure and then you're going to unlock it","width":706},{"text":"it's an error for another thread to actually try to unlock it","width":461},{"text":"also with a simple mutex like this unless we give it additional options it's an error to lock it twice","width":617},{"text":"if you try to do that the most likely thing to hapen is that the pthread library will say 'that mutex is locked, I'm just going to sit here until it's unlocked'","width":750},{"text":"but there's a problem becasue you locked it so it's never going to be unlocked, so now you've got code that's hit a deadlock again","width":461},{"text":"that this poor little thread is waiting for itself but it can't continue because it can't execute anymore code because it's waiting for the lock","width":420},{"text":"yes, so don't try to lock it twice","width":247},{"text":"you can give more arguments to pthread mutex locks to say add some more debugging and checking and it will complain to you if you do things like that","width":630},{"text":"but in practice we don't do that because a) it slows our mutex locks down and b) we should just write correct code anyway","width":482},{"text":"right, good luck with that","width":173},{"text":"yes? [student question]","width":321},{"text":"aha, ok, let's suppose the mutex is locked and you try to call destroy","width":389},{"text":"the answer is, don't do that","width":226},{"text":"it can lead to undefined behavior ","width":125},{"text":"the exciting thing about undefined behavior is that it's undefined! it can do anything! it could start world war three, it could change your facebook status to single","width":746},{"text":"ok that was a joke","width":203},{"text":"um, it could update your tinder profile, whatever","width":422},{"text":"it could - so, so - don't do this ","width":222},{"text":"these primatives are designed to be extremely high performance so as a result there's no safeguards so look back with nostalgia at Java where Java would say 'excuse me you've gone past the end of the array'","width":919},{"text":"I'm going to politely shut down your process and throw an exception","width":236},{"text":"this doens't exist anymore, you are ice climbing here and you'd better make sure that every line of code you write is correct","width":580},{"text":"so write code slowly, especially code that deals with locks","width":372},{"text":"especially code that deals with malloc and calloc and free","width":425},{"text":"and realize the lifetime of functions now can be very diferent","width":221},{"text":"so for example here's a student error I saw once where we had some memory ","width":573},{"text":"ok, so calloc sizeof an int, lets have enough memory for say a hundred of them. we'll pass this in as a parameter","width":777},{"text":"and then we'll free our memory","width":348},{"text":"not a good idea","width":370},{"text":"alright, because if my count gold function is now using that memory the code I've just written assumes that I can free it straight away","width":811},{"text":"well hold one, we don't know when countgold is going to end so just because we don't write anymore code in our main function that uses this memory doens't mean we can immediately free it","width":831},{"text":"no I've probably got another thread that's going to use that memory","width":224},{"text":"so now we have to think of the lifetime of our threads as well and how long their going to run","width":444},{"text":"so like I said this is like ice climbing, you do it carefully and think about each line of code and the lifetime of your data structures and whether they - what happens when two threads try to work on them at the same time","width":970},{"text":"alright, any questions about mutex locks?","width":387},{"text":"ok, so, I'll just reiterate the main points again","width":311},{"text":"they're not magic","width":119},{"text":"they're just little loops","width":148},{"text":"a pthread lock is basically just a little loop until that lock is available","width":484},{"text":"so it's up to you to use them as such","width":297}],
  // Part 4
  [{"text":"yes, if you had two threads using two different pthread locks that doesn't help you at all","width":431},{"text":"you're going to protect some memory use the same lock to protect that memory everywhere you access that memory","width":758},{"text":"right, are you ready for slide two?","width":225},{"text":"k, slide two","width":842},{"text":"yes, in todays lecture I'm not just giving you one synchronization primitive, but you get two synchronization primitives yours for just 19.95","width":619},{"text":"yes, so we're going to talk about counting semaphores","width":325},{"text":"here's an idea","width":207},{"text":"mutexes are a little constrictive, right?","width":180},{"text":"first of all I can only have a lock and unlock from the same thread","width":353},{"text":"and they don't have any internal state other than whether it just locked or not","width":491},{"text":"so sometimes we want something which is a bit more general and this is where a counting semaphore is very useful because it has the idea of a count","width":851},{"text":"and everything is happy providing that count is at least one","width":503},{"text":"but where we get down to zero or lower it stops","width":553},{"text":"it doesn't let you reduce the count ","width":222},{"text":"so it behaves like a resource counter","width":222},{"text":"the integer that we're going to put inside this counting semaphore","width":216},{"text":"and if you try to reduce the count you can't, you have to wait","width":832},{"text":"so I have a little example ","width":951},{"text":"so what's the code look like in terms of the counting semaphores?","width":200},{"text":"well what you'll see is this sem_post and sem_wait","width":562},{"text":"and fundamentally what they do is they increment or decrement the count inside the semaphore","width":478},{"text":"you never see the count directly","width":317},{"text":"and in fact it's quite common to increment and decrement - sorry it's quite common to set the initial value as say zero or one","width":1024},{"text":"so imagine a pizza box with slices of pizza in it","width":341},{"text":"and anyone, any thread can come up and say 'yes, I'd like to eat a slice'","width":443},{"text":"unlike the counting gold code I gave you, I guarantee you that each person will get a slice","width":835},{"text":"and we'll keep track of the number of slices in each pizza box","width":286},{"text":"so you can come up and eat a slice of pizza","width":291},{"text":"if you try to eat the slice of pizza and there's no pizza left, you wait","width":497},{"text":"here's the nice thing about semaphores that you don't twiddle your thumbs","width":207},{"text":"no, your thread is put on suspended animation, you're not going to use up any CPU time","width":378},{"text":"so if you want pizza and you ask for pizza and there's no pizza left, I get to freeze ray you and you're not even conscious of the fact that you've paused, that you're stuck","width":943},{"text":"now, is this the end of the world for you? no because here's the good news","width":272},{"text":"other threads may come along and put pizza back inside the box","width":371},{"text":"they can increment the count","width":222},{"text":"when they do that I can wake you up and say 'hey guess what? there's pizza now!'","width":315},{"text":"and you say 'oh thank you very much!' and take your pizza slice and carry on your way","width":244},{"text":"right, so this little analogy is what these sem_wait() and sem_post() calls do","width":414},{"text":"so how do we use a counting semaphore?","width":342},{"text":"here's the basic idea, we're going to say init and we want to say how many slices of pizza do we want inside of our box our what's the intial value","width":445},{"text":"so for example zero might be a common idea or we might say actually I want say three slices of pizza","width":744},{"text":"and then we might call wait","width":212},{"text":"I'm decrementing those counters, if there happens to be pizza inside the box, if there happens to be a non-zero value inside my counting semaphore these can return immediately","width":912},{"text":"OK, so I can call wait three times and they would immediately continue","width":638},{"text":"but if you call wait a fourth time","width":412},{"text":"your thread gets stuck inside the wait call","width":297},{"text":"doesn't need to use any CPU for this because your operating system is now going to take control of that thread and say 'I\"m sorry, you cannot proceed, there's no pizza left'","width":688},{"text":"ok, the good news is that on another thread we can call post","width":873},{"text":"post does not block, post will return immediately","width":242},{"text":"but post is the plus one effect, it says I want to actually increment the number of pizza slices inside this counting semaphore","width":945},{"text":"so when you do that anybody waiting to eat a slice of pizza can now continue, they will decrement the count themselves and continue","width":666},{"text":"we're going to use this counting semaphore for some more advanced examples, but one thing I want to show you or one thing you should notice is the way you post now they, they don't need to be inside the same thread. they could be, but they don't have to be","width":1442},{"text":"right, questions about counting semaphores? yes? [student question]","width":763},{"text":"ok, right, so, let's imagine you've got any empty pizza box","width":220},{"text":"two threads walk up and say I'd like to split a slice of pizza. we've put them in a state of suspended animation and then you walk up and you call post on this pizza box","width":705},{"text":"here's what's going to hapen","width":36},{"text":"first of all you get to walk away straight away, you can carry on whatever you were doing","width":256},{"text":"one of the two threads that were waiting will win, ok?","width":383},{"text":"one of them will get to return from their wait call","width":410},{"text":"now of course, what's left inside the pizza? because you posted but another thread immediately waited on that and stole that slice of pizza","width":504},{"text":"so the count is still zero, so any other threads that walk up and try to eat pizza, theres nothing left in the box","width":336},{"text":"but we've released one of those threads","width":132}],
  // Part 5
  [{"text":"[nothing]","width":784},{"text":"yes?","width":250},{"text":"correct, it's not necessarily like a queue","width":228},{"text":"it's actually operating system dependant","width":129},{"text":"we can give hints to the system as to how fair it should be","width":241},{"text":"for example, you might say that the thread that's been waiting the longest should have access to the pizza, that seems pretty fair to me","width":577},{"text":"but actually we have different definitions of fairness","width":370},{"text":"for example, the surgeon that is waiting to eat the pizza has a higher priority than the non-surgeon","width":498},{"text":"so we can actually assign different different priorities to our threads","width":234},{"text":"but that's some more advanced stuff that we don't need to worry about for today. for now just assume that you don't control it, the operating system controls who gets to eat the slice of pizza","width":634},{"text":"I don't know about you, but I'm going to be pretty hungry after this lecture","width":541},{"text":"so, yes?","width":416},{"text":"haha, great question! can you use this to implement lock? that's such a great question, I was about to ask it to!","width":434},{"text":"can we use a counting a semphore to implement a lock, a mutex lock? in other words, if I hadn't told you about the mutex lock, could you do it with a counting semaphore?","width":985},{"text":"that's true, yes, so counting semaphores are more versatile in that sense","width":272},{"text":"but in terms of the counting gold example I showed you at the beginning of this lecture could you do it using a counting semaphore?","width":670},{"text":"well the answer is yes","width":117},{"text":"my next question to you though is what should be the initial value of the counting semaphore?","width":679},{"text":"so if we were to go back to our code here","width":457},{"text":"and we didn't want to use lock and unlock, but we wanted to replace this with a counting semaphore","width":576},{"text":"ok, so, before entering our critical section we should try to take a pizza slice, we want to grab a slice of pizza","width":903},{"text":"ok, how do I do that?","width":140},{"text":"I'm going to call sem_wait() on my counting semaphore","width":400},{"text":"afterwards I can give back the slice of pizza","width":484},{"text":"yeah, sem_post()","width":691},{"text":"so how does that work now?","width":133},{"text":"if I have two threads trying to call sem_wait() at any one time I just need to make sure one of them wins","width":589},{"text":"so therefore how many slices should I put in the pizza box at the beginning? ","width":262},{"text":"just one! yes, so one thread get's a slice of pizza and can continue","width":444},{"text":"if I put in zero slices of pizza when I initialized my program what would happen?","width":486},{"text":"deadlock, yeah! no one gets to continue","width":268},{"text":"if I put in two slices of pizza or more I have a race condition again","width":640},{"text":"now I've let two threads continue when in fact I only ever wanted one thread inside my critical section","width":363},{"text":"if I'd put in two slices of pizza then two threads would've been able to proceed past that sem_wait() at the same time","width":471},{"text":"and that as we say lead to data corruption","width":497},{"text":"ok, so I think I have my sem_wait","width":559},{"text":"man page search","width":673},{"text":"so, when you initialize a semaphore the last thing you're going to pass in is it's initial value, in other words the number of pizza slices inside your counting semaphore","width":1396},{"text":"questions?","width":331},{"text":"so one of the powers of the counting semaphore is that you can call sem_wait() and sem_post from arbitrary threads","width":523},{"text":"and we'll see that when we want to make a simple queue or stack work with multi-threaded code","width":576},{"text":"now, the queues and stacks that you've made in past classes did things like 'oh look I've ran out of space, I know iI'll just allocate some more memory and I'll make my list or linked list longer'","width":809},{"text":"I'll double the number of spaces","width":227},{"text":"we can do better, what we can do is say I will stop thread from putting anything else into my data structure","width":809},{"text":"I can pause it because when it calls sem_wait() we know that it's going to be put on ice","width":464},{"text":"so it's unable to continue, it's unable to put anything else into my data structure until the space","width":426},{"text":"so now I can think of my processing in terms of pipes","width":360},{"text":"and I don't have to have an infinite amount of memory if part of my computation is generating results faster than the rest of my computational process","width":700}],
  // Part 6
  [{"text":"so I can say to a data structure given the next item, if the data structure's empty that call can just block and it can block until there's data to be retrieved","width":1113},{"text":"so these become very powerful primitives in multi-threaded code","width":329},{"text":"and by the way you can use semaphores as well to even work with multiple processes, but let's not worry about that today","width":763},{"text":"still I want to show you this little example here where I'm going to use sempahores with signals","width":787},{"text":"now a quick comment, semaphores don't work in mac os x","width":386},{"text":"so if you happen to have an apple machine in front of you please go intern at Apple and fix this","width":652},{"text":"don't worry, we'll work at how to get around that in a different lecture, but you can check to see if it works by looking at the return value of sem_init()","width":612},{"text":"so remember typical posix calls return -1 if they fail","width":213},{"text":"so it's a good idea to find out early that our semaphore failed instead of just carrying on and assuming it wasn't a problem","width":682},{"text":"so I want to show you a common way of using semaphores, and that's this","width":260},{"text":"let's have a thread that's going to do some clean up for us","width":309},{"text":"and the first thing this thread does is call sem_wait()","width":566},{"text":"alright, so I've got a little method here called sing song","width":247},{"text":"and the clean up is going to do sing 'yo ho ho ho a pirates life for me!'","width":455},{"text":"which you can imagine in say your java virtual machine there's a whole lot of clean up you might want to do before it exits","width":501},{"text":"and so this is a perfect example of how we can use a semaphore","width":182},{"text":"we're going to call sem_wait() which means this thread blocks, which means this this thread cannot continue because there's nothing in the pizza box right now","width":738},{"text":"now, I'm going to set up a signal handler so that when I press ctrl-c I call my little handler","width":750},{"text":"here's my handler","width":121},{"text":"so when I press ctrl-c I call sem_post()","width":334},{"text":"hold on a moment, why couldn't you've just printed 'yo ho ho ho a pirates life to me' directly from my signal handler?","width":644},{"text":"and the reason is because printf() might actually allocate some memory and the number of functions you can call from the signal handler is actually quite small","width":800},{"text":"sem_post happens to be one of the few functions that you're allowed to call from within a signal handler, printf() is not","width":702},{"text":"why? because there could be race condition","width":205},{"text":"it could be that malloc is being called from somewhere else in our code and the internal data structrues may not be correct, it may not be ready for another malloc call to run at the same time","width":1159},{"text":"so that's our trick, right, inside the handler we put an extra slice of pizza inside our counting semaphore","width":473},{"text":"we increment the count from zero to one and in doing so and a moment later sem_wait() can return","width":445},{"text":"at last that thread can eat! at last it can take a slice of pizza","width":595},{"text":"alright, so, let's run this","width":489},{"text":"so, you can see I'm using gcc. you need to give the option -pthread to say include the pthread support and because I didn't specify an output file it's just compiled to a.out","width":815},{"text":"so let's run this","width":277},{"text":"nothing happens of course until I try to press ctrl-c in which case it now prints 'yo ho ho ho a pirates life for me!'","width":502},{"text":"we caused the signal handler to run which posted the semaphore which let our other thread go","width":488}],

  // Start Lecture Video 9
  // Part 0
  [{"text":"[pause]","width":4520},{"text":"okay good morning and welcome to a very cozy edition of CS241","width":415},{"text":"it's eleven o'clock according to siebel 1404","width":191},{"text":"so let's get started","width":50},{"text":"here's what we're going to do today","width":59},{"text":"we're going to look at something called the critical section problem","width":226},{"text":"this is a fundamental idea of how we cope with doing two things at the same time","width":495},{"text":"or to be precise, how do we stop two things from happening at the same time","width":290},{"text":"we played around last lecture with counting gold remember? ","width":288},{"text":"and we saw that if we let two threads access that global variable","width":296},{"text":"then our count will be wrong","width":190},{"text":"and so our messing around reading or writing that piece of data we solve the problem via putting a mutex lock around it","width":658},{"text":"and we said okay right but if we do that then only one thread can continue and change that variable","width":404},{"text":"and the other one has to wait","width":111},{"text":"so what we did is we identified a critical section of our code","width":292},{"text":"where only one thread or one process can manipulate that memory at a time","width":409},{"text":"so what we're going to do now is step back from thinking about mutexes and locks and think about it in terms of some pseudocode and also think about what happens might you implement say mutex lock and mutex unlock","width":853},{"text":"and that is what we're going to do","width":110},{"text":"right so here we go","width":160},{"text":"it turns out for example that someone forgot to implement mutex lock and unlock","width":464},{"text":"and so, here's my idea of how we could actually implement those two functions","width":558},{"text":"okay so remember the game here is that if two threads called lock only one of them should win","width":558},{"text":"and the other one has to wait","width":153},{"text":"it's the you know any one person in the bathroom at a time type of rule here","width":231},{"text":"so how's the code work?","width":197},{"text":"right so when you call it you pass in a pointer to this mutex object inside that data structure I've got something called lock","width":539},{"text":"which can just be an int","width":164},{"text":"so if someone else has already entered, in other words, if they have already set the lock","width":310},{"text":"then my code does nothing","width":182},{"text":"it just goes around and says okay is it unlocked now is it unlocked now is it unlocked now is it unlocked now?","width":393},{"text":"so it's going to busy wait, it's going to just keep testing that variable","width":345},{"text":"once it's unlocked, my little thread is going to say okay great","width":350},{"text":"now I can set the lock","width":294},{"text":"that means if any other thread at this point tries to lock it, they are going to have to wait","width":294},{"text":"they are going to be inside that busy loop because I still have the lock","width":258},{"text":"and of course eventually when my code finishes I can then just immediately set it back to zero","width":368},{"text":"I don't need to have any loops here, I know that I'm the only thread that could of set this lock","width":407},{"text":"so the code is simple, just unlock the door and walk out","width":309},{"text":"right so that's my first attempt at protecting my critical code, my critical section","width":522},{"text":"so that's my first implementation of how lock and unlock might work","width":336},{"text":"is it any good though?","width":112},{"text":"will it work?","width":87},{"text":"perhaps you and your neighbor can figure out why this proposed code is actually not sufficient ","width":603},{"text":"what race conditions could you see? what would happen if two threads happen to call it at about the same time?","width":392},{"text":"so here's what we have to do, you have to look at that code with two parts of your brain","width":241},{"text":"and imagine two different threads were running the same code","width":335},{"text":"what could happen that would be bad?","width":217},{"text":"[pause]","width":5190},{"text":"okay so what have we discovered?","width":210},{"text":"is this implementation any good?","width":454},{"text":"what do you think?","width":131},{"text":"no, why not?","width":644},{"text":"no okay too scary, alright","width":292},{"text":"so here's our problem, our lock needs a lock","width":206},{"text":"there's a potential race condition here","width":106},{"text":"what would happen if two threads called lock at about the same time","width":258},{"text":"both of them would see that the door is unlocked","width":255},{"text":"yes? both of them would see that the variable is zero. great they say, I don't need to be inside my while loop anymore and they continue","width":452},{"text":"at the same time","width":83},{"text":"so now they both set the lock equal to one and they both return, they both continue","width":335},{"text":"so both of them, both threads are now able to enter the critical section","width":364},{"text":"which is precisely what we didn't want","width":168},{"text":"we wanted to make sure that only one thread at a time could escape from our lock","width":809},{"text":"does that make sense?","width":199},{"text":"because this is the easy one, this lecture is designed to blow your mind","width":634},{"text":"and to make new connections that didn't exist","width":155},{"text":"this stuff is really hard to think about if you have a human brain","width":367}],
  // Part 1
  [{"text":"so your homework for this week is to go and upgrade please","width":284},{"text":"go and get one of those uiuc brains please","width":161},{"text":"um because this stuff is really hard, we're looking at one piece of code but thinking about it for what could happen when two different threads happen at the same time","width":454},{"text":"and you're thinking about the sad days, your thinking about what could possibly go wrong","width":402},{"text":"we're not thinking about oh my code works great, it's no no let's look at this really really critically","width":414},{"text":"yes so our problem would be if two threads came along called lock at the same time and they both read a value of zero for the lock value","width":553},{"text":"before either of them had a chance to change it to one","width":279},{"text":"not very likely but that's not good enough, we're trying to make code that actually works","width":315},{"text":"that doesn't make us lose money or corrupt our data structure","width":332},{"text":"at the end there can only be one thread that gets through this","width":312},{"text":"alright I talk about threads because that's how we program this stuff","width":235},{"text":"but if you read the historic literature, it talks about processes that's because we're thinking about this actually in a more abstract sense","width":550},{"text":"not about pthreads and c structures but just how do we actually do this so that it works","width":523},{"text":"alright so this is broken, the only way that we could have made this code work is if we had somehow done all of this as kind of one operation","width":628},{"text":"but we can't do that","width":61},{"text":"in c","width":47},{"text":"you can't say okay I'm the gorilla, whilst I look at this lock, don't let anyone else look at it or touch it, alright?","width":448},{"text":"how do I do that? easy, make a lock, oh wait that's what I'm trying to do right?","width":203},{"text":"so that's not going to work for us","width":138},{"text":"okay so that failed, what we failed at was mutual exclusion","width":583},{"text":"we only want one thread or process if you're talking historically inside our critical section","width":1154},{"text":"so let's try a different solution, let's try our first real candidate solution","width":499},{"text":"we'll have um. we'll agree on the following","width":159},{"text":"now before you panic, the code written out here, the pseudocode is the same as the pseudocode on the right hand side","width":430},{"text":"the reason we wrote it twice is because I want you to think about two threads or two processes trying to execute this at the same time","width":439},{"text":"and see if we can actually kind of prevent bad things from happening","width":194},{"text":"so what we'll do is we'll have some flags","width":239},{"text":"we'll say look, I'm going to just wait until your flag is lowered","width":404},{"text":"and your thread will do the same","width":379},{"text":"so if I see that your flag is up, then I know that you are inside the critical section","width":752},{"text":"in which case I'm just going to wait","width":398},{"text":"once I decide that your flag is down, I'm going to raise my flag, I can do my stuff and then I'll lower my flag","width":435},{"text":"now we can say what happens if I have three or four or five or more threads in this, let's not","width":327},{"text":"let's just worry about what happens with just two threads or two processes trying to do that","width":314},{"text":"this is hard enough with just two","width":136},{"text":"alright so does this work, does this suffer from the same problem?","width":270},{"text":"or not?","width":66},{"text":"okay you decide and see if you can argue it with your neighbor","width":480},{"text":"[silence]","width":3168},{"text":"okay! so, does it work? yes it does great, end of lecture","width":321},{"text":"no of course it doesn't work","width":120},{"text":"right? so does it work? no! why not?","width":475},{"text":"let's hear from someone over here, yes","width":559},{"text":"they both could be waiting forever, uhhhhhhh, I think that might be hard, I think we can assume that their flags are initially down","width":801},{"text":"alright so how will they get to have both of them up?","width":420},{"text":"come on keep going","width":795},{"text":"alright so we have a potential problem right? yes that both people or both threads could see each other and say oh look his flag is down","width":731},{"text":"great I can continue, at which point we raise our flag and say alright off I go","width":309},{"text":"and they do this at exactly the same time, or about the same time","width":540},{"text":"so hey i'm going to wait until your flag is lowered and I'm going to wait until your flag is lowered","width":344},{"text":"they check each others flags they are both low so they can both proceed","width":302},{"text":"they raise their flags to say okay I'm going in","width":164},{"text":"but it's too late, they've both gotten past this little loop!","width":189},{"text":"so they both go into the critical section so what we have failed on the mutual exclusion principle game again","width":700},{"text":"we did not get mutual exclusion","width":123},{"text":"we wanted one person inside our critical section at a time thank you very much and we failed","width":511},{"text":"so when we're looking at these solutions, we've got to evaluate them a little bit carefully because it can happen more than once","width":438},{"text":"you could imagine you're going to wrap this around some data structure update like hey I want to add something to my linked list","width":344},{"text":"or add something to my hash","width":109},{"text":"and I don't know where I'm going to do it but I do know I'm going to say insert things into my hash or read my hash multiple times","width":647},{"text":"right so, let's be sneaky, let's be guided by what we did before","width":324},{"text":"and this time we're going to raise our flag first","width":266},{"text":"that way hopefully, we can stop this mutual exclusion problem","width":280},{"text":"okay what's wrong with this solution, right so again the code here is the same as this code here","width":351},{"text":"you could just imagine that this is person A and person B or thread A and thread B","width":252},{"text":"what happens now? what could possibly go wrong?","width":224},{"text":"again take a moment to argue this with your neighbor and even if you don't agree with them perhaps you can persuade them that you're right","width":512},{"text":"[silence]","width":1920}],
  // Part 2
  [{"text":"okay sounds like we got a little situation over here okay what have we got?","width":537},{"text":"you put your flag down. no, you put your flag down! it's a Mexican standoff with flags! It's a Mexican standoff with flags! okay...","width":601},{"text":"uh so what do we mean by that? what could possibly go wrong?","width":485},{"text":"okay right yes exactly, both of them could raise their flag at the same time","width":342},{"text":"not very likely I agree, but it could happen right?","width":189},{"text":"both of them could raise their flags first before continuing","width":218},{"text":"and then they check each others' flags ","width":93},{"text":"oh look over there that other thread has their flag raised, i better wait","width":425},{"text":"and they both do that","width":132},{"text":"both threads or both people now just are stuck forever waiting for the other thread to lower their flag","width":548},{"text":"this would be an oops moment right?","width":118},{"text":"so clearly this is not going to work for us","width":158},{"text":"this would not be a good implementation for mutex lock and unlock","width":453},{"text":"we can get stuck","width":267},{"text":"what have we got?","width":225},{"text":"so this will become deadlocked","width":518},{"text":"we can't make any progress","width":508},{"text":"right so let's try this one. alright that um","width":475},{"text":"this time we're going to have not some flags because they don't seem to be working for us","width":391},{"text":"let's have the british solution we'll say no after you, okay?","width":519},{"text":"so we're going to say something like look we'll have this shared variable so turned is shared between us","width":525},{"text":"so we can take turns","width":380},{"text":"and i'm just going to wait until turn is set to my id","width":212},{"text":"and then do the critical section stuff","width":162},{"text":"and similarly you're going to do the same, you're going to check the shared variable that you share between us","width":263},{"text":"so there's not two turn variables there's just one in global memory somewhere","width":213},{"text":"and see if it's set to my id","width":226},{"text":"and I'm going to wait until it is okay and when it is I can do my critical section stuff","width":283},{"text":"and then i'm going to say okay it's your turn","width":255},{"text":"right what do you think of that solution","width":231},{"text":"is it any good","width":277},{"text":"yeah we're just considering this for just two threads","width":186},{"text":"right we'll worry about generalizing this to more than two later","width":575},{"text":"[pause]","width":1986},{"text":"okay so could this lead to say data corruption?","width":278},{"text":"could we have two threads inside the critical section at the same time","width":529},{"text":"no, right it's impossible to continue unless you have the golden chalice ","width":333},{"text":"unless the turn variable has been given to you","width":223},{"text":"so hurray we have mutual exclusion again","width":428},{"text":"it's satisfied!","width":144},{"text":"alright but our critical section now is only going to have one thread at a time inside the critical part of the code","width":405},{"text":"two threads are not going to try and update our goal value or change the data structure at the same time or try to read it whilst another one is writing it. fantastic! we're done.","width":698},{"text":"but what's wrong with our solution?","width":325},{"text":"yes?","width":198},{"text":"okay it's not going to work if we add more threads to it uh but it is something that will run with just two threads","width":764},{"text":"uh if they try and update at the same time, let's have a look, so we'll let the first one go through and then a second one comes through","width":570},{"text":"but you're along the right lines, it's like what will happen if this thread actually wants to continue","width":449},{"text":"it can't! it has to wait for the first thread to actually do something","width":223},{"text":"yes, they become rate locked","width":137},{"text":"it's as if you and I have to use the bathroom at exactly the same rate, no it's your turn... oh i have to wait","width":394},{"text":"I have to wait to use the bathroom... no one's in it","width":177},{"text":"yes? but I still have to wait for you to use it","width":155},{"text":"there is something broken with this picture, yes?","width":289},{"text":"so what we have is a problem","width":321},{"text":"of uh, let's see I think...","width":335},{"text":"uhhh I have to look at the definitions, just a moment","width":407},{"text":"oh yes, progress","width":434},{"text":"there's no progress","width":110},{"text":"if no one's inside the critical section, I should be able to enter it","width":803},{"text":"so in fact there's three desirable properties that we need here","width":279},{"text":"and we've touched on two of them","width":147},{"text":"so what we'd like in our solutions is mutual exclusion, that one's pretty obvious yeah? we only want one thread or one process to be able to continue","width":871},{"text":"into the critical section","width":358},{"text":"the next one is progress","width":614},{"text":"so if there, I'll write it in terms of threads, if there are no threads inside the critical section we should be able to enter immediately","width":2880},{"text":"or with the bathoom analogy, if there's no one in there I should be able to just use it","width":306},{"text":"I don't want to have to wait for you to give me a chain of keys each time, right?","width":290},{"text":"the resource is not being used, I should be able to use it","width":293},{"text":"the last one is something called bounded wait","width":259},{"text":"and I'm going to give a non mathematical definition of bounded wait, there's more technical definitions","width":361},{"text":"that you might use in later courses","width":484},{"text":"that I should be able to get into the thread... the thread can enter the critical section in a finite amount of time","width":2048}],
  // Part 3
  [{"text":"okay so that's a little of loose definition","width":355},{"text":"other definitions talk about the number of other waiting processes or number of waiting threads","width":340},{"text":"that I don't want a little four year old running between my legs running into the bathroom and getting there before me","width":437},{"text":"that's going to be really annoying right?","width":108},{"text":"they should stand in line as well. There should be some kind of principle of fairness behind this","width":323},{"text":"that it shouldn't be the case that I'm just stuck there waiting for an infinite number of other processes to finish","width":396},{"text":"and they always get in front of me, they manage to somehow jump the queue, that's just no fair","width":219},{"text":"so we have this idea of bounded wait. yes?","width":426},{"text":"why does candidate three not have progress? because suppose you want to update it faster than the other thread wants to enter this critical section","width":776},{"text":"so we're stuck there waiting for the turn, waiting for the golden chalice to be given to you","width":493},{"text":"now, maybe the other thread may eventually call their code","width":375},{"text":"and update the critical section, do something inside the critical section","width":228},{"text":"but until they do so, you're just stuck there waiting","width":308},{"text":"so you could imagine I've got a thread that's writing into a an associative map ","width":529},{"text":"you've got a thread that's reading from it","width":133},{"text":"why should your reads have to wait for a write to come in?","width":280},{"text":"if no one's modifying the data structure, you should be able to immediately get in there and use it","width":861},{"text":"so this is the fact that you might want to say come in here twice as fast as this other thread is going to run, yes?","width":1098},{"text":"yes, it's not efficient, but worse you don't know when that other thread is going to make that call","width":581},{"text":"so imagine you had one thread that it wants to walk through a linkedlist structure and another thread that might be changing that linkedlist structure","width":628},{"text":"you don't want to modify it whilst one is walking through the links okay?","width":945},{"text":"you want to get in there eventually, you don't mind waiting but it shouldn't be an infinite amount of time","width":364},{"text":"right, it's not fair if another thread continually just jumps in front of you and you never get a chance to use the resource for example","width":646},{"text":"right, so I've littered this lecture with trying to make concrete examples of why we care about the critical section in terms of accessing data structures","width":652},{"text":"but these are the three formal thing that we care about for solving the critical section problem. So if you care about reading the literature about this..","width":614},{"text":"these are the properties in which we judge our success or not of our proposed algorithms","width":493},{"text":"so let's take a look at another one","width":308},{"text":"here we go","width":372},{"text":"so a reminder that we're not going to be executing this code all the time","width":231},{"text":"but the threads are going to execute this code more than once","width":305},{"text":"so we do other stuff and then repeat sometime in the future","width":447},{"text":"so now it's your turn","width":180},{"text":"take a look at this code and decide how could it possibly go wrong? This is tricky","width":695},{"text":"[silence]","width":14400}],
  // Part 4
  [{"text":"okay let me tell you how hard this example is","width":414},{"text":"for giggles, when I wrote this little problem I challenged a faculty member","width":382},{"text":"assistant programming senior professor five minutes to find the problem with this","width":477},{"text":"and after three minutes neither of us had actually noticed the error yet","width":440},{"text":"so I'm pretty sure there's a problem with this but it took us more than 3 minutes to see it","width":286},{"text":"I'll give you a hint though, it does not satisfy mutual exclusion","width":385},{"text":"the question is how could that happen then?","width":397},{"text":"[silence]","width":12397},{"text":"okay, so, before we talk about this code in specifics, I find that it's absolutely fascinating the fact that we can write something that just has a couple of booleans, just flags, simple flags [something]","width":803},{"text":"and a simple switch variable and a little boolean that says your turn or my turn","width":287},{"text":"and we've built something that couldn't be much more complicated and it completely fails to be handled by our poor little brain","width":602},{"text":"we have a really really hard analyzing this really really simple code","width":289},{"text":"for spotting it for synchronization problems","width":209},{"text":"and concurrency bugs","width":135},{"text":"so, anyways, let's see if we can kind of walk through this and do it carefully","width":364},{"text":"let's suppose for example right now that only one thread kept on using the resource, use this critical section here","width":506},{"text":"can we have progress? right so if we only have one raise my flag!","width":520},{"text":"wooohooo, if your flag is raised, it's not, great! I don't need to wait, I can continue to my critical section and I'm going to set turn to you","width":636},{"text":"okay, do I have a turn variable? yes here's my turn, wooo!","width":290},{"text":"right and lower my flag","width":107},{"text":"okay right a millisecond later, I want to do some more stuff for this critical section so what do I do?","width":273},{"text":"raise my flag! is your flag raised? no [something over there] right great","width":240},{"text":"so I don't need to wait, I can enter my critical section, I'm going to again set the turn to you and lower my flag","width":412},{"text":"so that seems to work, I'm able to enter the critical section if no one else is using it so progress is good","width":558},{"text":"right mutual exclusion let's see if we can argue that it works and then we'll argue that it doesn't","width":495},{"text":"right so raise my flag and is your flag raised? then if it's not I'm going to continue to the critical section","width":659},{"text":"meanwhile another thread comes along. alright so","width":357},{"text":"[noise]","width":260},{"text":"there's my flag, right. another thread comes along and says oh um I see your flag is raised","width":794},{"text":"then I'm going to just wait until it's my turn","width":209},{"text":"eventually that other code finishes and passes the golden chalice, this turn, to me!","width":504},{"text":"so now I can continue","width":165},{"text":"but they are only going to pass the turn variable to me when it finished, so the code works! right?","width":508},{"text":"oh what happy little brains we have","width":208},{"text":"because we're so happy excited to see that our code works","width":206},{"text":"um, no, it doesn't work","width":249},{"text":"the way to analyze this is to say okay I've got this turn variable so I actually have to do this analysis twice","width":305},{"text":"I have to say suppose the turn variable was set to the first thread before this stuff started","width":319},{"text":"or suppose the turn variable was set to the other thread","width":310},{"text":"before this mess continued","width":121},{"text":"and if you do that, then it is possible to break mutual exclusion here's how then","width":531},{"text":"first of all we'll set turn equal to two","width":233},{"text":"so there was some prior instance when we'd run through this code and turn ended up being 2","width":320}],
  // Part 5
  [{"text":"right that this is the solution then","width":196},{"text":"let's um, look to see what order things happen","width":290},{"text":"okay so I'm going to raise my flag and then I'm going to see if your flag is raised","width":543},{"text":"it's not, great! I can go into the critical section","width":501},{"text":"then the other thread comes along and says okay raise my flag","width":500},{"text":"if your flag raised? yes it is","width":143},{"text":"okay wait until it is my turn","width":192},{"text":"oh look at that, it is my turn","width":377},{"text":"so, enter the critical section","width":213},{"text":"three four five six, whoops","width":611},{"text":"so, by trying to introduce this turn flag to ensure progress","width":298},{"text":"we broke it, we broke mutual exclusion","width":213},{"text":"we have a situation where because of the prior value of turn, our code allows one way for mutual exclusion to be broken","width":675},{"text":"don't feel too bad about spotting this, there have been peer reviewed published papers in major conferences, in major journals that failed to solve the critical section problem","width":699},{"text":"yet claimed they did","width":100},{"text":"so in trying to solve this, in trying to come up with algorithms that actually solve this","width":275},{"text":"it actually advanced the state of the art in terms of how do we analyze concurrency and how do we analyze programs that do two things at the same time","width":895},{"text":"right so this is broken, it failed to satisfy mutual exclusion","width":427},{"text":"alright then, here you go, what do you think of candidate 5?","width":906},{"text":"see how far you can get in five minutes for this one","width":353},{"text":"[silence]","width":13248}],
  // Part 6
  [{"text":"[silence]","width":476},{"text":"what's up?","width":151},{"text":"which one are you talking about?","width":143},{"text":"yes? mhmm. uh why is not your turn?","width":2109},{"text":"no there's just one variable, ok. correct.","width":850},{"text":"okay just to read this code, there's only one turn variable ","width":288},{"text":"so when it says turn to win it's still the same turn variable","width":650},{"text":"okay so what I asked you to do is actually impossible","width":251},{"text":"this is a solution to the critical section problem","width":248},{"text":"this was the first published solution by dekker","width":364},{"text":"so let's see if we can understand some of the logic behind this as to how it tries to work","width":325},{"text":"ok so first of all, before we do anything else, we raise our flag, we are kind of signaling intent","width":386},{"text":"okay, I want to be inside the critical section","width":256},{"text":"so think about this flag as an intent, I want to go","width":554},{"text":"so then we have this while flag is raised","width":146},{"text":"right didn't we have this at the beginning of the lecture?","width":138},{"text":"yes we did and we saw how we could run into a problem of deadlock where both of them were waiting for the other thread to lower their flag","width":736},{"text":"but of course it never happened because thread one was waiting for thread two and thread two was waiting for thread one","width":453},{"text":"so what we do is to have a little bit more of a complicated logic","width":392},{"text":"which is to have a standoff","width":229},{"text":"and one of us will win","width":190},{"text":"and we take it in turns to see who wins in this potential deadlock","width":408},{"text":"so that's the purpose of this, so if it's your turn to win, then I'm just going to lower my flag and wait while it's your turn","width":930},{"text":"in other words, you've won! you've won this competition. I'm going to let you go","width":504},{"text":"so at some point though, you're finished and you've set the turn back to me, you'll give me the golden chalice","width":463},{"text":"or the trump card if you like","width":157},{"text":"what do I do now? well I don't continue immediately. ","width":164},{"text":"instead, I play another game with you. i say okay I'm going to raise my flag, ","width":266},{"text":"I've got this intent again to go into the critical section. but I'm not going to go straight in","width":274},{"text":" I'm going to first see if your flag is raised","width":489},{"text":"so it's a bit like playing trumps except that we're going to take it in turns to see who wins","width":400},{"text":"if we do that, then we've solved the critical section problem","width":225},{"text":"namely that we have mutual exclusion only one thread or one process at a time can be inside the critical section","width":439},{"text":"we've got bounded wait, what do we mean by that? well a rough definition is that I only have to wait for a bounded amount of time","width":693},{"text":"a more precise definition is that I only have to wait for one other thread or process to enter the critical section and then its my go","width":637},{"text":"and we've got progress","width":136},{"text":"so if the other thread or process is not inside the critical section, I get to play immediately, I get to use the critical section, I get to execute that code","width":646},{"text":"it took many many years to come up with this solution and it took even more years, several decades before another solution was published, here it is","width":558},{"text":"between those times, there were many incorrect solutions published","width":563},{"text":"and so here is the last solution I'm going to show you today","width":311},{"text":"the original article from peterson ","width":446},{"text":"this might look like it was from the 1960s, in fact it was from 1981","width":442},{"text":"that's how long it took to find a simple solution to the critical section problem","width":308},{"text":"that's how poor our brains are at how to cope with multiple threads or multiple processes","width":450},{"text":"it's incredibly hard to reason about this stuff","width":255},{"text":"right, I'm not going to talk about this but I will say the following","width":340},{"text":"first of all every systems programmer knows of peterson and dekker in terms of the critical section problem","width":404},{"text":"it's the kind of thing that should roll off your tongue in an interview","width":164},{"text":"secondly, yes I may choose to add a multiple choice quiz question based on these two solutions","width":461},{"text":"for example, does this code... is this code dekker's solution? or is this code a version of peterson's solution","width":474},{"text":"thirdly, I may choose to make other code which fails and I'm going to ask you in an exam quiz to work out whether it fails mutual exclusion, progress or bounded wait","width":858},{"text":"and with that, that's the end of today's lecture, if you have questions for me please come down and see me! thank you very much","width":384}],

  // Start Lecture Video 10
  // Part 0
  [{"text":"[Om Monk Chant with Transcendental and Tibet Bells]","width":8314.181818246841},{"text":"so, what do we got. overhead.","width":781.1818182468414},{"text":"right so, here's our requirements that we'd like","width":228.18181824684143},{"text":"know that first of all, we only want one process or thread to be inside our critical section at a time","width":371.18181824684143},{"text":"what do we call that?","width":425.18181824684143},{"text":"mutual exclusion","width":227.18181824684143},{"text":"in other words, if you've taken cs241, I don't want to see you taking any other courses","width":416.18181824684143},{"text":"yes, your time is mine! said cs241","width":209.18181824684143},{"text":"right, what about this then? if waiting, then another process or thread (if you're talking about threads) can only enter the critical section a finite number of times","width":727.1818182468414},{"text":"what do we call that?","width":156.18181824684143},{"text":"this is a better definition of bounded wait","width":356.18181824684143},{"text":"if you're waiting to use the resource, if you're waiting to be inside the critical section","width":305.18181824684143},{"text":"it would be unfair if another thread just kept on jumping in front of you in front of the queue","width":274.18181824684143},{"text":"so we want a solution where eventually we get to go in","width":383.18181824684143},{"text":"alright and then if no other process is in the critical section then the process or thread can immediately enter the critical section","width":424.18181824684143},{"text":"our code should be efficient. it shouldn't have to pause. if there's no one inside the bathroom, I expect to use it straight away","width":457.18181824684143},{"text":"alright, so, what's that called?","width":179.18181824684143},{"text":"progress! yes.","width":82.18181824684143},{"text":"so those are our three desired properties that we're going to evaluate","width":439.18181824684143},{"text":"alright. now there's um, one more thing that I think","width":215.18181824684143},{"text":"that I should mention is that we're talking about pseudocode right now. but today, if you were to look inside say, mutex lock, and you were to drill down to find out exactly how it worked, you might discover that it uses something called the exchange instruction","width":1076.1818182468414},{"text":"so many processors today will implement either test&set or the exchange instruction","width":458.18181824684143},{"text":"what do you think the exchange instruction does?","width":243.18181824684143},{"text":"okay, it exchanges something, yes, very good, but what might it exchange?","width":573.1818182468414},{"text":"how about a value inside a register and the contents of memory","width":418.18181824684143},{"text":"so it swaps them","width":173.18181824684143},{"text":"but here's the critical part: is that it does this atomically. it does this in the guerilla fashion. it walks up and it exchanges your hats","width":762.1818182468414},{"text":"actually no, I'll take your cellphone, that's more valuable, right?","width":218.18181824684143},{"text":"for the microphone oh yeah","width":129.18181824684143},{"text":"and in doing so, no other CPU is allowed to interrupt that process","width":323.18181824684143},{"text":"it completes as one logical step. here you go, you can have your phone back","width":385.18181824684143},{"text":"so that way, we can actually use it to implement our mutex lock because only one thread will win","width":484.18181824684143},{"text":"we can make sure that only one thread gets to put a certain value inside it","width":492.18181824684143},{"text":"so, it's an atomic instruction, why is it useful? well, to implement locks!","width":646.1818182468414},{"text":"we don't have to worry about officially catered code down here and it works even if I got say more than two threads trying to compete to lock something","width":732.1818182468414},{"text":"okay, alright, next thing we're going to talk about is condition variables","width":463.18181824684143},{"text":"I'm going to introduce them now, we'll let that simmer in your brain and then the second half of the lecture we'll come back to them","width":509.18181824684143},{"text":"so like I said, this is the cool bit","width":222.18181824684143},{"text":"condition variables sound like they hold some sort of clever value","width":475.18181824684143},{"text":"they don't","width":147.18181824684143},{"text":"uh, their name actually is very good at confusing beginners","width":360.18181824684143},{"text":"the way to think about condition variables is that you can make your thread meditate","width":576.1818182468414},{"text":"what an exciting lecture isn't it? okay, right!","width":106.18181824684143},{"text":"so we can put a thread to sleep...","width":300.18181824684143},{"text":"and then....it will stay until another thread decides to wake it up. now, you don't need to actually scrumple up a piece of paper and throw it at the other thread","width":1171.1818182468414},{"text":"the system will do that for you","width":137.18181824684143},{"text":"you can just make a call, you can say \"hey, signal!\"","width":145.18181824684143},{"text":"and, at some point, you know that the meditating thread will be woken up by the system","width":633.1818182468414},{"text":"so it's a communication pattern. it's a way for one thread to wake up another","width":468.18181824684143},{"text":"so we can use this and we can use this so that our thread can wait until something is true, but we need to write that, so that's the idea of variable comes in.","width":728.1818182468414},{"text":"we are actually going to write a condition. a truth that we want to be true","width":293.18181824684143},{"text":"but, until that truth happens, until that test happens, no magic is going to happen. we're just going to write a little loop (a little white loop) until that truth has happened we're just going to put our thread into a meditative state","width":1060.1818182468414},{"text":"alright, that's the idea","width":131.18181824684143},{"text":"they're not very complicated. they're not fantastic and clever, they don't know what the condition is going to be. we're just going to write a little while loop that says \"ok, while there is no good coffee at bervandes, meditate\"","width":895.1818182468414},{"text":"it'll be a long time","width":192.18181824684143}],
  // Part 1
  [{"text":"alright, but at some point, we'll write another thread that says \"ok, guess what? I've delivered great coffee to bervandes, and you saw it, and you wake up your meditating monk, aka your thread\"","width":764.1818182468414},{"text":"at this point, the monk wake ups. okay, I better see if there's good coffee at bervandes now","width":446.18181824684143},{"text":"alright, now, there's a little gotcha here, which is that sometimes monks wake up by acident","width":473.18181824684143},{"text":"this is called a spurious wait","width":319.18181824684143},{"text":"in other words, we'd like our monks to meditate forever until we do the little tip symbol, yes? ding! wake up","width":497.18181824684143},{"text":"unfortunately, it's not a perfect system. they may wake up by accident. but that's okay, because we will write a little loop to say, \"okay! before you attempt to purchase any coffee, actually go and see if it's any good\"","width":770.1818182468414},{"text":"\"and if it isn't, guess what I'm going to ask you to do. go back to sleep. continue meditating\"","width":562.1818182468414},{"text":"alright. now, there's a little bit more to this course.","width":418.18181824684143},{"text":"for starters, I've suggested that you can signal a waiting monk. you can throw something at them","width":562.1818182468414},{"text":"turns out that actually normally you can use wake one monk","width":295.18181824684143},{"text":"you can get the largest gong you can buy ebay and bash it like hell","width":374.18181824684143},{"text":"wake up all of them","width":171.18181824684143},{"text":"because maybe you want to wake up a lot of monks","width":133.18181824684143},{"text":"so that's a design decision. we'll see how we can do that in a little bit","width":296.18181824684143},{"text":"alright so that's the beginning of condition variables","width":155.18181824684143},{"text":"we'll let that simmer into your brain","width":128.18181824684143},{"text":"we'll come back to that in the second half","width":365.18181824684143},{"text":"because right now, hahaha. I've got some more critical section problems for you to look at","width":658.1818182468414},{"text":"I've written four potential solutions to the critical section","width":402.18181824684143},{"text":"and remember, what are we trying to do here? well, I've got some code here (my critical section stuff) that's only going to work if I've got one thread or one process at a time inside that code","width":863.1818182468414},{"text":"so I want to make sure that if I happen to have two threads or two processes attempting to get there, that one of them will lose","width":464.18181824684143},{"text":"one of them will have to wait until the first one has finished","width":350.18181824684143},{"text":"and remember, all code runs more than once","width":137.18181824684143},{"text":"so you can think of the critical section, for example, as using a data structure or updating a data structure. you don't want these two things to happen at the same time.","width":728.1818182468414},{"text":"I'm not quite sure how often this code is going to be called.","width":231.18181824684143},{"text":"but we do have our three desired properties. we want mutual exclusion so only one thread or process can enter the critical section at a time, bounded wait, and progress","width":725.1818182468414},{"text":"so, I've got some problems here, and this is where your neighbor comes in, because I'm going to ask you to actually evaluate these in terms of those properties","width":650.1818182468414},{"text":"and see whether they are good solutions to the critical section problem or not","width":430.18181824684143},{"text":"and I'm going to come around and answer any questions you might have","width":192.18181824684143},{"text":"[long pause]","width":17721.18181824684}],
  // Part 2
  [{"text":"[long pause]","width":8823.181818246841},{"text":"okay so let's have a look at the first one","width":253.18181824684143},{"text":"we have a flag and in this case, our flag represents an intent to go into the critical section","width":447.18181824684143},{"text":"because inside this while loop, we actually may lower our flag. we actually may say \"yeah, well, I give up. it's your turn\"","width":678.1818182468414},{"text":"so if I see your flag is raised, then if the turn variable is set to you, then I'm just gonna say \"okay, actually I'll let you go ahead\"","width":644.1818182468414},{"text":"so I'll lower my flag. I know then, therefore, that the other thread gets to win!","width":323.18181824684143},{"text":"they see my flag has gone down so they can go into the critical section","width":355.18181824684143},{"text":"but they're not going to raise my flag","width":120.18181824684143},{"text":"so before going into the critical section, my flag will always be raised","width":291.18181824684143},{"text":"alright, now I go around again","width":117.18181824684143},{"text":"so, let's go around again","width":105.18181824684143},{"text":"now, if it turns out that I've actually had to wait like I just did, then this time, it's my turn to win.","width":533.1818182468414},{"text":"so I'm not going to back down the second time. I am just going to now keep waiting until your flag goes down","width":612.1818182468414},{"text":"and because the turn variable is set to me, then I win this round","width":328.18181824684143},{"text":"I win this second time","width":92.18181824684143},{"text":"so I know that I can continue at some point","width":272.18181824684143},{"text":"at some point your flag will go down","width":256.18181824684143},{"text":"either because you've finished this other critical section or you've deferred to me","width":367.18181824684143},{"text":"so in fact, what we're looking at here is dekker's solution. so this was the first solution to the critical section problem","width":914.1818182468414},{"text":"and we're looking at, of course, the version which works for two threads","width":273.18181824684143},{"text":"but I hope you can see that the flag represents kind of an intent to be inside the critical section","width":622.1818182468414},{"text":"right then! so what about version two? yeah, we're raising a flag and this time, it's a kind of \"no no no, after you\"","width":612.1818182468414},{"text":"so now we have a little loop that we keep going around. if your flag is raised or its your turn, I'm just going to wait","width":516.1818182468414},{"text":"what do people think about this? candidate solution?","width":449.18181824684143},{"text":"no progress? no mutual exclusion? no bounded wait?","width":442.18181824684143},{"text":"no progress did someone say?","width":184.18181824684143},{"text":"alright so let's have a look. so, if I set the turn to you, and then I'm going to wait if its your turn","width":483.18181824684143},{"text":"well that's, that's like walking to the resource and just standing there because \"no, I want someone else to go in front of me. I'm scared\"","width":545.1818182468414},{"text":"I should be able to use the resource if its right there and no one else is using it. I want to have that piece of cake. I want to be able to enter the critical section","width":427.18181824684143},{"text":"so we've already identified that it fails","width":138.18181824684143},{"text":"at least in terms of progress","width":187.18181824684143},{"text":"there's no progress here","width":118.18181824684143},{"text":"it gets stuck waiting for the other thread to come along and kick the turn variable back to the first thread or first process","width":531.1818182468414},{"text":"so, we've found a problem here: no progress","width":608.1818182468414},{"text":"alright, um, what about the third one? I'm gonna raise my flag, this time I'm being selfish, hey! it's my turn!","width":779.1818182468414},{"text":"this is the toddler version of the critical section solution","width":267.18181824684143},{"text":"I see the cake. I want to eat it. it's mine. I saw it first","width":285.18181824684143},{"text":"alright so, I'm claiming set turned to me, and now I'm just going to wait while your flag is raised or it's your turn","width":527.1818182468414},{"text":"what happens here?","width":143.18181824684143},{"text":"so you could imagine, that we do one, two and three, alright, so","width":715.1818182468414},{"text":"if there was no other thread, then great! we're going into the critical section","width":336.18181824684143},{"text":"alright, now we've cured the problem of no progress here. so let's see if we can make it a bit more interesting. suppose another thread comes along and raises the flag","width":1013.1818182468414},{"text":"now we have to decide who's going to set the turn variable last","width":194.18181824684143},{"text":"ok so, for now, let's try like this","width":379.18181824684143},{"text":"we'll set turn to me, and then the other thread says set turn to me","width":271.18181824684143},{"text":"so what happens now?","width":252.18181824684143},{"text":"the first thread says \"oh look! your flag is raised! I better wait!\"","width":289.18181824684143},{"text":"and what does the other thread do? \"oh look! your flag is raised! I'd better wait!\"","width":576.1818182468414},{"text":"it's like a four way stop sign in Wisconsin","width":210.18181824684143},{"text":"\"oh! I see you've arrived! I'll wait for you!\"","width":164.18181824684143},{"text":"that was not a Wisconsin accent, but you get the idea","width":231.18181824684143},{"text":"we start talking about cheese perhaps. but we got a problem that now both threads have claimed its their turn but we've reached a problem where they're both looking at each others flags and so we get stuck","width":993.1818182468414},{"text":"so we actually have deadlock. we've again showed the problem of we try to fix progress but we failed","width":495.18181824684143},{"text":"there is no progress here","width":105.18181824684143},{"text":"I'm going to make a little change to this program","width":453.18181824684143},{"text":"I'm going to say \"what would happen if this was an AND?\"","width":657.1818182468414}],
  // Part 3
  [{"text":"and, if we do that, we actually have Peterson's solution","width":1513.1818182468414},{"text":"so now Peterson's solution says \"I'm only going to look at your flag if the turn variable is pointing at you\"","width":585.1818182468414},{"text":"otherwise, I'm just going to be the bully and walk in","width":467.18181824684143},{"text":"now, I'm not going to spend twenty minutes to prove that this works","width":303.18181824684143},{"text":"because we'd actually have to look carefully at the possible different sequences of how this could work","width":484.18181824684143},{"text":"well I'm going to kind of just do a little bit of hand waving which is - I think you can agree that by the time we get to the wait loop, one of them has set the turn variable","width":943.1818182468414},{"text":"so the turn variable is either pointing at process 1 or process 2. one of them has finished doing that most recently","width":351.18181824684143},{"text":"so, one thread will wait. and the other, will continue.","width":433.18181824684143},{"text":"so we've solved the progress problem","width":623.1818182468414},{"text":"right, so dekker and peterson are two solutions to this and every systems programmer should be able to kind of recognize how these solutions work","width":844.1818182468414},{"text":"sorry, at least be able to recognize these solutions","width":224.18181824684143},{"text":"you'll notice what peterson did, what peterson noticed was this. was setting the turn to me before the wait","width":472.18181824684143},{"text":"that was his insight","width":161.18181824684143},{"text":"to say \"oh look! if I change the turn variable to me, BEFOREhand, I can actually write a really really simple solution\"","width":481.18181824684143},{"text":"and like I said, that wasn't actually discovered until 1981","width":348.18181824684143},{"text":"okay, what about the last one?","width":563.1818182468414},{"text":"does this work?","width":425.18181824684143},{"text":"what about algorithm 4? or solution 4?","width":553.1818182468414},{"text":"no progress again! yes, we can have a case where both sides are seeing each others flag being","width":628.1818182468414},{"text":"each others flag is raised and so we get stuck","width":330.18181824684143},{"text":"alright so, we've worked out two possible solutions. dekker's solution and peterson's solution here. through that minor change here","width":527.1818182468414},{"text":"how about enable us to actually implement a mutex lock and unlock?","width":210.18181824684143},{"text":"what part of the code would you put inside mutex lock and which part would you put inside unlock?","width":497.18181824684143},{"text":"alright. it's actually not that hard, right? let's use dekker's solution. we'll say this is the pseudocode I'm going to put inside","width":583.1818182468414},{"text":"the lock","width":101.18181824684143},{"text":"and this is the part that we'll put inside unlock","width":399.18181824684143},{"text":"and we better write some documentation to say that our code actually only works for two threads","width":318.18181824684143},{"text":"and if you want to use this for more than two threads, you better pay me more to think real hard about how to generalize this","width":655.1818182468414},{"text":"okay so, not bad for a morning's work! look, it's only 11:25 and we've already figured out some code to write mutex lock and mutex unlock. unfortunately, we come back a moment later and people say, wait, you know what? okay, it failed!","width":1131.1818182468414},{"text":"what do you say? this is impossible! I learned this in class! this is a correct solution. I even proved that it's correct","width":451.18181824684143},{"text":"it doesn't work","width":145.18181824684143},{"text":"it does not work on modern hadware","width":254.18181824684143},{"text":"here's why","width":92.18181824684143},{"text":"the C code that we write even the assembly code that we write, does not always correspond to exactly what happens in the hardware","width":690.1818182468414},{"text":"we try to make our hardware run as fast as possible. so, here's some things to abide to","width":350.18181824684143},{"text":"first of all, we can have a cache problem that what CPU thinks is in memory is being provided by the cache on the chip, on the CPU","width":627.1818182468414},{"text":"so if we've got two distant CPUs, they may not update the memory and notify each other that the value has changed","width":524.1818182468414},{"text":"so all this stuff about testing a turn variable and looking your flag, I might actually be looking at stale values that have not yet propogated from one CPU cache to another CPU cache","width":688.1818182468414},{"text":"a second problem is that actually our CPU can execute instructions out of order","width":556.1818182468414},{"text":"now before you panic and say \"oh! whats gonna happen to my code?\" don't panic too much. actually all the stuff we're going to do with pthread_mutex_lock ensures that the all the instructions up to that point are fully executed and completed","width":1333.1818182468414},{"text":"so, I'm not going to talk anymore about how this can bite you. other than don't panic because guess what, we've got the exchange instruction that we can use at the lowest level to make sure that we really do have a complete round trip to main memory as opposed to dealing with stale values in the cache","width":1695.1818182468414},{"text":"okay, right, any other questions about these?","width":508.18181824684143},{"text":"when we have an exam, when we have a quiz about this stuff, I will be writing these kinds of problems and asking you to figure out if its a valid solution or not. or if it is a valid solution, whether its dekkers solution or peterson's","width":886.1818182468414},{"text":"any other questions?","width":100.18181824684143},{"text":"good! we have round two!","width":191.18181824684143},{"text":"here we go, condition variables!","width":457.18181824684143},{"text":"alright, we're gonna write some code that actually uses a condition variable","width":424.18181824684143},{"text":"okay so, along the way I'll write some pseudocode I'll turn into real code and I'll talk about some gotchas","width":401.18181824684143},{"text":"so for example, one common gotcha is that we forget to actually initialize this stuff","width":438.18181824684143},{"text":"if you forget to initialize it, then yes you still got some memory reserved but it may not be connected to any actual real system resource that does some of the work for you","width":595.1818182468414},{"text":"so calling your mutex lock unlock may just silently fail","width":363.18181824684143},{"text":"because you never bothered to initialize it correctly","width":114.18181824684143},{"text":"so that's just a common gotcha","width":139.18181824684143},{"text":"so, if your friend leaves their workstation or their laptop open for a moment, just quietly walk over and delete their initialization code. they'll never know and they'll be stuck for hours","width":694.1818182468414},{"text":"alright, so how do I have these things, how do I create these things in my code?","width":373.18181824684143},{"text":"guess what? the pthread library gives you one, here it is. I'm gonna have this little variable called cv","width":364.18181824684143},{"text":"and you might notice in this code I've got a mutex lock as well","width":269.18181824684143},{"text":"it turns out that whenever you need a condition variable, you are going to need a mutex lock as well","width":581.1818182468414},{"text":"it's like the little side kick that comes along to the party","width":189.18181824684143},{"text":"you can't uninvite them. I'm sorry they just won't come together as a pair","width":319.18181824684143},{"text":"you're gonna see a mutex lock and a condition variable together","width":258.18181824684143},{"text":"why? because a mutex lock makes our lives much simpler","width":332.18181824684143},{"text":"the mutex lock allows us to reason that one thread at a time is doing things inside a critical section","width":493.18181824684143}],
  // Part 4
  [{"text":"and remember, that makes our life much easier. when we can say, oh look! i've got multiple threads happening somewhere in my program, but in the stuff that's really complicated, when I'm changing data structures or reading data structures which might be changed, I just want one thread accessing this stuff","width":1027.1818182468414},{"text":"so that's what my lock is for","width":147.18181824684143},{"text":"alright, so here's my incredibly complicated data structure, it's called an array, here it is","width":259.18181824684143},{"text":"and I've got the count that counts the number of things inside my array","width":294.18181824684143},{"text":"and as they are global variables, we know they are going to be initialized to zero","width":453.18181824684143},{"text":"okay, so, here's what I can do to my data. I've got something to add something into my array, to push some data in, and I've got a method to delete something!","width":756.1818182468414},{"text":"which all it does it just reduce the count","width":183.18181824684143},{"text":"and hopefully we'll assume that no one tries to delete more items than there are","width":494.18181824684143},{"text":"ok, I'm also going to have a getLast() method","width":558.1818182468414},{"text":"so getLast() we could, if we're inside cs225, say, I'll tell you what, I'll just return a bad value if nothing is actually in there already","width":539.1818182468414},{"text":"but no, what we're going to do is make getLast() wait","width":225.18181824684143},{"text":"we're going to make sure that it doesn't continue until there really is at least one value inside our datastructure","width":804.1818182468414},{"text":"alright so, here's the game we're playing","width":258.18181824684143},{"text":"there's one thread that's going to be calling push data and delete and it might do it several times.","width":281.18181824684143},{"text":"I've got another thread that might call getLast() several time","width":550.1818182468414},{"text":"right, so we're going to develop this code slowly but here we go. so, here's the plan. any time we want to deal with condition variables, we're going to write something incredibly incredibly simple. just a busy wait. just a simple while loop that keeps testing something","width":1387.1818182468414},{"text":"right so, this is the code that I'm scared about. right. I'm going to try and get something inside my array but what would happen, for example, if the count is oops this should be count - 1","width":844.1818182468414},{"text":"here we go","width":155.18181824684143},{"text":"what would happen for example if count was zero?","width":179.18181824684143},{"text":"it means my array doesn't have anything in it","width":207.18181824684143},{"text":"so, I need to say the following \"look, while count is zero, don't carry on.\"","width":1009.1818182468414},{"text":"so while count is zero, just go around","width":442.18181824684143},{"text":"and, who cares about burning up my battery on my cellphone. alright. it's easy code to write","width":475.18181824684143},{"text":"this is the kind of code you might write if you didn't come to cs241","width":152.18181824684143},{"text":"you know just \"[something] count is zero, doesn't matter, just keep going around\"","width":166.18181824684143},{"text":"eventually, at some point, count will change and that's fine","width":195.18181824684143},{"text":"of course, that code might execute a billion times and used up several milliamps of current","width":477.18181824684143},{"text":"or milliamperes of power","width":167.18181824684143},{"text":"and um, but it's the best we can do, right. I'm going to show you how we can do better","width":363.18181824684143},{"text":"so how can we fix this code? well first of all, we can see there's a race condition, right, that I don't want these methods to run at the same time so I'm now going to put my locks in","width":725.1818182468414},{"text":"alright so, here's what I wanted to do. I'm going to call my pthread and pthread's a lot to write so I'm just going to write p","width":492.18181824684143},{"text":"pthread_mutex is a lot to write so I'm just going to write m","width":342.18181824684143},{"text":"lock","width":49.18181824684143},{"text":"and, pass in the address of my little lock structure and at the end, call unlock","width":637.1818182468414},{"text":"and, suddenly our code is easier to read. we don't need to worry about say, two threads calling pushdata at the same time even if the problem says that never happens","width":604.1818182468414},{"text":"my code now says \"because of that lock, only one thread can ever be inside that little piece of code\"","width":476.18181824684143},{"text":"and similarly, here, if I lock on the same lock","width":978.1818182468414},{"text":"I'm conpletely confident that even if you tried to call pushdata and delete at the same time from two different threads, the code would still work","width":456.18181824684143},{"text":"one thread would have to wait","width":84.18181824684143},{"text":"one thread wins the lock and can continue and change the value of count. the other thread has to wait until the mutex is unlocked and then it can lock the mutex and carry on","width":784.1818182468414},{"text":"alright so, the lock call may take a bit of time","width":320.18181824684143},{"text":"if someone else if currently in the bathroom, you're going to have to just twiddle your thumbs and wait until that lock has been unlocked","width":601.1818182468414},{"text":"we're good, okay, we're fine so far right? this is not complicated so far. this is easy stuff, yes?","width":345.18181824684143},{"text":"yes?","width":65.18181824684143},{"text":"I know it's a monday and the weekend was great but come on, this is not too bad","width":269.18181824684143},{"text":"alright so, now, haha, right, now let's see what we should do over here","width":382.18181824684143},{"text":"um, before checking this count, I should make sure that no one else is touching it alright?","width":513.1818182468414},{"text":"that no one else might be, say, changing its value halfway through","width":246.18181824684143},{"text":"so, um, before doing anything with these shared variables, let's put a lock call in at the beginning. there we go.","width":945.1818182468414},{"text":"we see how our code is becoming littered with these lock() and unlock() calls, yes?","width":527.1818182468414},{"text":"alright, so we write this code, what happens?","width":460.18181824684143},{"text":"if we tried to test it at this point?","width":448.18181824684143},{"text":"this is the, what, freddy mercury who wants to live forever code?","width":418.18181824684143},{"text":"alright so my. I'm fine if I'm just calling pushdata and delete","width":394.18181824684143},{"text":"things can bad though, the moment I call getLast()","width":264.18181824684143},{"text":"because, getLast() locked the mutex, so what would happen now, to any other code that calls pushdata and delete?","width":583.1818182468414},{"text":"they get stuck! yeah, they get stuck inside their lock call","width":181.18181824684143},{"text":"waiting for that lock to get unlocked","width":106.18181824684143},{"text":"which as we can see from the code is never going to happen. wahahaha. alright, so we've got a problem","width":650.1818182468414},{"text":"we can even imagine as well that this count, if this was zero, then we can get stuck inside this loop, and because we don't unlock it, pushdata will never happen","width":1080.1818182468414},{"text":"so, here's how we're going to fix our code now","width":396.18181824684143},{"text":"we're going to unlock the mutex, meditate, me-di-tate, with our condition variable","width":1098.1818182468414},{"text":"after we finish meditating, lock the mutex again","width":352.18181824684143}],
  // Part 5
  [{"text":"so if our count is zero, go into a restful, peaceful state, but you say \"how can I wake my monk up if its meditating?\"","width":1152},{"text":"okay, when should I wake it up? do I need to wake it up in the delete()?","width":192},{"text":"no! because there's no way it could've fallen asleep then. it's going to fall asleep if the count was zero","width":576},{"text":"so, when should I wake it up?","width":192},{"text":"after I've incremented the count","width":320},{"text":"there's no point kicking the monk before that point, yes?","width":192},{"text":"because if I do, the monk will wake up, come out, eventually it'll be able to lock the mutex, it'll check the count again and say \"oh!\"","width":576},{"text":"so I'm going to write the code like this. I'm going to after here, after we're kind of ready, kick the monk","width":832},{"text":"of course, if you're not feeling so violent, you can have one of those little bells. ding!","width":512},{"text":"and signal the monk to wake up","width":192},{"text":"alright so, we kick the monk! they wake up out of their meditation! they attempt to lock the mutex, but they can't because guess what our other thread has currently got it locked, so they're stuck in the lock call but in a moment's time, we will unlock the mutex.","width":1024},{"text":"when we do that, the monk on this side is able to lock the mutex and continue. the go around, back to their while loop. hey look at that! count is no longer zero!","width":512},{"text":"great! I can continue! quick, get the array! get the last entry of the array! fantastic and return it","width":448},{"text":"alright, is my code complete?","width":128},{"text":"no, I've forgotten to do one last thing which is at the end, unlock()","width":320},{"text":"the mutex","width":128},{"text":"notice I put this after reading the array","width":512},{"text":"why? because I want my life to be simple. if I'm going to look at the array, if I'm going to look at the count, I want to make sure that I'm the only thread that can do so","width":768},{"text":"how do I do that? by owning the lock","width":256},{"text":"any other thread that attempts to say \"push more data in\" or \"delete stuff\" has to wait because they have to get the lock first. yes?","width":576},{"text":"you could do the kick after the unlock() almost, but there's actually a subtle race condition that I don't want to talk about today.","width":1024},{"text":"so for now, just put it inside","width":128},{"text":"okay?","width":64},{"text":"alright, now, some comments on here. so this is how I want you to think of a condition variable. look, there's always three steps","width":704},{"text":"we better unlock stuff, because if we don't then I'm going to be meditating forever","width":192},{"text":"the rest of my code can't continue. it can't do its stuff to the array structure, it will never kick the monk because it will never get the lock","width":704},{"text":"so we must unlock it","width":64},{"text":"then we meditate","width":64},{"text":"and then, because we want to check our variables, we better relock the mutex","width":384},{"text":"alright?","width":64},{"text":"now I have some wonderful news for you","width":256},{"text":"all three of these things that we do here, happen inside cond_wait","width":1088},{"text":"actually, it's just one call","width":128},{"text":"so the most important thing in this lecture is to remember that cond_wait actually does three things. before meditating, it's going to unlock the mutex that you give it","width":960},{"text":"why? so that other things can actually access the data structure and do things","width":448},{"text":"and the POSIX call is not called \"kick the monk\" or \"ring a little symbol\"","width":576},{"text":"it's just signal or cond_signal, to be precise","width":576},{"text":"and you pass in a pointer to the condition variable","width":128},{"text":"so here's what happens. when you call cond_signal, you're saying to the operating system \"please, at some point in the future, find a monk that's meditating and walk up and do the little symbol. ding!\"","width":1152},{"text":"wake up the monk","width":64},{"text":"if you call cond_signal, the operating system's only going to do that to one monk if it can find it. if there's no monk's meditating, it won't bother","width":960},{"text":"it is also possible to bash the gong and wake up all monks which are meditating","width":576},{"text":"but we don't need to. well, we don't need that today. we know that from the problem specification, there's only going to be one thread inside getLast()","width":768},{"text":"later on, we'll see examples that do taht","width":128}],
  // Part 6
  [{"text":"okay, right, so, now, this is where you come in","width":192},{"text":"remember how I said, OSX doesn't implement semaphores. well guess what, it's your lucky day,!","width":512},{"text":"you are at Apple and in the afternoon, they accidentally left you access to the source code so you decided to actually implement sem_wait sem_post ecetera for Apple so we can actually get these things working","width":1024},{"text":"alright, and we can use condition variables. condition variables are more general, they're more powerful than semaphores because we get to write any condition that we want inside the little while loop","width":640},{"text":"so, how would you write these things? okay, how do we implement our semaphores?","width":448},{"text":"okay, so what do we need inside our semaphore?","width":192},{"text":"well, we need some sort of count","width":192},{"text":"to remember when that count gets to zero, then our sem_wait will wait","width":384},{"text":"and presumably, we also need some sort of pthread_mutex_lock","width":384},{"text":"there we go. and we'll have a pthread_cond variable","width":320},{"text":"there we go","width":320},{"text":"so with both things inside our semaphore, now we can figure out how to write sem_wait and sem_post","width":640},{"text":"so, what's the first thing we should do inside sem_wait?","width":1664},{"text":"we're going to be accessing our count variable so before we do that, we want to make sure that we have sole access. exclusive access to it. alright. so what should we call first?","width":960},{"text":"yes! let's lock our mutex","width":128},{"text":"alright, so, pthread_mutex_lock, and passed in a pointer to that structure so we'll do s, get the lock","width":640},{"text":"um, we'll make these little pointers just for speed today. right, and at the very end, we are gonna unlock stuff as well","width":704},{"text":"so, when did we need to actually meditate? when did we actually need to pause?","width":960},{"text":"so if the count is zero, then let's send this monk to sleep. let's send this thread to sleep. so now we can call pthread_cond_wait","width":1280},{"text":"and you'd pass in a pointer to the condition variable and a pointer to the mutex","width":512},{"text":"and remember, that does three things for you. it unlocks the mutex, sleeps on the condition variable, and when eventually where it wakes up from that meditation, it's going to relock the mutex before returning","width":960},{"text":"so one way to look at this code is that inside this code, at all times, the mutex lock is actually locked in terms of the code that we writing. in terms of say, checking this count.","width":704},{"text":"we know that that mutex lock is always locked","width":192},{"text":"it's only if it actually goes to sleep inside this cond_wait will the mutex lock become unlocked","width":576},{"text":"alright so, we get around there. and the last thing we need to do in our wait call is to reduce the count","width":512},{"text":"so, in our count structure, reduce it","width":512},{"text":"what would happen if two threads called sem_wait at the same time? doesn't matter. our lock would ensure that only one of them wins.","width":640},{"text":"that only one of them executes at a time","width":128},{"text":"so maybe the first thread will successfully call sem_wait and continue. the second thread, though, calling sem_wait might see the count value zero and then it's forced to meditate","width":704},{"text":"alright, what about our post? our post is not going to do any sleeping.","width":384},{"text":"it will increment the count","width":320},{"text":"okay, oh! look at that! I've touched part of the structure. I better make sure that what?","width":512},{"text":"what should I have done first?","width":128},{"text":"get the lock! yes.","width":128},{"text":"okay, so pthread_mutex_lock and pass in a pointer to the lock that everyone's playing with","width":448},{"text":"there we go","width":64},{"text":"so now I know when I get back from this that I've got exclusive access to this data structure because all the code I'm writing always locks the same lock","width":832},{"text":"and now, I can call pthread_cond_signal","width":512},{"text":"on the condition variable","width":512},{"text":"and finally, unlock the mutex. so this code would work","width":512},{"text":"but we can do a little bit better","width":192},{"text":"which is that our post is always asking the operating system to find a sleeping monk and ring the bell","width":640},{"text":"and, we could do a little bit better reasoning about this, we can say well hold on, the only time that there could be a sleeping monk is if the count is actually already been reduced to zero","width":832},{"text":"so if I've just incremented the count, then I'm going to wake up one monk","width":320},{"text":"so if the count has just been incremented to one, now I know that I should try to wake up a monk. if there happens to be no monks waiting, doesn't matter. that's okay, that's not my problem","width":1024},{"text":"but for the other times, if count says greater than one, then there can't have been any monks waiting. there's only going to be monks waiting if we've reduced the count down to one.","width":768},{"text":"alright and in here we write the standard code to initialize our mutex lock and our condition variable","width":512},{"text":"okay, and with that, we're out of time! I will see you on wednesday and you will have a quiz on friday! more about that on wednesday","width":576},{"text":"a reminder that malloc part 1 is due today","width":256},{"text":"come down and, it is isn't it?","width":320},{"text":"come down and see me if you have any questions! welcome to condition variables","width":384}],

  // Start Lecture Video 11 (0 INDEXED... OUTLIER)
  // Part 1
  [{"text":"Apparently my head cold managed to confuse me so therefore I confused you","width":832},{"text":"and I gave you an incorrect delta to those examples to show you peterson's solution","width":534},{"text":"and what I did was incomplete","width":128},{"text":"this is peterson's solution","width":169},{"text":"it is in the book, the wiki book","width":229},{"text":"the wiki book is very new ","width":124},{"text":"I only started creating it last semester","width":192},{"text":"it is an experiment to say what would happen if I after every lecture I wrote some notes","width":360},{"text":"and rather than just put it in a pdf, actually make it a wiki page","width":197},{"text":"so the wiki book is yours to edit and to add to eventually we'll actually turn it into a hard copy and I'll charge eight hundred thousand dollars for each one","width":768},{"text":"right no I'm not going to give it to Peterson or any of those other vulture companies","width":305},{"text":"I'll eventually have a hard copy and basically sell it at a bit over cost","width":359},{"text":"but until we do that it is available on the web","width":192},{"text":"you too can edit it, you too can improve it","width":192},{"text":"and in fact i'll be talking partly about that on Friday","width":247},{"text":"there is a conference where we talk about educational technologies and I've got a talk about that","width":430},{"text":"and also about the linux in the browser project which you too can play with","width":344},{"text":"and it's all in the cs 241 home page and you too can help develop it if you wish","width":379},{"text":"so i have several people doing improvements on that project as part of their senior projects for example","width":452},{"text":"I also have another group adding subtitles, captions to lecture videos","width":446},{"text":"and are looking at crowdsourcing for that","width":128},{"text":"so lots of good stuff","width":111},{"text":"right so we've talked about that","width":192},{"text":"i'll tell you about some more news in a little bit","width":154},{"text":"right now let's turn our attention to today's little challenge here","width":569},{"text":"the first challenge is relatively easy","width":135},{"text":"but it's still nontrivial","width":128},{"text":"what we're going to do today is make a barrier","width":457},{"text":"so we talked about okay we can create all these threads","width":217},{"text":"and one way to program them would be to say create a whole lot of threads which work on a little problem and join on all of those threads and we wait for them to finish","width":538},{"text":"that's a perfectly reasonable and simple way to use threads","width":192},{"text":"but we can do better","width":119},{"text":"now that we know that we've got these primitives that can stop and wait","width":331},{"text":"we can make our threads wait for each other ","width":244},{"text":"so before going to a part b of an algorithm","width":259},{"text":"let's wait for everybody to finish part a","width":222},{"text":"so this is basically like before closing the door of an elevator and going down to the next part","width":298},{"text":"we want all of our other threads to finish","width":185},{"text":"so that's the idea of a barrier","width":128},{"text":"we can implement this using semaphores and we can say that we're going to look at using condition variables","width":576},{"text":"so remember what is a condition variable? it's nothing particularly special","width":198},{"text":"it just allows our threads to go into a meditative state and not use any cpu until we wake it up","width":400},{"text":"but it's called a condition variable because we've put this inside the loop that tests for some condition","width":712},{"text":"so let's look at our little story here and see what we can do here","width":519},{"text":"there we go","width":193},{"text":"right so I've set up a typical little problem here that hey I've got a lot of data here it is","width":616},{"text":"a big array","width":188},{"text":"it's in global memory so that makes life easy","width":187},{"text":"and I've got a calculation I want to do on it","width":256},{"text":"fortunately I know about threads so I'm going to split my big array up here into chunks","width":680},{"text":"and if I've got two hundred and fifty six blocks why don't I split it up into sixteen chunks","width":917},{"text":"for my oops I'm just looking down here if my x so this is now x and this is now y, nevermind","width":553},{"text":"so my x values are going to be rather than one thread going from zero to two hundred and fifty five","width":648},{"text":"I'm going to get each thread to work independently on a segment of this matrix","width":477},{"text":"alright so if we have a look at this ","width":192},{"text":"this is what we've got here","width":108},{"text":"in my main I'm going to fire off N threads","width":385},{"text":"okay so we'll define N to be say sixteen","width":410},{"text":"wouldn't it be nice to have a sixteen core processor","width":160},{"text":"well you too can right now either just spend a lot of money or wait three years and it'll be easy","width":539},{"text":"so it'll be cheap","width":51},{"text":"so then we'll start say 16 threads","width":271},{"text":"I want to ask each one of them to do a chunk of the work","width":165},{"text":"one sixteenth of the total amount of work","width":302},{"text":"okay so great we've called pthread_create","width":340},{"text":"what's the first argument we pass into pthread_create?","width":430},{"text":"yes we are actually going to pass in the address of that","width":253},{"text":"the address of where we want pthread_create to store the the thread identifier","width":297},{"text":"so how do I write that","width":105},{"text":"I could say ampersand okay here's my little array and I want the i one","width":477},{"text":"that's probably the most readable way of writing that","width":192},{"text":"an equivalent would be to say ids + i","width":438},{"text":"is that true? so think about that or test it","width":1066},{"text":"part of it becomes what's the size of this","width":154},{"text":"what happens when you add to it","width":193},{"text":"I'm not going to write that today","width":84},{"text":"I'm going to go with this","width":69},{"text":"right so we've got the address of where we want to store that identifier","width":385},{"text":"we don't need to set any special parameters for our pthread_create","width":174},{"text":"we're going to pass in this calc function that actually does all the work for us and finally we say (void*) i","width":361},{"text":"right so what are we doing here we're taking that little integer and we're turning it into a pointer","width":320},{"text":"you can that in C, remember it's just a bit pattern being converted into a similar bit pattern but we're saying that the type of it should be treated as a (void *) pointer","width":704},{"text":"why do I that, that's because that's the argument type","width":192},{"text":"and that will be okay provided we don't actually try to follow that pointer into memory","width":320},{"text":"remember it's just a value 0 1 2 3 4 5 6 7 8 9 10 11 12 13 15","width":320},{"text":"okay so at the end of here I'm going to wait for my threads to finish","width":355},{"text":"okay so here I'm just going to call pthread_join and this time pass in the value of my little identifiers","width":623},{"text":"and I don't actually care about the exit value","width":287},{"text":"otherwise I could have passed in a pointer to a void * to grab that","width":294},{"text":"and then I would write some code to print out the result which I don't care about","width":192},{"text":"so that's the outside of my algorithm, start all these threads, off you go, sixteen people start doing your work","width":389},{"text":"I'm going to give each one of you a unique number and then wait for them to all finish by calling pthread_join","width":585},{"text":"now the main part of this puzzle starts","width":172},{"text":"okay we're going to write our little calc program","width":300},{"text":"we know that our pthread functions take a void* and return a void*","width":827},{"text":"so I've got some pointer, I don't actually want to use that variable as a pointer though","width":275},{"text":"I just want to cast it back into an integer","width":466},{"text":"so no memory lookups were used in this casting ","width":221},{"text":"it simply says hey I know you treat me as a pointer, I lied I just want to treat it as an integer","width":384},{"text":"and I went through those hoops just to make the compiler happy","width":421},{"text":"and I'm confident that a void* pointer can hold the integer between zero and fifteen","width":294},{"text":"right so that's going to be my starting point","width":169},{"text":"my end point exclusive would just be the starting point plus sixteen","width":295},{"text":"so now in my little loop x can go form the start almost to the end and my y is going to go through all of the remaining 8192 entries","width":772},{"text":"right and then I do my calculation","width":128},{"text":"that's going to take a while","width":84},{"text":"now you might say really all sixteen threads are going to run at the same time so they are all going to finish at the same time","width":407},{"text":"well that's not quite true","width":222},{"text":"it could be that one of these threads starts very very late","width":312},{"text":"it could be another thread starts completely earlier ","width":128},{"text":"it depends on how the operating system decides to schedule these threads","width":221},{"text":"it could be that a cpu is temporarily stolen to do some other work","width":280},{"text":"like process an interrupt because you pressed something on the keyboard","width":179},{"text":"something arrived on the network","width":105},{"text":"something arrived from the disk","width":75},{"text":"so you're not guaranteed to have the CPU for 100% of the time","width":265},{"text":"so we're not quite sure when all of these threads are going to finish","width":204},{"text":"so that's where we come in now","width":85},{"text":"we're going to try and write some code in here so that we can make sure that we don't continue the second calculation until all sixteen threads have finished","width":798},{"text":"so what are you going to do","width":153},{"text":"how are we going to solve this?","width":199},{"text":"what do we need?","width":442},{"text":"I need some ideas","width":318},{"text":"we could potentially do this with a semaphore","width":175},{"text":"kind of, what other ways could we do this though?","width":556},{"text":"okay yes we need some sort of global count variable","width":146},{"text":"just keep track of how many threads are currently running","width":269},{"text":"we're not going to try and directly query these threads","width":222},{"text":"we'll just have some sort of global variable that all the threads can decrement to say oh yeah I finished","width":668},{"text":"okay so up here we'll have an int remain and we can set that equal to sixteen","width":587},{"text":"or N if we want to","width":498},{"text":"so when I actually finish my work, each thread will decrement remain","width":950},{"text":"now notice what I just said","width":44},{"text":"when each thread finishes, it is going to decrement remain","width":161},{"text":"at this point, alarm bells should go off","width":328},{"text":"okay very quiet ones inside your head","width":192},{"text":"because I've just said that more than one thread is touching a data structure","width":320},{"text":"so there's a potential race condition","width":143},{"text":"two threads might decide to decrement remain at the same time","width":185},{"text":"whoops we don't want that","width":78},{"text":"we want each thread to have exclusive access to this remain","width":260},{"text":"when it's actually manipulating that","width":105},{"text":"so how do we ensure that happens","width":152},{"text":"yes bring out your mutex lock","width":456},{"text":"maybe it looks like a giant padlock or anyways nevermind","width":347},{"text":"so yeah we'll call pthread_mutex_lock on our mutex","width":640},{"text":"okay so this takes a pointer to that data structure","width":326},{"text":"at this point alarm bells go off and say oh hey did I actually remember to initialize the mutex","width":334},{"text":"and the answer is yes yeah you did if you actually managed to write the correct function","width":382},{"text":"these are pthread_mutex_init is one way to initialize your mutex lock","width":308},{"text":"right so if we do a lock, we know that any other thread that comes in here has to wait","width":459},{"text":"it could be then that those other threads that have not yet finished","width":490},{"text":"in which case the thread that is running this code ","width":169},{"text":"we want it to go to sleep","width":77},{"text":"okay well let's suppose I didn't know about condition variables","width":356},{"text":"then I might say something like while remain is greater than zero","width":504},{"text":"do nothing","width":250},{"text":"wohahahahaha we laugh at that code wohaahaha","width":171},{"text":"why? because we do know about condition variables, but why else?","width":501},{"text":"yeah the first thread that gets in there is just going to spin around","width":448},{"text":"and round and round and round it goes","width":145},{"text":"the second thread when it finishes will attempt to lock the mutex","width":289},{"text":"are you prepared to wait? yes i'm prepared to wait","width":171},{"text":"right then the second thread that finishes will get stuck inside pthread_mutex_lock","width":248},{"text":"waiting to lock that mutex, but we can see from this code that that mutex lock is never unlocked","width":313},{"text":"the second, third, fourth and fifth and the remaining fifteen threads will never get past pthread_mutex_lock","width":455},{"text":"because that mutex lock is never unlocked wohahahah","width":232},{"text":"alright so how can we start fixing this code","width":322},{"text":"well here's what we are going to do","width":79},{"text":"rather than just having a busy loop where we continuously burn up CPU time","width":298},{"text":"we are going to call pthread_condition_wait","width":561},{"text":"and for that you pass in your condition variable and pass in a pointer to your mutex lock","width":494},{"text":"and every good systems programmer knows that is when your thread meditates","width":410},{"text":"it goes to sleep","width":255},{"text":"but before it goes to sleep what happens?","width":310},{"text":"what do you get inside here?","width":194},{"text":"for free, what's it do for you?","width":207},{"text":"hint, we have to pass in the pointer to the mutex","width":166},{"text":"why? because it's going to unlock that mutex for you","width":287},{"text":"and then go to sleep","width":192},{"text":"alright so one of our threads arrived here early and said \"look remain is still non zero, I'm just going to sit here and chillax\"","width":783},{"text":"yeah i'm not going to do anything, I'm just going to go into my meditative state","width":384},{"text":"the very last thread, the sixteenth thread that comes in says \"oh look remain is finally zero, I don't need to sleep, I can continue!\"","width":835},{"text":"so I'll unlock and off we go","width":298},{"text":"and the sixteenth thread to arrive will then do the second calculation","width":347},{"text":"right so that's not a very good barrier right?","width":436},{"text":"what do we do? we wait until the sixteenth sheep finally arrives that was enough weight to tip the balance and the sixteenth sheep could continue","width":576},{"text":"and all the others are left there waiting, sleeping, yes?","width":319},{"text":"we'd like a way to wake up those meditating threads","width":354},{"text":"how do we do that?","width":214},{"text":"yes broadcast, we want to not just wake up one sleeping thread with a little bell, ding","width":615},{"text":"right, if you call pthread_condition_signal the system will choose one arbitrary sleeping thread and wake it up","width":713},{"text":"we don't want to do that, we want to wake up everybody","width":300},{"text":"so this is like running over to FARPAR and shouting free ice cream right? everybody comes over","width":545},{"text":"actually any free food at FARPAR will work but so","width":244},{"text":"how can we do this? well here's what we'll do","width":263},{"text":"inside our code, we need to call broadcast","width":346},{"text":"now I could do it even before the while loop here","width":371},{"text":"I could say \"okay pthread_condition_broadcast\" and here's the way we're going to wake up, anybody who is sleeping on this particular conditional variable","width":993},{"text":"now will this work? yes, here's what happens","width":297},{"text":"you wake up everybody in FARPAR and they check and discover that actually there is no ice cream so they just go back to sleep","width":530},{"text":"okay so that's a silly analogy, but what happens in the code is that we wake up everybody inside the condition wait and see look we wrote it inside a while loop","width":544},{"text":"so everybody wakes up, eventually they get to run on the CPU, and when they do they'll say \"oh look remain is actually still greater than zero\"","width":555},{"text":"so this code will keep waking up every time a thread gets to this point, it would run it","width":301},{"text":"so we could do a bit better than that","width":111},{"text":"we actually don't want to always wake people, we actually only want to call this when we know that if remain is now zero, actually bother to wake people up","width":1244},{"text":"alright so if I'm the last person in the gate, wake everybody up","width":271},{"text":"there's no point in waking other people up beforehand because they will simply check and discover that remain is actually still non zero and then just go back to sleep","width":601},{"text":"so that would work, it's just not that efficient","width":250},{"text":"this is more efficient, don't wake people up until remain is zero","width":575},{"text":"so that is a barrier, yes at the back?","width":809},{"text":"well the last thread will see the value of zero so you'll never actually go into this while loop","width":297},{"text":"yes I could have written it afterwards, it's still a good idea to do the broadcast inside the lock and unlock","width":643},{"text":"there's a subtle race condition we can get if we don't","width":373},{"text":"right and the other thing to remember is that condition wait actually does three things","width":369},{"text":"after being woken up from its deep sleep, before it returns, it waits to acquire the mutex lock again","width":635},{"text":"so that means you've woken people up but they won't actually start to execute this code","width":349},{"text":"they won't be checking the remain value until someone exits","width":326},{"text":"until someone unlocks the mutex","width":191},{"text":"so in this case the sixteenth thread will come in, see that remain is now zero, wake everyone up","width":322},{"text":"but now they've woken up but can't actually continue on this code yet because we're still holding the mutex lock","width":510},{"text":"so eventually we unlock and then another thread in here will say great!","width":257},{"text":"finally I've woken up and finally I've managed to lock the mutex thread and I can continue","width":266},{"text":"and what's it do? it just unlocks the mutex and continues","width":203},{"text":"and so on and so on for the remaining threads","width":265},{"text":"so this is really really powerful","width":128},{"text":"this is a very very powerful paradigm now because now you can make your threads do a whole lot of work, pause for each other, wait for each other and then continue to do more work, etc","width":575},{"text":"now you can write pretty good performant code in a way that you couldn't before","width":481},{"text":"okay any other questions?","width":173},{"text":"I'll give you a hint, I like to do things like show you code and say on an exam or quiz and say \"well okay does this actually work? is it efficient or not? or when might it break?\"","width":906},{"text":"so you could imagine for example if we only did signal here instead of broadcast, we'd only be waking up one thread","width":479},{"text":"and the other fourteen of them would still be sleeping","width":561},{"text":"aha right so when we come to test this, A will be compiled so let's fix what you said","width":581},{"text":"pthread_cond_t there we go and then when we come to test it, it doesn't work","width":611},{"text":"what did we forget to do?","width":128},{"text":"initialize it, yes! remember with these things, we've actually got two steps","width":343},{"text":"you've got to A. make some memory somewhere of enough size and B. actually call init on it","width":414},{"text":"so inside here we need to do pthread_cond_init and if we were writing robust code, that's a null as well, we would check the return values of these","width":1555}],
  // Part 2
  [{"text":"right, let's try this","width":153.18181824684143},{"text":"you should be able to write this code yourself","width":221.18181824684143},{"text":"and understand how it works","width":317.18181824684143},{"text":"now we're going to talk about the Reader-Writer problem","width":313.18181824684143},{"text":"the Reader-Writer problem crops up in all sort of places","width":467.18181824684143},{"text":"maybe in a web server, maybe in a database server and anytime you've got a data structure","width":483.18181824684143},{"text":"where you want to read it and update at the same time, you're probably going to run into the Reader-Writer problem","width":473.18181824684143},{"text":"so the problem is this","width":63.18181824684143},{"text":"I might have multiple threads that want to read from it","width":213.18181824684143},{"text":"and multiple threads that want to write to it","width":377.18181824684143},{"text":"if I've got a writer that is updating my data structure","width":375.18181824684143},{"text":"everybody else needs to wait","width":263.18181824684143},{"text":"I can't have two writers trying to change my data structure at the same time","width":247.18181824684143},{"text":"it's like two surgeons trying to do the cardiac stuff at the same time. it's not going to work","width":369.18181824684143},{"text":"it's going to end badly","width":73.18181824684143},{"text":"so we want to make sure that anytime we update data structure","width":289.18181824684143},{"text":"everybody else has to wait","width":147.18181824684143},{"text":"so if there's multiple writers waiting \"hey get in line, just one at a time please\"","width":363.18181824684143},{"text":"however, most of the time we don't actually need to update the data structure","width":245.18181824684143},{"text":"most of the time we want to allow our readers to read the data structure","width":273.18181824684143},{"text":"we want it to be efficient, in other words more than one reader can read the data structure at a time","width":644.1818182468414},{"text":"sounds easy, yes?","width":267.18181824684143},{"text":"the reader writer question is a popular question in internship interviews by the way","width":583.1818182468414},{"text":"let's have a look at some proposed solutions and see what happens","width":580.1818182468414},{"text":"and by the way, another thing you can expect in interviews is \"hey, what's the producer consumer problem?\"","width":653.1818182468414},{"text":"or \"how's it different?\"","width":183.18181824684143},{"text":"OK, so how is it different?","width":132.18181824684143},{"text":"first of all, the reader-writer problem is harder!","width":718.1818182468414},{"text":"the producer-consumer is just hey, I want to throw some stuff into this data structure and I want to pull some stuff out of the same data structure","width":493.18181824684143},{"text":"and if the data structure is full then you need to wait","width":230.18181824684143},{"text":"and if the data structure is empty then you can't pull anything from it and you need to wait","width":286.18181824684143},{"text":"and we can implement that with semaphores or conditional variables as well","width":277.18181824684143},{"text":"but we'll see that later","width":135.18181824684143},{"text":"the reader-writer problem I've got multiple readers running at the same time","width":448.18181824684143},{"text":"N readers, that's OK","width":521.1818182468414},{"text":"but I only expect one writer at a time","width":689.1818182468414},{"text":"anytime I've got a writer everyone else has to stand back, the readers aren't allowed to access the data structure either","width":419.18181824684143},{"text":"great, I've defined the problem. let's see if this code works","width":241.18181824684143},{"text":"here's some example code, perhaps you and your neighbor can figure out if it's any good","width":420.18181824684143},{"text":"or why it's no good","width":120.18181824684143},{"text":"[students working, long pause]","width":8933.181818246841},{"text":"OK, so let's talk about one kind of common gotcha here is","width":274.18181824684143},{"text":"I've been giving you examples where I've made p_threads, mutex locks and conditional variables just as global variables","width":336.18181824684143},{"text":"you don't have to do it that way, you could actually put them inside heap memory","width":240.18181824684143},{"text":"for example, if we called malloc, we might say \"now give me the size of a p_thread mutex pointer\"","width":617.1818182468414},{"text":"is that OK?","width":152.18181824684143},{"text":"no! I've just asked for the size of a pointer, that's going to be say 4 bytes on 32-bit system and 8 bytes on a 64-bit system","width":463.18181824684143},{"text":"I don't want that. I actually wanted the size of the data structure","width":263.18181824684143},{"text":"and unfortunately no one is going to tell you that you got it wrong","width":201.18181824684143},{"text":"it's just going to crash at some strange point in the future of the program","width":348.18181824684143},{"text":"so watch out for your asterisks ","width":133.18181824684143},{"text":"a pointer is not the same as the structure","width":183.18181824684143},{"text":"and good that we've initialized these things, presumably we have to make some more memory for the write lock as well","width":490.18181824684143},{"text":"how does this work? well anytime a thread wants to read, it first grabs the read lock and does reading stuff and when it's finished it unlocks","width":484.18181824684143},{"text":"how does the write work? anytime it wants to write it grabs the write lock, and it grabs the read lock! so it can only get through this stuff, it can only get to actually doing any writing, when it has both of these things","width":850.1818182468414},{"text":"so that means that no other writer can be writing at the same time, right?","width":233.18181824684143},{"text":"because I've got the lock and if I have the lock you that means you don't have it! You must be stuck inside the write lock","width":444.18181824684143},{"text":"so only one of us can actually do the writing","width":298.18181824684143},{"text":"this works great, yes?","width":63.18181824684143},{"text":"no, of course it doesn't, it's the first version!","width":341.18181824684143},{"text":"how is it broken?","width":439.18181824684143},{"text":"yes, our first problem is that only one person can read at a time. we wanted multiple readers to be able to use our data structure","width":707.1818182468414},{"text":"this is insufficient","width":258.18181824684143},{"text":"it fails in terms of allowing multiple readers","width":198.18181824684143},{"text":"it does a few good things though. it ensures that if a writer is writing then no one else can do anything","width":453.18181824684143},{"text":"so that seems pretty good","width":223.18181824684143},{"text":"let's have a go at version two","width":393.18181824684143},{"text":"and in this version we are going to have a couple of integers, which if they are on the stack I'd better set equal to zero","width":834.1818182468414},{"text":"and we'll keep track of how many people are really writing","width":668.1818182468414},{"text":"should read be locking write? it's not necessary","width":212.18181824684143},{"text":"the question is \"should the read method actually call write lock as well?\"","width":329.18181824684143},{"text":"it's not necessary because the write also grabs the read lock","width":385.18181824684143},{"text":"so the writer cannot continue whilst anyone actually has the read lock","width":654.1818182468414},{"text":"good question, thanks","width":151.18181824684143},{"text":"we'll keep track of this somehow","width":152.18181824684143},{"text":"whether reading or writing is actually happening","width":650.1818182468414},{"text":"what do you think of candidate two?","width":540.1818182468414},{"text":"is this any good?","width":63.18181824684143},{"text":"[long pause]","width":1641.1818182468414},{"text":"so you could be doing reading while writing","width":148.18181824684143},{"text":"OK, let's have a look at the logic that inspired this and then we'll see why it's broken","width":318.18181824684143},{"text":"so the logic behind this is trying to say, while someone is actually doing some writing, I'm not going to touch this. I'm going to wait","width":446.18181824684143},{"text":"so then we can carry on and I'm going to raise my little flag to say \"we're doing some reading\"","width":262.18181824684143},{"text":"and then I set reading to false","width":269.18181824684143},{"text":"what's the logic that I did behind the writing is to say ","width":153.18181824684143},{"text":"while anyone is reading or writing, just do a busy loop. we'll burn up some CPU","width":280.18181824684143},{"text":"nevermind that, CPUs are cheap","width":242.18181824684143},{"text":"and then when we get past here we'll raise my flag","width":201.18181824684143},{"text":"I've got writing to do. I'll do my writing stuff. I've raised the flag so anybody else will be stuck inside their busy loops","width":513.1818182468414},{"text":"because I've set the flag to true then the readers will be waiting and any writers will also be waiting inside their while loop","width":608.1818182468414},{"text":"the code is fine!","width":329.18181824684143},{"text":"what smells a bit? it's not fine!","width":313.18181824684143},{"text":"we've got race conditions, just like we saw with the critical section problem","width":251.18181824684143},{"text":"with these flags we might be setting the flags a bit late","width":316.18181824684143},{"text":"and what would happen if two readers came in?","width":492.18181824684143},{"text":"the first reader to finish reading would set the reading flag back down to false","width":305.18181824684143},{"text":"it would look like no one is reading","width":427.18181824684143},{"text":"you could imagine two writers coming in","width":210.18181824684143},{"text":"both writing threads would see that reading and writing are zero or false","width":308.18181824684143},{"text":"and so we'll continue. oops! we've got a race condition","width":299.18181824684143},{"text":"so we're not doing very well here","width":353.18181824684143},{"text":"we're not checking our variables in a careful enough way","width":404.18181824684143},{"text":"and we're allowing readers to happen a the same time as writers","width":326.18181824684143},{"text":"I could imagine a reader and writer coming in at the same time and they both get past their while loops because neither of the flags are set yet","width":515.1818182468414},{"text":"because they are set later","width":119.18181824684143},{"text":"so if the two while loops happen at the same time, whoops! we've allowed both a reader and a write access to the data structure","width":442.18181824684143},{"text":"so this is no good, but don't worry, we've got a solution for you!","width":303.18181824684143}],
  // Part 3
  [{"text":"Let's see. I've heard the uiuc students are incredibly bright. Yes, they know how to party, but I've heard that you're really really bright","width":1170},{"text":"so let's see if you can actually solve this problem","width":273},{"text":"yes you're going to need some sort of flags or counters","width":533},{"text":"to keep track","width":377},{"text":"and rather than set them to one or zero","width":141},{"text":"we should add and subtract as people come in and want to read","width":308},{"text":"and I'll give you a clue: you're going to need some mutex locks","width":361},{"text":"at least one lock","width":102},{"text":"and some condition variables","width":1269},{"text":"we can start with one condition. let's do one condition variable","width":396},{"text":"you can add more if you want","width":93},{"text":"see if you can get something to kind of work with those","width":14756},{"text":"alright, let's have a go at grading the solution here","width":136},{"text":"I'm not gonna do the complete solution today","width":186},{"text":"I'm just trying to do this in stages","width":108},{"text":"we've seen two broken ones, I'm now going to try and write something which is a little less broken","width":371},{"text":"towards a complete solution","width":252},{"text":"we're going to be touching these variables so I'm going to use locks to make sure that when we access the values, it's actually read/written by one process at a time","width":935},{"text":"so now in reader, what we'll do is we'll see if we've got any writers trying to do anything","width":612},{"text":"then I want to wait","width":182},{"text":"but rather than having a busy loop, I'm going to meditate","width":263},{"text":"here we go, condition wait","width":196},{"text":"and I'll go to sleep","width":182},{"text":"so, if I come out of that, I'll check to see if there's any writers","width":157},{"text":"and if there are, then I'll go back to sleep again","width":392},{"text":"alright, before doing anything, I'm going to increment my little counter here. the number of readers has now gone up by one","width":591},{"text":"and then I can actually access the data structures so I'll do my reading here","width":469},{"text":"then I'll declare that \"hey! I finished! hey, there's no more readers\"","width":439},{"text":"and I can unlock","width":282},{"text":"the mutex","width":206},{"text":"yes, I can see that we've only going to actually allow one reader at a time, but trust me, for now this is a good stepping stone to a more complete solution","width":614},{"text":"what about the writers?","width":229},{"text":"well, they need to wait while there's any readers  (so any readers greaters than zero) or any writer greater than zero","width":573},{"text":"we want our writer to sleep","width":206},{"text":"great, I know a fantastic way to do that. let's call my cond_wait and pass in the pointer to the condition variable and a pointer to the mutex","width":625},{"text":"so we can only get out of this little loop once there's no other readers and no other writers","width":509},{"text":"before doing the writing, I'm going to increment my write count, then I'll do the writing","width":560},{"text":"afterwards, I'll decrement my write count and I'll unlock the mutex","width":1229},{"text":"I've got my readers and writers sleeping. if they are unable to continue, they'll sleep. we never wake them up.","width":674},{"text":"we....probably want to wake them up occasionally, yes?","width":393},{"text":"we could try to be clever when we should bash the gong","width":304},{"text":"when should we wake everybody up","width":132},{"text":"but I'm not going to do that right now","width":102},{"text":"I'm just going to put the code in down here that says \"well look, if I finish writing, maybe there's another writer waiting\"","width":596},{"text":"so hey, let me bash the gong here","width":157},{"text":"so pthread_cond_broadcast","width":542},{"text":"wake everybody up!","width":489},{"text":"alright, so, anybody that's sleeping, hey! wake up and check your condition, check your invariant, check the loop that you're inside","width":446},{"text":"do I need to do the same inside the read call as well?","width":1438},{"text":"so if there's a writer that is waiting, we should call p_cond_signal. could it be that I've got new readers in here?","width":1227},{"text":"cuz they might get the signal instead","width":104},{"text":"you can say \"okay! that's fine!\" or you might say \"actually that's impossible\" and never happen. even if it's impossible, they still end up signaling someone, so I could either call signal or broadcast here","width":1060},{"text":"so that's my next attempt. what do you think of it?","width":397},{"text":"it's better than the busy wait we saw a moment ago, but, what?","width":403},{"text":"thank you! right now, we've still got the problem of only one thread can actually do the reading because we lock the mutex.","width":470},{"text":"okay, we're going to have to fix that. other problems with it?","width":1305},{"text":"okay, so you're worried about mutual exclusion. actually, the beautiful thing is that our while loop will be checked each time and because we've got locks here, we can reason abotu this much more simply.","width":894},{"text":"because we locked this, we know that only one thread at a time can ever be executing inside this critical section, inside this code that we've written","width":1123},{"text":"hold on, I see what you're saying. but we're only incrementing the reader afterwards","width":275},{"text":"yeah, it's easy to see that initially, but remember we're going to wake these writers up but they don't actually check the values of r and w until","width":849},{"text":"we unlock the mutex","width":166},{"text":"okay so they're ready to go, they're about to run, but they don't get to return from this condition wait until we say so","width":493},{"text":"so they can only see a decremented version of the reader","width":635},{"text":"right so, we're heading towards a good solution but we've got more work to do","width":436},{"text":"one problem you might think about is, what would happen if I had a lot of readers?","width":539},{"text":"the poor writer is stuck! it never gets to change the data structure. readers barge in there and our read count never goes to zero","width":803},{"text":"so remember this magic saying called \"bounded wait\"?","width":230},{"text":"which is about, don't let the small kids just run in front of you?","width":297},{"text":"if you've been waiting, there should be a finite number of other processes to allow to continue before you get a fair chance","width":463},{"text":"we haven't succeeded in that yet either","width":210},{"text":"but anyways, this is towards a good solution","width":211},{"text":"so now, I need to change topic because first of all, you have a quiz on friday!","width":300},{"text":"woohoo!","width":63},{"text":"it's about memory allocation","width":276},{"text":"you can expect these kinds of questions!","width":225},{"text":"alright, does code data heap and stacks inside your memory?","width":372},{"text":"you know how to use pthread, and pthread_exit, and pthread_join and what the differences between pthread_exit and pthread_join","width":403},{"text":"you know what free(NULL) does. answer: nothing","width":274},{"text":"pthread_create succeeds, what does it return, zero, you get the id by giving it a pointer instead","width":350},{"text":"can you use a function that's not thread safe in a multithreaded program?","width":342},{"text":"what the answer? yes you can, but you've got to make sure only one thread at a time accesses it","width":570},{"text":"gosh, when do you knew about pthread_mutex_lock","width":164},{"text":"so yes you can, but you have to be careful","width":409},{"text":"pthread join man, okay, so enough about pthread_join","width":275},{"text":"boundary tags, oh yes! here's a memory allocator that we did not talk about in lecture","width":332},{"text":"but rather than making allocations the size that the user requests, we can have chunks which are 2^n sizes","width":972},{"text":"so if I have a pool of a 1024 bytes, we can split that into two allocations of 512, for example","width":657},{"text":"or I can split this 512 into two allocations of 256","width":341},{"text":"so if I keep my chunks at sizes 2^n","width":354},{"text":"then I can very quickly and efficiently find an allocation of the correct size","width":636},{"text":"so, for example, if I wanted 65 byte allocations, I would end up using allocations of 128 bytes","width":899},{"text":"and so, if I had 1024 bytes to play with, I could make eight of those allocations","width":375},{"text":"so you can see that this kind of allocator, which by the way is called the buddy allocator, suffers strongly from fragmentation","width":651},{"text":"I'm going to give you a block of 128 bytes, but you're only going to use 65 bytes of it","width":563},{"text":"so it can end up having a great bit of a unnecessary space, but the good news is that it's very very fast to find a free block of sufficient size","width":956},{"text":"implicit and explicit free lists? you've seen this now in the MP contest that we can have a separate list of free blocks","width":659},{"text":"so it's much much quicker to find a free block rather than scanning through a linked list of all free and allocated blocks, why not have a second linked list which only contains the free entries?","width":1038},{"text":"so that's an explicit free list","width":141},{"text":"and if we do that, we can put it inside the unused space","width":664},{"text":"okay so you know about first fit and worst fit and how they work","width":484},{"text":"and you know what malloc() and calloc() do if they can't return the request.","width":306},{"text":"alright good, I have a moment left","width":254},{"text":"good news and bad news. I've got some sad news for you in a sense. monday and wednesday, I'm going to be in california","width":802},{"text":"so, robin is going to be taking this lecture slot. and she's going to be talking about some 241 content","width":458},{"text":"you're in safe hands. she's taught this course before","width":176},{"text":"I'm talking about andriod mook and representing illinois at the coursera partners conference","width":471},{"text":"this course, which ran in december 2013, we the largest ever course by illinois","width":370},{"text":"at 143,000 people signed up. we've since had 200,000 people sign up","width":325}],

  // Start Lecture Video 12
  // Part 0
  [],
  // Part 1
  [],
  // Part 2
  [],
  // Part 3
  [],
  // Part 4
  [],
  // Part 5
  [],
  // Part 6
  [],
];
