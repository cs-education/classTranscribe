// Data structure that holds captions for the videos
var videoCaptions =[
  // Video 1
  [{"text":"Okay welcome to systems programming","width":200},{"text":"so let's get started","width":51},{"text":"let's write our first c program","width":103},{"text":"that makes use of a system call","width":144},{"text":"i'll do an example and then I'll let you play as well","width":219},{"text":"so uh here's a little virtual machine","width":146},{"text":"i've got up and running","width":122},{"text":"and i can write a little c file here","width":158},{"text":"so what we're going to do is make use of a system call called write","width":306},{"text":"so let's try this","width":52},{"text":"we'll say okay write","width":102},{"text":"and then i need to give it a file descriptor","width":213},{"text":"more about that in a moment","width":84},{"text":"a little message like hello","width":201},{"text":"and then the number of characters or bytes that i actually want to send here","width":267},{"text":"so h e l l o","width":179},{"text":"that's five bytes we're going to send","width":238},{"text":"so let's try compiling this","width":203},{"text":"and once that's going we'll see that whoops","width":233},{"text":"we've got a little bit of a problem here","width":118},{"text":"that write was not declared before","width":248},{"text":"okay so the c compiler here is warning us that we're trying to call a function called write which hasn't yet been declared","width":538},{"text":"so we could declare it","width":109},{"text":"now i happen to know for example that the write signature looks a little something like this","width":261},{"text":"it takes um, it's called write ","width":200},{"text":"it takes a file descriptor which is going to be an integer","width":161},{"text":"it takes a pointer to a character","width":183},{"text":"and it takes another integer which is the number of characters to write","width":273},{"text":"so it looks a little bit like that","width":97},{"text":"in fact it takes a void pointer which means point to it without any particular type","width":600},{"text":"so i could attempt to compile this for example","width":220},{"text":"see if this works","width":152},{"text":"and oh ho ho","width":34},{"text":"if we look at the left hand side","width":80},{"text":"we can see we managed to compile a program called program here","width":252},{"text":"and when we ran it we got hello","width":102},{"text":"alright so let's do a little better then that though","width":240},{"text":"rather than me having to manually write the declaration in here","width":313},{"text":"these are already included inside an existing file which I get for free","width":326},{"text":"it's actually unistd.h","width":229},{"text":"okay so let's tell the preprocessor to read in the contents of the file","width":251},{"text":"go in and find a file named unistd.h","width":179},{"text":"and include all the text that is in that file","width":179},{"text":"okay so now when we run this","width":193},{"text":"we'll compile it and run it and great it prints out hello","width":167},{"text":"if i wanted to print out hello with a new line","width":194},{"text":"let's increment this to six","width":154},{"text":"and now i've got a program called Hello","width":166},{"text":"okay great and of course i could make my program print out hello world and do it on two different lines","width":752},{"text":"alright so uh that's my program working","width":171},{"text":"now it's time for you to play","width":120},{"text":"you create which uses a system call write","width":237},{"text":"to write a little message on the two lines","width":219},{"text":"see you in the next video after you've said hello to the world","width":255},{"text":"bye","width":133}],
  // Video 2
  [{"text":"so let's talk more about that file descriptor","width":185},{"text":"I'm gonna make my program be a little bit more useful by printing out \"Hello World\" a few times","width":325},{"text":"so for example, I have a variable 'count' here and a little for-loop","width":335},{"text":"Start with count equal to five, while count is greater than zero","width":275},{"text":"each time around the loop we're going to decrement 'count'","width":270},{"text":"In C, there is no boolean type.","width":183},{"text":"instead, if I've got an integer value which is nonzero, that is treated as a true value","width":385},{"text":"So, I could actually write this more tersely just by saying \"hey, count!\"","width":323},{"text":"meaning is count a non-zero value","width":193},{"text":"and if you compare two things, you'll learn that with an integer value of either 0 or 1 to mean for example if they are either the same or different","width":497},{"text":"so, we're going to print out \"hello world\" 5 times","width":442},{"text":"I want to show you just a little idea here that actually I've got two file descriptors which are valid when my program starts.","width":519},{"text":"And they're called 1 and 2.","width":174},{"text":"Why might it be useful to have two output streams?","width":236},{"text":"well, you can imagine we have a program that is calculating something","width":266},{"text":"for example it's thinking of something to say or it's going to write to a file","width":282},{"text":"but we may also want to display some error messages back to the user","width":190},{"text":"or we might want to print some progress information","width":360},{"text":"the first output stream identified by the number '1' is the regular output, standard output","width":456},{"text":"The second one is reserved for error messages.","width":354},{"text":"Let's, for example, use this. Instead of error messages, we'll put a little dot to see this","width":419},{"text":"We'll run this and we should (if we got everything correct) see \"Hello\" and...lib lib lib lib","width":771},{"text":"Now, why do we see \".lib\", because we said \"hey, I'm going to give you a pointer and I want you to use that pointer and take the next 6 bytes from it which is the next  six character","width":886},{"text":"So we just got whatever happened to be in memory after our dot. So, we only wanted to do the dot","width":646},{"text":"Change that and run it again","width":195},{"text":"And great, we've got Hello and dot Hello dot Hello","width":195},{"text":"So, right now, both the output and the standard error are going to different places","width":352},{"text":"we could actually change that over here in the console before we start the program","width":277},{"text":"Our terminal can actually control where the output goes","width":256},{"text":"So, for example, I might say, I want to take the standard output and put that into a file.","width":344},{"text":"So, \"output.txt\"","width":153},{"text":"So now, if I run this before the program starts, I'm going to redirect it's output into this new file","width":531},{"text":"Okay, so what we see on the console output is anything written to standard error","width":308},{"text":"The standard output is inside output.txt","width":196},{"text":"To prove it, let me have a look at that file.","width":205},{"text":"Let me cat that file","width":94},{"text":"So, output.txt","width":145},{"text":"And here it is! It says \"hello, hello, hello, hello\"","width":239},{"text":"Now, rather than writing 1 and 2 over here, perhaps we should actually have some constants","width":359},{"text":"which signify what those values actually mean","width":238},{"text":"so we could say start define things to say have a constant here, I'll call it say \"STDOUT_FILENO 1\"","width":707},{"text":"And I'll say define STDERRFILENO 2","width":480},{"text":"so anytime you do hash define, you're talking to the preprocessor to say \"hey, in the future, parts of this file, if you come across this character sequence, then replace it (in this case) with either a 1 or a 2 depending on what it is\"","width":1084},{"text":"We can compile this, except I've got a surprise for you which is that these particular macros are already defined inside unistd.h","width":705},{"text":"So, I don't actually need to define them here in my program.","width":302},{"text":"So that's my little program. You see it's got a return value of zero. Which is a convention for being correct (no errors)","width":636},{"text":"But it's up to us. We could choose a different value, for example we could choose the value 42.","width":555},{"text":"And, I don't see an output value, but I can find out what the last exit value was of the last process","width":569},{"text":"Let me print it out","width":133},{"text":"It happens to beinside special variables","width":140},{"text":"so I could say \"Hello terminal value of this dollar question mark.\"","width":308},{"text":"which means give me the exit value (or the exit status) of the last command run.","width":347},{"text":"So there's our forty-two.","width":153},{"text":"Okay so, we've covered quite a bit of ground. We've talked about how in C, any non-zero integer is considered \"true\"","width":804},{"text":"and zero is considered \"false\"","width":235},{"text":"And, we've talked about these two different output streams. Now it's your turn to play with this. After that, let's have a go at creating some new files directly from C","width":831},{"text":"by making system calls","width":160},{"text":"So, now it's your turn. Have fun playing! Bye.","width":300}],
  // Video 3
  [{"text":"Welcome so let's start creating some files","width":334},{"text":"for that we can use the system call open()","width":194},{"text":"and for open we need to say whether we want to append to an existing file, create a brand new file, and we need to give it a filename","width":683},{"text":"For example, I might have a file name called \"output.txt\"","width":396},{"text":"so the open call takes 2 or 3 arguments. the second argument will be exactly what we want to do","width":557},{"text":"so in this case we want to say create a brand new file and truncate it back to 0 if it doesn't exist","width":469},{"text":"so, I want to truncate as well","width":237},{"text":"if we are creating a new file we better say who can read this file and who can write to this file and who can execute this file","width":533},{"text":"so we are going to have to say something about the mode flags ","width":346},{"text":"who is allowed to do what","width":89},{"text":"finally this call is going to give us back an integer, a file descriptor","width":272},{"text":"just like we've seen so far with file number 1 and file number 2","width":211},{"text":"so lets store that inside a little variable","width":219},{"text":"ok, so now I better actually find out what the correct syntax is","width":374},{"text":"and the correct arguments are in order to create a file","width":301},{"text":"so lets go and look that up","width":153},{"text":"and that we'll find inside the manual","width":187},{"text":"And, if, for example, I type \"man open\" on a command line on a real linux machine. it doesn't quite work yet in my small virtual one. we didn't have enough memory to include all the manual pages yet","width":887},{"text":"but heres a linux manual page I found on the web for the open()","width":342},{"text":"and you'll see here's the function signature here","width":301},{"text":"where we're going to pass in an integer for the flags and the mode type","width":297},{"text":"so, I'm going to look up now the flags I need to open and create a new file","width":463},{"text":"I don't want to do append()","width":106},{"text":"I want to use \"create\" and I want to truncate it as well","width":404},{"text":"let's include \"O_CREAT\" here. I'm going to say \"O_CREAT\" which is a constant and I'm going to bitwise OR it with the flag to say \"truncate\" so let's look that up as well","width":1309},{"text":"alright and i want to say when i open it that i am going to open it for say reading and writing","width":592},{"text":"so let us grab that as well","width":220},{"text":"so that is the first thing","width":160},{"text":"now we need to do the mode","width":109},{"text":"Let's write this as a variable.","width":134},{"text":"and there is actually a typedef","width":192},{"text":"it is essentially an integer but it is wrapped up in this type here called mode","width":520},{"text":"mode_t","width":79},{"text":"and we'll say that with our file we want to be fairly private and only the owner of the file can access it","width":594},{"text":"Let's go back up and find those flags, where are you? Here we go.","width":387},{"text":"We'll say that the user has read and write permission","width":343},{"text":"We'll copy the read one and we'll have write permission as well.","width":839},{"text":"But no one else in my linux system will be allowed to read it and write it.","width":476},{"text":"So that's the permissions we want","width":216},{"text":"What can we do with this?","width":82},{"text":"Well let's write something out to this file.","width":473},{"text":"We will write a little message \"Great!\" and a newline","width":506},{"text":"so how many characters is that? I've got \"one, two, three, four, five, six, and a new line so that's seven characters\"","width":612},{"text":"then we'll close this file descriptor meaning we don't want to use this descriptor anymore","width":436},{"text":"that will ensure as well that all of the bytes that we send to the file stream have been saved","width":621},{"text":"We're not doing any error checking right now, we're just trying to write the smallest possible program to create a file and send something to it","width":563},{"text":"let's run this and see what we get","width":239},{"text":"we'll run into an error which is: we haven't defined what this mode_t is","width":370},{"text":"what we forgot to do, was to do the includes","width":149},{"text":"the good news is that the man pages tell us which includes we need to put at the top of our program","width":637},{"text":"so let's grab those and insert them in here","width":285},{"text":"i will just get the formatting correct","width":279},{"text":"and, run it again","width":410},{"text":"Right so our program ran and it's still printing \"Hello\" to standard out and dot to standard error","width":418},{"text":"but hopefully, it also secretly created another file","width":215},{"text":"let's have a look at that file","width":136},{"text":"I can do \"ls\" and see if anything exists starting with \"out\"","width":493},{"text":"yes we've got output.txt. great!","width":140},{"text":"let's look at the contents of that file","width":154},{"text":"and it says \"Great!\" Fantastic","width":102},{"text":"Right so now it's your turn to play: create a file and see if you can send some bytes to that file.","width":518},{"text":"so you'll be using open(), write(), and close(). Bye.","width":296}],
  // Video 4
  [{"text":"Hello, suppose we want to actually print out some integer values","width":312},{"text":"write() doesn't give us that fuctionality","width":206},{"text":"write() is the low level call that we make to the operating system","width":252},{"text":"to say \"look, here's a pointer to some memory and please take so many bytes from that memory and send it out to a file\"","width":527},{"text":"or, possibly, another device","width":113},{"text":"if we want to change a bit pattern into a sequence of characters because we want to read, say, one-seven for the value seventeen","width":533},{"text":"that's not something that the system does","width":118},{"text":"instead, we've got some C standard library calls that we can call","width":256},{"text":"that do this for us","width":144},{"text":"and they will wrap the call to write()","width":186},{"text":"so as an example, let's try printing something out","width":329},{"text":"we can say \"printf my value is\"","width":387},{"text":"and I can say \"%d\"","width":134},{"text":"this means that the next argument I give in printf() better be an integer value","width":444},{"text":"so the bit pattern we pass to printf() will be treated as an integer","width":294},{"text":"to be displayed","width":73},{"text":"so let's have a little variable called result","width":220},{"text":"and I can say result is sixty five","width":404},{"text":"if I attempt to run this, we're using printf(), we haven't declared it beforehand so we get a warning","width":490},{"text":"to say \"oh, you're just using it.\" and, what we should've done is actually declare the function signature of printf()","width":580},{"text":"and that I know from looking at the man pages","width":248},{"text":"is inside stdio.h","width":195},{"text":"if you're coming from a cpp background, there's no IO streams","width":234},{"text":"we dont have operator overloading. instead, let's use printf()","width":211},{"text":"so we've got \"my value is 65\"","width":153},{"text":"and, you'll see that actually this was printed out after the hello hello hello hello","width":572},{"text":"here's why: printf() has a buffer. the C libraries have a buffer","width":250},{"text":"so it's only going to call write() when that buffer is full","width":248},{"text":"or if we explicitly tell it to","width":103},{"text":"or if we finish a line","width":157},{"text":"so let's put a newline in here and run it again","width":280},{"text":"this time, we've compiled it, and we should see that \"my value is 65\" appear before my hellos","width":523},{"text":"so this time, because we sent a new line, printf() will be making that call to write()","width":443},{"text":"to send its buffer out to standard out","width":347},{"text":"so now we can actually print out the value of our file descriptor","width":318},{"text":"let's do that. after we've opened our file, I'll send \"fildes is\" and, we will print out fildes.","width":1358},{"text":"and, let's get rid of the first one","width":157},{"text":"and let's flush our little buffer by sending in a newline","width":409},{"text":"and we'll see that our value is three","width":363},{"text":"so, we've opened up a file descriptor who's value is three","width":206},{"text":"in fact, that is expected by specification because if we successfully open a file, we'll get back the lowest unused integer (the lowest unused file descriptor)","width":809},{"text":"as one and two are already being used, we get back three","width":215},{"text":"so just for fun, let's actually close one of the existing file descriptors before we do the open()","width":547},{"text":"so let's close standard error","width":235},{"text":"I'm sorry, we'll close standard out","width":252},{"text":"and, we won't close our own file descriptor until the very end of the program here","width":545},{"text":"so I'm going to move that line down to here","width":164},{"text":"great, so, let's run this","width":457},{"text":"so, what did we do? we opened a file descriptor and now if we look at the output of the program, you'll see we're only getting our dots printed out on standard error","width":720},{"text":"why is that?","width":63},{"text":"what happened to our standard output?","width":63},{"text":"well, we better check out file output.text","width":221},{"text":"and you'll see that everything printed to standard out has been sent to our file","width":435},{"text":"why? because when we called open(), it gave us back a file descriptor for stream number one. and, that is the. that is where all the standard output is going to go","width":895},{"text":"so, all future output is being sent to our file","width":250},{"text":"this is a neat way if you'd like to do logging","width":252},{"text":"and we've just changed our program so that all future output goes to output.text","width":459},{"text":"now what if we've got a problem with open() ?","width":199},{"text":"right now, our code doesn't check for any error","width":221},{"text":"and, a better program would actually check the return values of our different calls","width":369},{"text":"for example, it could be that open() could fail. suppose, for example, we gave it a bad file descriptor","width":675},{"text":"now so we can see what's going on, I'm not going to close standard out anymore.","width":316},{"text":"I'm just going to give it a bad file name","width":234},{"text":"now, our program compiles correctly of course","width":192},{"text":"but this time our file descriptor is negative one","width":211},{"text":"so, we should check that","width":215},{"text":"in fact, if we check the man page of open(), it's always a good idea to check the section called \"return value\"","width":475},{"text":"and you'll see, it's specified here that we'll get back a negative one if an error occurred","width":318},{"text":"so the last thing we'll do today is let's capture that and quit if we get a bad error","width":340},{"text":"so, if fildes equals negative one","width":227},{"text":"a common error is to write equals instead of double equals for comparison","width":371},{"text":"and we want to quit here","width":171},{"text":"so we'll leave our program, so let's exit with a value","width":238},{"text":"to say: \"hey, we couldn't carry on\"","width":250},{"text":"I could've returned zero but I wanted to show you an alternative way to quit a C program is to call exit","width":327},{"text":"and we'll print out an error","width":398},{"text":"so, something bad happened while calling open","width":228},{"text":"so, we'll use perror()","width":269},{"text":"let's run this","width":246},{"text":"and, I get some implicit problem here that we're calling exit(). I need to find the right #include to call for that.","width":734},{"text":"but, you'll see on the lefthand side that we've got open() failed, so that's the part of the error message that I supplied","width":487},{"text":"followed by a colon followed by no such file or directories","width":213},{"text":"so it's complaining that my file name is bad","width":292},{"text":"if I had included a dot here, this is also an invalid file name because a single dot corresponds to the current directory","width":542},{"text":"and, it's complaining that it can't open that because dot corresponds to a directory","width":414},{"text":"so now it's your turn to play. bye!","width":240}],
  // Video 5
  [{"text":"Hi, so C is designed to be a portable language in a sense that we could write a C compiler for many many different hardware architectures","width":542},{"text":"from small embedded machines to large mainframes","width":284},{"text":"so C does not specify a precise number of bits required for, say, and integer","width":394},{"text":"instead it specifies minimums that should be supported by the architecture","width":348},{"text":"let's have a look at that. let's see how we can find out how large or small of numbers we can store in different types","width":385},{"text":"and also how many bytes each different type is ","width":209},{"text":"and even further, what is a byte?","width":183},{"text":"so let's start with our integers","width":152},{"text":"I could say hello but what's the largest value I can store inside my integer type?","width":438},{"text":"fortunately, there's some macros, some constants, defined inside limits.h","width":677},{"text":"let's find out what these are","width":209},{"text":"the int min and max is going to be %d and %d and INT_MIN and INT_MAX","width":753},{"text":"so, we'll print that out. I'll get rid of my unnecessary variable here","width":240},{"text":"let's run that","width":91},{"text":"and we see that on this particular machine, that an integer can represent numbers from roughly minus 2 billion to plus 2 billion","width":649},{"text":"a very wide range of numbers","width":135},{"text":"C promises that we'll be able to store the numbers between minus 32768 and plus 32767","width":460},{"text":"in other words, an integer will be at least 16 bits","width":292},{"text":"what else do we have? how about a character?","width":180},{"text":"well, here's a surprising thing, a character is one byte","width":225},{"text":"so what do we mean by byte?","width":113},{"text":"surely we mean 8 bits? no.","width":224},{"text":"though we often say a byte means 8 bits in modern parlance, it doesn't have to be true","width":421},{"text":"and in fact, C is very careful to say that a byte does not mean 8 bits","width":294},{"text":"it means at least 8 bits","width":101},{"text":"our character, then, is at least 8 bits","width":184},{"text":"so why this distinction?","width":122},{"text":"well, in being portable, C needs to be able to read and write every bit inside memory and each bit inside each memory should only live inside one addressable memory location","width":875},{"text":"and, it could be that architecture have very different numbers of bits it can read or write","width":515},{"text":"for example, an early PDP machine had a 36 bit wide addressable memory","width":394},{"text":"so, C does not attempt to say it's going to be exactly 8 bits","width":396},{"text":"so how do we find out how many bits are actually in a character?","width":254},{"text":"well, again, the limits.h includes a useful constants here","width":404},{"text":"a character is %d bytes","width":197},{"text":"let's go and see what that is","width":114},{"text":"so CHAR_BITS","width":129},{"text":"and we'll print that out","width":471},{"text":"on this architecture, a character is 8 bits","width":181},{"text":"that's typical on modern machines","width":283},{"text":"so what if I wanted to know the actual number of bytes in different types?","width":247},{"text":"for that, we have something called sizeof","width":306},{"text":"we can give it a type and it will tell us how many bytes (or if you prefer, how many characters) are required to hold that particular kind","width":468},{"text":"so for example, let's find out how big an integer is on this machine","width":334},{"text":"perhaps you can guess the answer already","width":136},{"text":"so, sizeof int is %d and we'll have a newline as well","width":903},{"text":"is it any surprise that the size of an integer on this particular machine happens to be 4 bytes","width":354},{"text":"and that's not surprising because we need thirty two bits to represent all numbers between minus two billion and plus two billion","width":529},{"text":"there are other integer types you'll see things like short (which is generally shorter than an int), long (which is generally longer), long long (which is even longer, still)","width":843},{"text":"and compilers even occasionally provide their own custom types as well","width":257},{"text":"notice as well that these types are signed","width":422},{"text":"so we can represent negative numbers and plus numbers","width":176},{"text":"C also provides the idea of being able to say that we can have an unsigned version","width":450},{"text":"so, for example, I can have an unsigned int","width":255},{"text":"now there is no signed bit that is included in the bitwise representation","width":439},{"text":"so that's great if you wanted to represent all the numbers between zero and 4 billion on this particular machine","width":355},{"text":"the character type can actually be signed or unsigned","width":343},{"text":"depending on the particular implementation of the C language for this particular architecture","width":404},{"text":"so that's enough for now","width":142},{"text":"in the next video, we will talk about pointers","width":137},{"text":"now it's time for you to play and learn a little bit about the basic C primitives. Bye!","width":394}],
  // Video 6
  [{"text":"Now let's talk about pointers and arrays","width":224},{"text":"how might I make an array of integers?","width":179},{"text":"let's say I had some data and I did this","width":241},{"text":"well, on this particular architecture we just found out that an integer is four bytes","width":272},{"text":"so I've now got thirty two bytes of storage","width":226},{"text":"and in fact, it's going to be thirty two bytes on the stack","width":209},{"text":"so what do I have here?","width":120},{"text":"when I say data square brackets eight, I'm going to get back four times eight, thirty two bytes all together","width":456},{"text":"all contiguous in memory","width":117},{"text":"and in fact, data is going to point to  the very first four bytes","width":240},{"text":"so I've got four bytes and then four bytes and then four bytes and then four bytes and so on","width":364},{"text":"let's have a look at that","width":116},{"text":"so, if I say printf data is at and this time do %p, that means treat data as and print it out as an address","width":760},{"text":"so we'll print this out","width":538},{"text":"and we see we've got a value here in memory","width":253},{"text":"that data points to the very first element","width":191},{"text":"let's do something a little bit surprising here","width":133},{"text":"let's add one to data and print that out","width":257},{"text":"so, data plus one","width":161},{"text":"and we'll do data plus two","width":244},{"text":"and so on","width":626},{"text":"so, if we look over here at our output, we'll see that each time we add one, our address in hexadecimal is going up by four each time","width":563},{"text":"so we've got 9d40, 9d44, 9d48","width":323},{"text":"here's why","width":43},{"text":"when you add an integer to an address pointer","width":308},{"text":"C knows the type of that pointer","width":209},{"text":"so in this case, we're pointing at integers","width":135},{"text":"so each time we add one, we actually want to progress to the next integer stored in memory","width":306},{"text":"and as each integer takes four bytes, that's why our address is going up by four each time","width":483},{"text":"so how could I use this?","width":101},{"text":"well, one way is to use asterisk which means use the address so, for example, I can say data the parenthesis are not strictly necessary but we'll use them in a moment","width":941},{"text":"and let's say store the value a hundred in there","width":188},{"text":"what about if I wanted to store some value at the next entry?","width":383},{"text":"ok so, hundred, hundred one","width":123},{"text":"so now I've stored the value a hundred that integer pattern into the first four bytes","width":376},{"text":"and the integer pattern for a hundred and one in the next four bytes","width":358},{"text":"and I guess you could figure out what this would do as well","width":374},{"text":"the asterisks means use the pointer follow the pointer dereference the pointer","width":409},{"text":"in other word, we've got an expression which is a memory address, now I want to use it","width":291},{"text":"now I actually want to use that pattern that bitwise pattern to actually read or write some memory","width":469},{"text":"so that's what the asterisk does means actually okay it's time to go and talk to memory","width":288},{"text":"this is so useful with arrays","width":127},{"text":"there is an alternative syntax which is to use the square brackets","width":228},{"text":"so for example I could have written the following","width":300},{"text":"which means take my address pointer add two to it and use that address for the array","width":473},{"text":"so these last two lines are the same","width":133},{"text":"in fact, here's a little secret about C that I could actually swap these around","width":319},{"text":"so we could also write this in this slightly crazy way","width":418},{"text":"so this is crazy but actually two square bracket data would evaluate to the same thing","width":396},{"text":"so that's something to confuse your non-C friends with","width":377},{"text":"that's enough with me playing with integer pointers","width":272},{"text":"now, it's your turn. Bye!","width":188}],
  // Video 7
   [{"text":"so what about strings in c?","width":131},{"text":"what if I said","width":99},{"text":"\"hello\"","width":79},{"text":"how is this represented? well clearly it's made up of characters","width":214},{"text":"and I've got five characters to display","width":218},{"text":"h e l l o, but actually C strings contain an extra character at the end","width":325},{"text":"a zero value or null character to say \"hey this is the end of the string\"","width":383},{"text":"so this is going to take six bytes of storage","width":196},{"text":"let's see if we can prove that","width":106},{"text":"we'll say printf() and \"Size of hello is %d\"","width":420},{"text":"and we'll have a little expression here to say what is the sizeof() \"hello\"","width":658},{"text":"and we'll print it out and you see that size of hello is 6","width":477},{"text":"h e l l o that's five, plus an extra byte for the 0 to say that's the end","width":410},{"text":"so we can use sizeof() on constant strings","width":339},{"text":"we could also run through the string to actually find the 0 byte ourselves","width":408},{"text":"so let's do that","width":79},{"text":"let's have a pointer to a character","width":279},{"text":"I will initialize it to my string \"hello\"","width":347},{"text":"which means pointer is initially pointing to h the first character","width":448},{"text":"I'll have a little count variable here","width":161},{"text":"and let's say \"while the pointer the value is not equal to 0\"","width":676},{"text":"I want to do something","width":83},{"text":"lets increment the pointer","width":72},{"text":"lets move it onto the next character","width":115},{"text":"and let's increment our count as well","width":185},{"text":"so we can find out how many characters we have","width":261},{"text":"and then at the end we will say how many characters we found","width":461},{"text":"which are not the 0 byte","width":276},{"text":"so if our program works this should find five characters","width":324},{"text":"lets run it and i'll put in a new line at the end","width":707},{"text":"our little loop went around five times and all it did was increment count","width":302},{"text":"we could have made it of course print out each one of those letters","width":254},{"text":"we could also simplify our program a little bit","width":142},{"text":"because as you know any non-zero value is treated as true","width":342},{"text":"so let's remove that and say while star pointer","width":245},{"text":"and when we get to the null byte we will finish","width":197},{"text":"so just for fun lets change our program as well before we increment the pointer to print out the next characters","width":603},{"text":"my format string is just %c. and what character would I want? well the one pointed to by the pointer","width":493},{"text":"pointers to characters that Â each character is exactly one byte","width":353},{"text":"so when we add one to our pointer, line ten here","width":266},{"text":"we are actually just going to add one to it","width":176},{"text":"because each character is exactly one byte","width":165},{"text":"so there's our program and it managed to print out exactly \"hello\"","width":538},{"text":"do we need to write this every time that we want to find out the number of characters in a string?","width":397},{"text":"no! guess what there's a function called strlen()","width":190},{"text":"so instead of my little loop if I include string.h","width":413},{"text":"I've now got strlen()","width":92},{"text":"so let me check the two results","width":212},{"text":"instead I'll say len is strlen() and pass it a pointer to my character","width":394},{"text":"I'm tempted to use pointer but that would be a bad idea","width":209},{"text":"perhaps you can figure out why","width":159},{"text":"so \"Strlen returned\" and we'll talk about how to fix my program in a moment","width":621},{"text":"so we'll run this","width":454},{"text":"strlen() returned 0","width":104},{"text":"why? because by the time my loop finished I'd advanced that pointer on until it had reached that null byte","width":395},{"text":"so when we passed that to strlen() it immediately found the null byte","width":209},{"text":"now what we should do is evaluate our strlen() before we change our pointer","width":962},{"text":"the last thing we'll do today is make our program crash","width":201},{"text":"let's try and change our first character to be someting else","width":396},{"text":"like 'J' turn it into Jello","width":283},{"text":"so let's dereference that pointer and use it to push in a character","width":397},{"text":"I don't want to have a string, i actually want to have a character","width":322},{"text":"let's try that and see what happens","width":296},{"text":"I get a segmentation fault when I try to run that line","width":189},{"text":"here's why, different parts of my proccesses' memory are valid for reading or reading and writing","width":549},{"text":"the program code, the actual assembly, the actual instructions for the cpu, can only be read","width":418},{"text":"and my constants, such as this \"hello\" can only be read","width":274},{"text":"and the hardware is sophisticated enough to know which parts of memory are read and which parts of memory are read/write","width":487},{"text":"and which parts of memory are invalid","width":147},{"text":"so that's why I get a segmentation fault if I try to change the constant memory","width":383},{"text":"alright time for you to play with character poitners, bye","width":270}],
  // Video 8
  [{"text":"So this video is about how to have an argument","width":174},{"text":"let's have a look inside some directories that we've got on our little system","width":281},{"text":"so if I type ls /bin","width":170},{"text":"you'll see here's a whole lot of programs that I can run from my terminal window","width":298},{"text":"and some of them you might recognize already","width":123},{"text":"including ls for list the contents of a directory (what we just did)","width":243},{"text":"cat to list the contents of a file and print it out","width":213},{"text":"and echo simply to echo back whatever we type","width":260},{"text":"so I can say echo Hello World","width":196},{"text":"and we also can used echo to print out the result of the exit value of the last program run","width":364},{"text":"how is it that these programs then can find out the parameters (the arguments) that we supply?","width":456},{"text":"when they are run?","width":90},{"text":"and the answer is that actually our main method can have two parameters here","width":339},{"text":"we have an integer (the number of arguments here) and also an array of character pointers","width":601},{"text":"called argv for value","width":206},{"text":"so let's actually print out some of these things","width":218},{"text":"so we'll say printf and we'll have the argv, the very first entry, the zero-th index is this","width":600},{"text":"and we'll say argv of zero","width":157},{"text":"and we will also print out what the last thing points to","width":384},{"text":"so that's going to be argc","width":190},{"text":"so that's %p","width":143},{"text":"we'll have a new line or two","width":135},{"text":"alright, and change that argc","width":311},{"text":"so here's two surprising things","width":176},{"text":"first of all, the very first entry is actually the execution name of the program","width":291},{"text":"how we started the program","width":150},{"text":"here, our program is just called \"program\"","width":298},{"text":"and secondly, there is actually one extra argument at the end and that points to the null string","width":417},{"text":"our pointer is null, it's zero","width":264},{"text":"so, let's now actually print out the other values","width":359},{"text":"we'll find out what the other values of argv is","width":628},{"text":"and we'll loop through and we'll print out all of those values","width":258},{"text":"so I'll have a little count. I'll start from 1 this time.","width":226},{"text":"because we don't want to print out the program name","width":343},{"text":"I can say: while count is less than argc, because I don't need the null pointer at the end","width":457},{"text":"and each time around the loop, increment count","width":274},{"text":"I'll print out the value of my count that's %d and print out its value as a string","width":565},{"text":"ok so that's going to be count and argv at index of count","width":442},{"text":"finally, let's put a new line in here","width":173},{"text":"here's my mistake: I should have said argc here for count","width":297},{"text":"ok, let's print it out","width":296},{"text":"when we start, argc is just 1. we've got just the program","width":197},{"text":"run it again but this time but this time have \"cat hat sat\"","width":277},{"text":"and you'll see I've got three additional arguments","width":254},{"text":"if I had put that inside double quotes then the hat and sat would be one argument","width":565},{"text":"so you see that we can now send our arguments","width":199},{"text":"for example, I could write a little program that helps me add up some numbers","width":370},{"text":"and I need a simple way to turn a string of digits into an integer","width":444},{"text":"in other words, I want to go from ASCII to an integer","width":136},{"text":"so this is the simplest way of turning a string into an integer number","width":466},{"text":"but this function doesn't give us much error checking","width":123},{"text":"if it can't read it, it simply returns zero","width":121},{"text":"I'll talk about how we can do a better job using scanf in a different lecture","width":238},{"text":"so we'll add those up and we'll print the result. right so we've got a result of zero","width":425},{"text":"let's try running our program again with 10 20 30","width":280},{"text":"and we see we get a result of 60","width":205},{"text":"if I had put some non-numbers in here, I get the result ten because the string I've got here it's converted into a zero","width":821},{"text":"alright, that's enough from me. now it's time for you to play. bye!","width":257}],
  // Video 9
  [{"text":"hi so this video is about the environment","width":260},{"text":"so in addition to being able to set arguments to our little programs","width":317},{"text":"each program also has access to environment variables","width":229},{"text":"let's have a look at those now","width":104},{"text":"so in my shell over here","width":149},{"text":"so my terminal window","width":63},{"text":"if i type for example set","width":117},{"text":"i can see a list of environment variables","width":181},{"text":"so these can be used by the shell and any other programs that we start to help configure their behavior","width":316},{"text":"for example we see down here that I am running as superuser","width":377},{"text":"as the root on this little system here","width":188},{"text":"we can also see that my home directory is in slash root","width":258},{"text":"so that's where kind of root's files will be stored","width":236},{"text":"great so how will i get access to that in my c programs","width":274},{"text":"well there's two ways","width":118},{"text":"first of all there's a variable called environ","width":301},{"text":"which if we are running in an older posix environment","width":280},{"text":"we have to specifically declare ","width":167},{"text":"in fact we say look there is somewhere in there is already a variable declared called environ and we just need access to it","width":475},{"text":"so that's what the extern keyword means","width":168},{"text":"we are not trying to say give me additional storage for this","width":149},{"text":"rather that the storage for this environment variable has already been made","width":210},{"text":"and we just want to be able to reference it inside our program","width":253},{"text":"so if i use that","width":173},{"text":"you'll see that it's actually a character pointer pointer","width":212},{"text":"in other words i'm going to dereference it twice","width":173},{"text":"the first time i dereference it","width":180},{"text":"i get a pointer and that pointer itself is going to point to character strings","width":297},{"text":"and i can keep moving along then to print out different environmental variables","width":342},{"text":"so if i had the same kind of pointer ","width":252},{"text":"i'll call it ptr and i initialize it to environ","width":341},{"text":"i could print out the very first one","width":234},{"text":"if i say let me print out a string and a new line and if I do star pointer we can follow that money if you like","width":710},{"text":"we can follow where that pointer points to","width":101},{"text":"so it points to the first entry in this array ","width":351},{"text":"so we can run this and we see i get the first environment variable","width":244},{"text":"which looks like a key or a name followed by an equal sign followed by its value","width":297},{"text":"so if i was to add one to the pointer","width":244},{"text":"then i move on to the next character pointer","width":196},{"text":"and i get the next entry","width":253},{"text":"so let's put that in a loop","width":121},{"text":"how can i do that","width":63},{"text":"well i can say while i might be tempted to write pointer but that's not going to be particularly useful","width":494},{"text":"instead i want to say whilst the thing that pointer is looking at is a non null value","width":322},{"text":"in other words whilst i have a valid pointer","width":214},{"text":"why? because i happen to know that this array has one extra entry at the end which is the null entry","width":400},{"text":"meaning that its got a pointer that points to nothing","width":139},{"text":"and let's also increment our pointer at the end","width":171},{"text":"great so we can run this and get a look at all of the entries","width":414},{"text":"in fact why don't we set a couple of entries here","width":258},{"text":"so export secret to be 123456","width":324},{"text":"let's try that and run our program again","width":183},{"text":"this time when we run it","width":128},{"text":"the environmental variable secret is part of the environment of our running program","width":480},{"text":"if you already know the name of the environment variable that you wish to use","width":346},{"text":"you can get to it directly","width":125},{"text":"so we can also say hey give me the environment variable and give it a name","width":287},{"text":"for example secret and this will give me back a pointer to a character array","width":603},{"text":"oops i better call it secret","width":188},{"text":"let's print it out and quit","width":163},{"text":"so the secret is and we can call exit","width":992},{"text":"great i've got a little program that can print out secrets","width":222},{"text":"so now i can make my program check that the secret is set for example","width":320},{"text":"for example if I try to get an environmental variable that doesn't exist","width":465},{"text":"then my pointer is actually going to be nil","width":288},{"text":"let me show you that","width":94},{"text":"let me try to print out the value of secret as an integer","width":486},{"text":"so my secret pointer is pointing to nothing","width":268},{"text":"we didn't set that environmental variable yet","width":126},{"text":"so we for example i could say look if secret is null then i'm not going to let this program run","width":662},{"text":"i am just going to stop","width":294},{"text":"so we'll stop and let's now change it so that very secret is something like abc","width":779},{"text":"and when we run the program again this time you'll see that secret is a valid integer value so that's just an integer representation of the pointer","width":793},{"text":"and we got back at that memory location the contents of that environment variable ABC","width":469},{"text":"okay that's enough for me now it's time for you to play","width":124},{"text":"bye","width":48}],
  // Video 10
   [{"text":"let's talk about strings today","width":165},{"text":"first of all, these two things are very different","width":171},{"text":"I could have a pointer to \"hello world\"","width":403},{"text":"or I could have an array of characters to \"hello world\"","width":492},{"text":"though both ptr and array points to the first letters","width":353},{"text":"some things that are noteworthy here is first of all they have different sizes","width":303},{"text":"so let's look at the sizes of each of these, perhaps you can guess what the result is going to be","width":405},{"text":"so you'll see the size of the pointer is the number of bytes to actually hold the character pointer","width":307},{"text":"which as this is a 32-bit machine is four bytes","width":226},{"text":"the size of array is the total size required to hold the whole array","width":420},{"text":"so when this code runs it's actually going to copy the contents of that string literal \"hello world\" into the new array object","width":564},{"text":"so in this case we need twelve bytes for that, eleven for \"hello world\" plus a twelfth to hold the null character at the end the bit pattern zero to say okay we've reached the end of the string","width":769},{"text":"their sizes is very different, plus remember that because we've made additional memory on the stack","width":496},{"text":"we can change it so I can change it to \"jello world\" for example","width":272},{"text":"let's start manipulating our string","width":234},{"text":"we'll do this on our array so we can actually make modifications to it","width":240},{"text":"how about we change all the 'l's to a different letter","width":242},{"text":"so we'll change and we'll pass the beggining of the array","width":255},{"text":"so let's pass in the array and afterwards we'll print what the array is so that's %s","width":985},{"text":"alright so I'll have my function called change down here and it takes a pointer to that memory","width":378},{"text":"so we don't need to return anything because we are actually going to be using the parameter to point to some memory that we are going to change","width":506},{"text":"what can we do with this?","width":121},{"text":"well let's have a little loop that says while(p) that says while p is non zero","width":433},{"text":"actually what we care about is whether p is pointing to memory that holds zero","width":316},{"text":"in other words, we've reached the end of the string","width":142},{"text":"we want to follow the pointer we want to dereference the pointer and for that we need the asterisk","width":290},{"text":"okay so what should we do with this. well we could change all of the letters","width":429},{"text":"for example we could blank it out","width":173},{"text":"we could say star p equals","width":147},{"text":"and it might be tempting to write an astericks here","width":376},{"text":"but that's not right because the asterisk means I've given the address of the asterisk","width":473},{"text":"so I'd be writing an asterisk into the address of the asterisk into that occasion","width":483},{"text":"if I run this I get a few warnings","width":134},{"text":"but it runs and it runs it for forever because my loops runs forever","width":257},{"text":"so let me ctrl-c that to break it","width":171},{"text":"this time change the loop so I add one to p each time","width":504},{"text":"so now I've got a very strange character because it's taken the lowest eight bits and copied that into my character","width":555},{"text":"instead let's change that to the actual bitwise pattern of my character","width":326},{"text":"now I've got something which can get rid of swear words by over writing them with asterisks or perhaps a password or something","width":573},{"text":"but we didn't want to do that for all the characters, we just wanted to do that for the l's","width":208},{"text":"so let's see if my p is, at when I look at that memory location, whether it's a lowercase l","width":594},{"text":"and as I said before because we are working with characters it is ok to compare them so note the use of double equals here","width":553},{"text":"okay so let's run that","width":341},{"text":"we have a couple of errors here","width":204},{"text":"for starters we're not using pointer","width":150},{"text":"so I can comment out that line","width":111},{"text":"I've got another problem here which is that change is implicitly declared","width":289},{"text":"that's because we haven't declared what the function signature of change() looks like","width":301},{"text":"let's do that now","width":89},{"text":"I'm going to say later on compiler, I expect to actually define a function and I'll give you the actual code to create this change method","width":700},{"text":"but for now here is what it's signature looks like","width":153},{"text":"it's called change, it takes a pointer to a character and it doesn't return anything","width":272},{"text":"so if I compile that now my warnings should go away","width":283},{"text":"great so I've got a function that can walk through","width":402},{"text":"I could have another function that finds letters as well","width":186},{"text":"so for example suppose we wanted to find the first o in this","width":503},{"text":"I could change this so that rather than changing the letters","width":413},{"text":"if the contents of p is an 'o', let's return p","width":466},{"text":"now I'm going to change my method signature","width":243},{"text":"and I'd better have a return value that returns something if I get to the very end","width":338},{"text":"so for example, it returns where p is","width":324},{"text":"we can now update my original code so that it finds the first 'o' and gives you back a pointer to that","width":876},{"text":"if I print that out","width":93},{"text":"hopefully you can guess what my program should do","width":407},{"text":"okay so it gave us back a string and it this time the pointer was half way through \"hello world\"","width":453},{"text":"that's OK, our pointers don't care what they point to","width":278},{"text":"we know that strings will continue until we reach the null byte at the end","width":384},{"text":"so that's how we were able to print out hello world","width":257},{"text":"okay that's enough for me, time for you to play. bye!","width":83}],
  // Video 11
  [{"text":"Hello! Let's talk about automatic variables","width":204},{"text":"so here's my main method I've got two function calls f1 f2","width":328},{"text":"and today I'm going to actually define them before my main method","width":266},{"text":"so I don't need to put in the additional declares in","width":211},{"text":"so let's have f1 here and f2...ok","width":353},{"text":"so now I've got a syntactically correct program","width":257},{"text":"but I want to talk about the variables that we might put inside these","width":182},{"text":"so if I create a variable like this to say \"hey I've got a value here, something I need to compute inside f1\" or maybe I want to make an array","width":718},{"text":"so here's my array and I can initialize it to, say, \"f1f1\" here we go","width":529},{"text":"then the lifetime of my array (this variable) is only for the lifetime of the function","width":456},{"text":"when I return from f1, then the variable goes out of scope","width":307},{"text":"which means the name \"array\" doesn't mean anything anymore inside our program","width":271},{"text":"but secondly, the memory that we were using for the array is automatically free'd up","width":298},{"text":"it can be reused for other purposes in a moment by the rest of the program","width":197},{"text":"so isn't that fantastic","width":131},{"text":"that's why it's called an automatic variable","width":160},{"text":"so automatic variables are very easy to use","width":140},{"text":"they also come with a big warning sticker and that's this","width":273},{"text":"which is to be very wary of just how long they live for","width":440},{"text":"let's do a couple of things here","width":126},{"text":"first of all, let's make it so that we can actually see the pointer in memory where array is pointing to","width":671},{"text":"so, let's print that out inside our function here","width":341},{"text":"remember that the name of the array (when converted to address) gives us the very beginning of the array","width":400},{"text":"and, we'll do that for our second function too","width":172},{"text":"okay, so, f2 f2","width":220},{"text":"just to prove that they're making different arrays","width":215},{"text":"okay, so we'll compile and run this","width":190},{"text":"and, when we run it, we see that both f1 and f2 both these functions the array is actually stored inside the same memory location","width":864},{"text":"isn't that fantastic. we didn't need any additional memory","width":155},{"text":"and that's because after we return from f1, any of those automatic variables are free'd so they are no longer needed so we can reuse that space","width":598},{"text":"internally, later we'll discover that a stack data structure is used to implement this","width":497},{"text":"and I can show a little bit of this by having a either a recursive function or we can make another function call these","width":611},{"text":"so for example, I could have a function called eg","width":421},{"text":"and, this calls f1","width":146},{"text":"so now let's have a look in the case that I'm not using f2 anymore","width":363},{"text":"so that can go away","width":180},{"text":"instead, I've got a function called eg and that can say have its own space","width":365},{"text":"so, blah and maybe say a thousand and twenty four bytes here","width":571},{"text":"and then we call f1 again","width":142},{"text":"so let's run this now","width":474},{"text":"so, in the output, you'll see that f1 is printed twice and the second time it's because it's being called from our function eg","width":784},{"text":"and in this case, it's further down in the stack. it's in lower memory","width":348},{"text":"f948 as opposed to fd50","width":154},{"text":"because it's being called from eg","width":335},{"text":"so, we'll see more about the stack in a moment","width":162},{"text":"later on. I just wanted to show you that they really are stored in different places","width":326},{"text":"finally, to reinforce this idea, let's make a little recursive function","width":348},{"text":"so, I can have something which takes an integer say I'll call it \"level\"","width":488},{"text":"and if level is greater than zero, let's call ourselves again with a slightly reduced value","width":667},{"text":"and I can of course make that simpler by just saying \"if level\"","width":272},{"text":"so if level is nonzero, then call it again","width":125},{"text":"and let's call it with say five","width":178},{"text":"okay, a semicolon would help","width":303},{"text":"each case as we go deeper and deeper into recursion, our array is getting lower and lower and lower in memory","width":587},{"text":"so we have all of these arrays created. all of these different activation records in different places","width":370},{"text":"inside our processes's memory","width":181},{"text":"so the last point we'll make, which is the most important, which is that it's very dangerous to return pointers to memory that is no longer valid","width":472},{"text":"for example, rather than returning nothing returning void, suppose we try to return a pointer to our array","width":659},{"text":"then though this code might compile, okay, I can get rid of \"level\" now","width":557},{"text":"it's certainly not a valid program because the pointer we get back from f1 now points to stale memory","width":631},{"text":"that memory is no longer ours to control","width":167},{"text":"it will be used in a moment for other function calls","width":182},{"text":"so always be careful if you are returning a pointer to something. make sure that that memory is still valid","width":413},{"text":"and never return a pointer to an automatic variable","width":208},{"text":"that's it for me. time for you to play. bye!","width":187}],
  // Video 12
   [{"text":"welcome so let's talk about some options other than automatic variables","width":350},{"text":"so here's a little problem i've got so far","width":121},{"text":"in my main method i want to print out the current time ","width":273},{"text":"and i'm going to write my function called currenttime that returns a new string array","width":460},{"text":"i already know that i cannot make an array in here to hold the result","width":385},{"text":"say with two hundred and fifty because when I go to return from this function","width":333},{"text":"the array variable won't be pointing to memory that is valid any longer","width":424},{"text":"so here is two options","width":102},{"text":"i could make my array static","width":130},{"text":"so how do i do that","width":127},{"text":"just by the keyword static","width":106},{"text":"so for example if i were to just say okay i've got myself a static array out here outside of that method","width":445},{"text":"then my array lives forever or at least for the length of my process","width":377},{"text":"so that gets rid of the problem of having some space","width":260},{"text":"i cheated i said look just give me some space for the lifetime of my program here ","width":319},{"text":"so that's what static does","width":167},{"text":"i can also put this inside the function","width":174},{"text":"that doesn't change the lifetime of the variable","width":125},{"text":"it just changes the scoping","width":126},{"text":"so as always that means simply that now the variable name array can only be connected to that piece of memory inside my little method","width":756},{"text":"so it's just changing how the actual name of the variable is bound to the memory","width":380},{"text":"so that's one method","width":134},{"text":"but instead i want to talk about a completely different way which is to use malloc","width":379},{"text":"so you're going to come across malloc calloc and realloc","width":703},{"text":"today let's talk about malloc ","width":124},{"text":"which essentially means give me some bytes","width":192},{"text":"and i can say how many bytes i need","width":204},{"text":"and that storage space is found inside the program's heap","width":271},{"text":"so for example if I want one hundred and twenty eight bytes I would say malloc one hundred and twenty eight","width":275},{"text":"so this is going to give me a pointer to the very first byte","width":245},{"text":"so let's store that inside my little character pointer here","width":294},{"text":"and i'll say there is my result","width":285},{"text":"it is possible that malloc fails","width":268},{"text":"if it is unable to give me one hundred and twenty eight bytes it would give me back an invalid pointer pointed to null or pointed to nothing","width":381},{"text":"so i could say look if result is zero or null or if i wanted to be really terse I could say if not result","width":684},{"text":"in other words result is null","width":115},{"text":"then just return that null pointer","width":176},{"text":"i am not going to try and use it","width":130},{"text":"it's not a valid pointer","width":135},{"text":"otherwise let's put some things inside this and I could turn the current time and store it inside that array","width":620},{"text":"so let me use a function called strcpy to put in the current time which is two fifty one pm","width":572},{"text":"#include <string.h>Â let's run this","width":887},{"text":"and my program calls currenttime creates some memory and then returns it","width":375},{"text":"this is fantastic right","width":63},{"text":"i've now got a way to make long lived pieces of memory and put data inside them","width":365},{"text":"but with great opportunity comes great responsibility here ","width":207},{"text":"so what we should do is let our programs is with every malloc we should at some point free up that memory to say hey i've finished with it","width":640},{"text":"so the correct way to do this is to keep a pointer around","width":191},{"text":"so let's have a pointer down here","width":280},{"text":"and when i finished using that memory","width":169},{"text":"i can free it","width":122},{"text":"to say hey this memory is no longer being used","width":128},{"text":"this block of memory of one hundred and twenty eight bytes is no longer being used","width":289},{"text":"please put it back into the heap and maybe we will reuse that memory again for a future malloc","width":566},{"text":"so good programs will have one free for every malloc ","width":353},{"text":"in the next video i'll talk about some of the mistakes that we can make with heap allocation","width":334},{"text":"but now it's time for you to play with malloc ","width":162},{"text":"bye","width":52}],
  // Video 13
  [{"text":"hi welcome","width":116},{"text":"so we have got a little function so far called currenttime()","width":136},{"text":"that requests 128 bytes from the heap","width":307},{"text":"and then providing we get a non-null pointer back from malloc","width":263},{"text":"we will copy in the time 2:51 PM into that memory","width":288},{"text":"and then return a pointer to the first byte of that memory so that's our little currenttime","width":262},{"text":"we've been careful to make sure that if malloc fails, perhaps our program has used all of the heap memory","width":411},{"text":"then we don't try to use that null pointer","width":207},{"text":"but now let's actually make it so that it actually makes a call to find out what the current time is","width":540},{"text":"the current time is known by the system","width":114},{"text":"so it's time to make a system call and then we will format that using a c function called ctime()","width":529},{"text":"to actually give us a human readable version of the time","width":328},{"text":"both of these functions can be found inside the include time.h","width":306},{"text":"I've commented them up here","width":113},{"text":"so the first think we can do is call time so when you call time you can pass it a pointer to a time_t variable","width":717},{"text":"or you can say actuall I'm not going to give you anything and it will still give you back the time in its result","width":512},{"text":"so let's just use the result","width":145},{"text":"so here's the number of seconds since 1970","width":534},{"text":"we'll store that inside our little variable called secondsSince1970","width":359},{"text":"but I don't want that as a value, I just want to turn that into a string","width":224},{"text":"for that there's a function called ctime, this a library function. there are other functions that give greater control to the precise formatting","width":630},{"text":"but for this demo let's just use ctime() which has some reasonable formatting that most people can understand","width":617},{"text":"this will give us back a pointer to the time","width":319},{"text":"so the time in ASCII, in otherwords in letters, in readable time","width":484},{"text":"and then we can use that and copy that result into new memory, into our result","width":526},{"text":"so one problem with ctime() is that it uses static storage","width":339},{"text":"in other words it's great if you just want to call it once, and it will use it's static storage to give you back the time in a readable format","width":674},{"text":"but don't expect that to stay around because if you call ctime() again in the future it is going to overwrite those bytes","width":455},{"text":"and that's why our little function here called currenttime() is useful","width":200},{"text":"we are going to take that temporary result and put it into some memory that is ours to control","width":403},{"text":"so it can't be overwritten","width":174},{"text":"we need to pass in seconds since midnight","width":223},{"text":"except we've got a problem here","width":208},{"text":"it doesn't actually want the value, it wants a pointer to this variable, it wants to know where in memory this variable is","width":554},{"text":"for that I have to introduce some new syntax, which is the &","width":270},{"text":"when you see & it means that I don't want to know about the variable itself, but where it is stored in memory","width":523},{"text":"tell me the address of the variable","width":305},{"text":"we didn't need this for arrays because that's what the array name gives us automatically","width":224},{"text":"but for other items we can use the & to find out where it is stored in memory","width":500},{"text":"let's compile and run it","width":374},{"text":"and we find out that my little virtual machine thinks it's Jan 1 2014","width":389},{"text":"not very accurate, we should probably change it, but it did print out what it thinks the current time","width":487},{"text":"I promised you that I'd mention a few more mistakes that we can make with heap memory","width":479},{"text":"one mistake we can make is to double free the same pointer","width":423},{"text":"this can lead to all sorts of horrendous problems because when you tell the heap that you've freed with some memory it might actually use that memory for it's own book keeping","width":719},{"text":"so it knows that the particular block of memory is free","width":275},{"text":"if you free it again it can confuse the book keeping, the pointers that the heap is using itself","width":684},{"text":"once we've freed some memory, dont free it by accident a second time!","width":208},{"text":"another common mistake in C programs is to continue using memory after we've freed it","width":536},{"text":"we shouldn't consider that memory to be valid anymore","width":175},{"text":"perhaps it's going to be reused by some other part of the program that is about to call malloc()","width":458},{"text":"and certainly we shouldn't expect anything that we've previously stored in there to be valid","width":469},{"text":"once we've freed it don't try to use the pointer again","width":188},{"text":"so for example, this would be an error","width":217},{"text":"so how can we guard against some of these errors?","width":199},{"text":"one common defensive programming technique is once we free a pointer set that pointer to be NULL","width":498},{"text":"to mean that I'm not pointing to anything anymore","width":212},{"text":"so this avoids the problem of what is called a dangling pointer error","width":429},{"text":"that now our pointer is no longer pointing to invalid memory","width":541},{"text":"that's it for me. time for you to play, bye!","width":231}],
  // Video 14
  [{"text":"Hi, welcome!","width":94},{"text":"let's talk about creating more complicated data types in C","width":294},{"text":"so far, we've talked about integer and character pointers","width":220},{"text":"what if we wanted to make something more complicated like a linked list?","width":196},{"text":"for that, we will use a struct","width":193},{"text":"so, let's say we've got a struct and we'll say my struct I'll call it say Link","width":561},{"text":"and what should we have inside this?","width":80},{"text":"well, we've have a value to store and we'll need a pointer to the next link","width":310},{"text":"we'll need to know where the next link is in memory","width":117},{"text":"so, we can say struct Link and it's a pointer to that","width":368},{"text":"so, don't forget the asterisk","width":80},{"text":"so that's our little struct here. a semicolon is required at the end","width":297},{"text":"but it's kind of painful to keep saying \"struct Link\" every time I want to refer to this type","width":412},{"text":"so I can have a link here called \"one\" for example","width":204},{"text":"so quite often, we can use, or you'll find that people use \"typedef\"","width":277},{"text":"to say \"here's an alias\" and I can use typedef with any kind of type","width":417},{"text":"I can even use it with integers","width":139},{"text":"for example, I can say typedef number","width":168},{"text":"now I can say \"number x\" instead of \"int x\"","width":368},{"text":"but today we're going to use typedef for our link","width":190},{"text":"so we'll say instead of having to write struct Link, I'll call this my link type","width":416},{"text":"so now I've got my link type, I can make a link","width":238},{"text":"here's one","width":63},{"text":"and if I declare variables like this, outside of my functions, then they live forever","width":614},{"text":"and, let me write my main method here","width":326},{"text":"so, my link called \"one\" and my value live forever","width":395},{"text":"and in fact, they're initialized","width":87},{"text":"so their bitwise pattern is just all zeros","width":212},{"text":"so in other words, my value will be zero and the link \"one\" will have a value of zero and its next pointer will have a value of zero as well","width":740},{"text":"if we wanted to change that, then we could say one.value equals fourty two","width":369},{"text":"and one.next equals well, where should we put it?","width":237},{"text":"well where should we send it next?","width":98},{"text":"we could say \"NULL\" if we wish to use NULL, actually we have to #include <stdlib.h>","width":570},{"text":"to have NULL defined","width":185},{"text":"and now our Link says \"I'm the last thing. there's no one after me\"","width":354},{"text":"if we wanted to be particularly crazy, we can make the next pointer point to the very same link","width":425},{"text":"we do that by saying \"one\" except we don't want \"one\" we want the address of \"one\"","width":350},{"text":"we need a pointer to \"one\"","width":70},{"text":"so how do I do that? I use ampersand to say \"give me the address\" of this","width":281},{"text":"so that gives me a pointer to a link","width":121},{"text":"well thats great if we only need one link","width":114},{"text":"but that's not much of a linked list","width":150},{"text":"let's actually work out then how we can actually make a whole load of links","width":292},{"text":"for that, we'll use some heap memory","width":148},{"text":"and I'm going to use malloc which is also declared inside stdlib.h","width":268},{"text":"so, I need some memory","width":160},{"text":"how many bytes do I need?","width":109},{"text":"for that, I can say: \"give me the sizeof my link structure\"","width":225},{"text":"in other words, give me the size of link_t","width":143},{"text":"be careful you don't put an asterisk here otherwise, you'll only be reserving enough bytes for a pointer","width":362},{"text":"in other words, 4 bytes or so","width":109},{"text":"that's not enough for what we need","width":104},{"text":"we need the size of our whole struct","width":247},{"text":"so that gives me back a pointer and I actually want to cast it so that it's type pointer to a link_t","width":528},{"text":"so I can now store that inside a variable","width":227},{"text":"and I can have it as my first pointer","width":261},{"text":"so, malloc does not initialize the actual memory. it just simply reserves it for us","width":371},{"text":"just allocates it for us.","width":89},{"text":"we better make sure that our Link is properly initialized","width":228},{"text":"so for my first Link, I want to set its value to something","width":353},{"text":"and I need to set its \"next\" pointer to something","width":225},{"text":"so for example, I can set it to NULL","width":107},{"text":"or if I, oops, let me change that to put a one","width":271},{"text":"or if I wanted to make it point to itself, I can say \"ptr1\"","width":355},{"text":"if I had two links, let's do that","width":347},{"text":"then I can again set up the values. be very careful when copying and pasting code that you've actually edited it correctly","width":543},{"text":"I can now make my first link ptr1 its next point to next ptr","width":407},{"text":"and the next link, its next pointer can go nowhere","width":440},{"text":"so, there's my simple linked list","width":205},{"text":"more complicated links might have a previous pointer as well","width":246},{"text":"so you can navigate both in the forwards and backwards direction throughout the linked list","width":506},{"text":"okay, so, let's now finally compile this and check that it works","width":403},{"text":"our program compiles correctly, but to be a well-behaved program, really we should free up the memory as well","width":720},{"text":"so don't forget for every malloc you do, we should responsible for freeing up that memory once and once only","width":566},{"text":"so free(ptr1) and free(ptr2)","width":324},{"text":"also, a more robust version of this program would check that malloc actually succeeded","width":377},{"text":"that we actually really got the bytes","width":143},{"text":"that would be something important to do if your program ran for a very long time","width":322},{"text":"or needed very large unknown amounts of memory","width":319},{"text":"so that's how we make linked lists in C","width":184},{"text":"now it's time for you to play. bye!","width":161}],
  // Video 15
  [{"text":"Okay so let's talk about how we can make it easier to create links and destroy them","width":335},{"text":"so i've changed my link class a little bit so now each link can have a key and a value","width":297},{"text":"in addition to the next pointer","width":129},{"text":"the pointer to the next link","width":106},{"text":"okay so let's make some methods to create links and destroy them","width":440},{"text":"we'll do the create one first","width":123},{"text":"so it's going to return a pointer to a link","width":227},{"text":"and i might call it say link_create and I'll expect a key and I'll expect a value","width":721},{"text":"so that'll give me two pointers","width":159},{"text":"if i wish to debug this I could have a printf in here saying hey creating link and I could have what the key and values are for example","width":737},{"text":"right so i need to get some memory","width":165},{"text":"let's get some memory from the heap because we want our link to last for a long time until we decide to destroy it","width":445},{"text":"so i'll say malloc give me some memory and how much well i better ask for how big is my memory structure link_t","width":545},{"text":"and i will cast that return type as a pointer to my link object","width":445},{"text":"why do i do that","width":63},{"text":"well i want to be able to reference the sub parts","width":170},{"text":"the components of my struct","width":119},{"text":"and i will call that say result and i need to initialize my pointer","width":481},{"text":"so now i've got that I can set the key to be a key and the value to be the value","width":499},{"text":"now when i do this i am copying the pointers i'm not creating new strings","width":444},{"text":"so in other words i've now got a pointer called key and it's looking at exactly the same string array as the parameter is","width":499},{"text":"i haven't made any new string arrays","width":203},{"text":"so let's remember that when i return this","width":214},{"text":"that those pointers better be valid for the lifetime of the link","width":288},{"text":"well that's fine if I knew for example that this will always be used with string constants or I am taking control of those values that I send in and I happen to know that their lifetime is longer than the link's lifetime","width":1068},{"text":"so if that's the case then my code is relatively simple like this","width":214},{"text":"and destroying the link is also relatively simple","width":225},{"text":"so let's write a link destroy method destroy","width":205},{"text":"which takes a pointer to the link that is going to disappear so we can call that just p","width":437},{"text":"and what do i need to do in here","width":104},{"text":"well i can simply return the memory back","width":190},{"text":"okay so this works we could do a little better than this","width":253},{"text":"we could actually do some defensive programming here","width":150},{"text":"where we also destroy the information inside that link","width":381},{"text":"so for that i can use memory set","width":190},{"text":"so memset where I give it a pointer that I want to use","width":325},{"text":"the value will be zero the number of bytes can be the size of my link","width":279},{"text":"so this assures that i don't have any dangling pointers","width":258},{"text":"i have destroyed the key and value pointers","width":232},{"text":"i've set them back to null and anything else inside my link has been set to null","width":247},{"text":"so if someone happens to have a pointer to this link and they try to use the contents straight away then it will fail it will be null","width":521},{"text":"and secondly we are freeing it to say okay this memory can now be reused for other purposes","width":356},{"text":"so that's my link destroy method","width":158},{"text":"now suppose we discover that our strings we don't control the lifetime of these string arrays","width":483},{"text":"and that actually we should make copies of them","width":186},{"text":"so how can i do that","width":89},{"text":"well there's a method called strdup so let's do that strdup and this gives me back a pointer to a new string ","width":697},{"text":"a new character array that has been created on the heap","width":223},{"text":"and it's just a copy of that existing character array that we passed it","width":296},{"text":"so let's create our new string arrays and use those","width":296},{"text":"if we do that then when I destroy the link I better free up the memory associated with my key and value","width":470},{"text":"so before ending here I should free up those pointers","width":344},{"text":"so I should call free on my key and free on my value pointer as well","width":641},{"text":"okay so there's my code now to start working with a link","width":780},{"text":"with my main method I will need to always know the beginning of my linked list","width":448},{"text":"so that sounds like a great thing to actually have as a global variable here","width":312},{"text":"so let me have my link pointer here and I can call it root","width":327},{"text":"and so the first link I make I can initialize root to that","width":316},{"text":"to that very first link","width":157},{"text":"okay so that's it for now, it's now time for you to play with creating more links","width":389},{"text":"bye","width":70}],
  // Video 16
   [{"text":"hello welcome","width":63},{"text":"let's talk about how we can get single characters and print them out in c","width":267},{"text":"so here's some functions defined in std.io","width":232},{"text":"i can say give me a single character for example and why don't I just keep calling this","width":400},{"text":"so i could just say while getchar is not equal to a special constant called end of file (EOF) keep going around in a loop","width":590},{"text":"but if I actually want to print them out I better actually store the value of getchar","width":232},{"text":"so let's have an integer value called c and inside my while condition I'm actually going to assign the result into c","width":544},{"text":"so you'll often see this pattern inside systems programming where we take a systems call or a library call and we store the results inside a variable","width":643},{"text":"but because that may also signify an error condition or a termination condition we use it immediately to check inside part of a while loop or an if statement","width":641},{"text":"so we've got a little character loop here that is going to keep going until it gets to the end of the file","width":254},{"text":"so now I want to print it out","width":92},{"text":"guess what i can call putchar and we'll see that running ","width":217},{"text":"so let's run this little program","width":264},{"text":"ABCD","width":90},{"text":"it prints back ABCD","width":147},{"text":"okay so we don't have to display the character just as a character","width":273},{"text":"we can display it as a character an integer and hexdecimal values","width":255},{"text":"so let's use printf for that","width":94},{"text":"so I've got %c %d and %x for character integer and hexadecimal value","width":376},{"text":"alright so let's run this","width":324},{"text":"and you can see that the letter A corresponds to sixty five which is in hexadecimal forty one","width":385},{"text":"right so why don't we use our little program to print out the contents of another file","width":433},{"text":"so if I cat my source code I can see the contents of that","width":292},{"text":"great so I'm going to pipe it into my program","width":273},{"text":"so i'll do ./program and it reads every byte and prints it out as a character","width":526},{"text":"great so let's encrypt our file now so I'm going to modify our value of c if it's not a newline character","width":533},{"text":"so what we'll do is say if c is at least thirty two in other words at least a space an ascii space","width":470},{"text":"and if it is we will change the lowest bit","width":382},{"text":"we'll flip the lowest bit","width":61},{"text":"how can we do that","width":64},{"text":"let's xor it with one","width":169},{"text":"right and then we'll print it out","width":147},{"text":"okay so we'll run this","width":172},{"text":"CDE for example and it changed the C to a B","width":281},{"text":"and if I do 135 I get 024","width":254},{"text":"so to say that I've got to the end of the file when I'm just typing you by the way you can do control d","width":374},{"text":"now see this working on some actual source code","width":226},{"text":"so let's here some text my program.c and i'm going to pipe that into my program to use as its input","width":524},{"text":"and you can see great we've garbled the program","width":264},{"text":"so if I want to I can then take that output and pipe it into my program again","width":444},{"text":"so now i'm going to unencrypt it because i flipped the lowest bit back  ","width":259},{"text":"so we get back our source code","width":133},{"text":"so that's getchar and putchar i can also work with whole lines","width":372},{"text":"i can let's get rid of the loop here i can say puts hello or any pointer to a character array provided its terminated by a zero byte at the end","width":997},{"text":"and that is equivalent to printf by saying %s and \\n at the end","width":560},{"text":"so i've got some character pointer here","width":279},{"text":"right so it's a little bit shorter to type than writing printf","width":480},{"text":"there is the opposite which is to get some input","width":225},{"text":"but this has a problem and we'll see why in a moment why this function actually call is being removed from the c standard","width":392},{"text":"i'm talking about gets so let's call gets and we will have a little buffer here","width":648},{"text":"so let's put a little buffer on the stack here","width":187},{"text":"i'll make it twelve bytes today ","width":109},{"text":"and remember when we call gets with buffer if you use the array name you are talking about the very first byte of the array","width":432},{"text":"and rather than printing out hello","width":175},{"text":"we will print out our buffer value","width":137},{"text":"so let's run this and we can type something in and it echos it back to us","width":509},{"text":"fantastic but what happens if we enter more than twelve bytes","width":262},{"text":"so in other words could something bad happen to our other variables","width":247},{"text":"well yes it could because if we go past twelve bytes we start writing into memory which is used for other purposes","width":353},{"text":"for example in my little program the integer is immediately after the buffer","width":378},{"text":"let's prove this let's set our hex value of c to be ten twenty thirty fourty","width":422},{"text":"let me print that out after we've called gets i'm going to print it again","width":584},{"text":"so we've got to remember that what we store is going to be our letters plus a null byte","width":475},{"text":"so in this case if I do ABCDABCDABCD I've already overflowed because the thirteenth byte is now going to be written into my integer","width":796},{"text":"but i am going to do just a few more I'll do ABCD there we go","width":295},{"text":"and we'll see that I've managed to change my integer value to 41424344","width":412},{"text":"so the last ABC that I wrote in there actually overran my buffer","width":277},{"text":"i've got a buffer overflow and I've corrupted the contents of another variable","width":300},{"text":"so that's why gets is dangerous","width":107},{"text":"there's no way to tell gets that we shouldn't accept input that is too long for it","width":420},{"text":"so in a future video i'll tell you about getline and also fgets which don't suffer from these problems","width":586},{"text":"okay that's it for me thanks for watching and i'll see you in another video. bye!","width":269}],
  // Video 17
  [{"text":"Hello! Let's talk about how we can use scanf and sscanf and fscanf to read some data and convert that into say integers or floats or strings","width":739},{"text":"so we can actually use those values inside our variables","width":232},{"text":"alright, so, I'll start by using sscanf","width":207},{"text":"which can parse data inside a string","width":184},{"text":"inside memory","width":109},{"text":"so for example, let's have a little bit of data here","width":136},{"text":"I'll have my data be my name and a score","width":454},{"text":"and I want to take that and pull it apart into a string and an integer","width":385},{"text":"so I'll have a little buffer here, say, up to twenty characters","width":343},{"text":"and a little integer here","width":102},{"text":"and I could set this to be equal to some arbitrary value. we'll see why in a little bit","width":434},{"text":"and then I'm going to say \"okay, sscanf please read from this string array and what I'd like you to do is convert that into a string followed by one or more spaces and then an integer value\"","width":1146},{"text":"alright so scanf is going to look at our memory starting at wherever our data is pointing at","width":359},{"text":"and, it's going to first of all look for a string until it comes across one space","width":357},{"text":"and then there can be actually multiple spaces in our data","width":155},{"text":"and then after that, it's going to treat the rest of the string as an integer","width":287},{"text":"okay, now, our format specifiers say the kind of data that we want to interpret and also the number of bytes that should be written to when it is trying to parse its data","width":730},{"text":"so we better tell it where to exactly put these things","width":154},{"text":"so for our string, we want it to write it into a buffer","width":234},{"text":"and for the score, we want to write it into our score variable","width":199},{"text":"but hold on a moment","width":114},{"text":"when we say \"buffer\" yes that gives us the beginning address of our array","width":372},{"text":"but not for score","width":63},{"text":"score is just going to give us whatever value score happens to hold","width":170},{"text":"in this case, negative forty two","width":124},{"text":"that's not what we need","width":69},{"text":"we actually want the address of this variable","width":132},{"text":"so we're going to say ampersand score","width":239},{"text":"so, lets read that and we'll print it out","width":271},{"text":"so here's the result and we'll say %s %d and we'll print the contents of the buffer and print the value of score","width":592},{"text":"so notice that scanf and printf, the arguments don't always look the same","width":266},{"text":"when we want to print out the values, we don't actually want to just print out the address of score","width":389},{"text":"we actually wanted to know what the value is","width":106},{"text":"great so that read that correctly","width":202},{"text":"scanf actually tells us something else which is how many arguments it correctly managed to parse","width":428},{"text":"so let's make a note of that and we'll print that out","width":299},{"text":"so, we'll say %d here","width":313},{"text":"print out the result in our printf statement here","width":183},{"text":"so now when we run it, we'll see that sscanf managed to read both iterms","width":384},{"text":"I got result two","width":90},{"text":"fantastic. so that's useful. now we can write robust programs to check if we really did write into both variables","width":521},{"text":"now you might be worried that scanf could result in a buffer overflow","width":286},{"text":"and, in fact, in our current code, you'd be right","width":168},{"text":"so if I had a very long name with no spaces here","width":419},{"text":"then that's longer than our buffer","width":229},{"text":"so what we need to do is tell scanf just how big our buffer is","width":209},{"text":"so in this case, it should be nineteen","width":207},{"text":"because we're setting scanf how many character to read from the input","width":321},{"text":"and our buffer, of course, if going to need one extra one to hold the terminating byte for this string","width":397},{"text":"so let's run this now","width":483},{"text":"and you'll see that first of all the name is truncated and that secondly, the return value of our scanf call here was one","width":538},{"text":"and it only managed to read into the buffer","width":259},{"text":"it gave up trying to read the integer because our buffer wasn't long enough","width":190},{"text":"and, in fact, our score variable still contained its original value","width":305},{"text":"of negative forty two","width":123},{"text":"so good defensive programs must check that the return value is reasonable","width":389},{"text":"also, when writing scanf or sscanf or fscanf, it's always a good idea to carefully check to see whether you should be looking at the address of the variable or if the variable itself actually is a pointer","width":783},{"text":"and is already going to give you the memory address that you'd like scanf to change","width":532},{"text":"alright so we've read data from a string ","width":263},{"text":"we can also parse data from a file stream and how can we do that? well you can use not sscanf but fscanf","width":663},{"text":"and if you did that, you better give it a file stream","width":182},{"text":"there's one called stdin already","width":209},{"text":"if we didn't want to use that, then we could open up a file using fopen and then pass in the file handle here","width":564},{"text":"and reading from stdin is such a common occurance that in fact there's another form of this which is just say scanf","width":699},{"text":"and if you do that, that means \"hey, just read from stdin\"","width":188},{"text":"so now, let's run our program here","width":555},{"text":"and, now it's waiting for input","width":99},{"text":"so let me typing something","width":130},{"text":"I'll say \"Angrave one hundred\"","width":324},{"text":"great! and it managed to parse both variables","width":177},{"text":"okay so that's enough introduction to scanf","width":188},{"text":"remember this next time you're trying to read 3d data and points and you want to say convert those ASCII numbers into actual floats and doubles","width":640},{"text":"and also remember that its important to read exactly how scanf uses these format specifiers because its not quite the same as printf","width":624},{"text":"alright, that's it for me. time for you to play. bye for now","width":278}],
  // Video 18
  [{"text":"hello welcome","width":111},{"text":"let's talk about getline","width":93},{"text":"so it's very very common to read in a single line of text either from the user or from a file","width":438},{"text":"and we would like it to be very easy to say hey \"let's not worry about making sure my buffer is large enough\"","width":384},{"text":"I just want to get the whole line","width":95},{"text":"and thus getline was born","width":130},{"text":"this is being adopted into the posix standard","width":215},{"text":"if you are working however with older standard and an older compiler we have to ask gcc to explicitly enable it","width":463},{"text":"so before doing our includes with stdio we need to define _GNU_SOURCE","width":575},{"text":"so if we do that we would like the gnu source additions to the standard functions","width":473},{"text":"right so if we do that now we have got a getline declaration included as part of the #include <stdio.h>","width":478},{"text":"so here is how we can use getline","width":228},{"text":"with getline we actually set up two variables","width":284},{"text":"we get getline to manipulate these directly ","width":287},{"text":"we are going to have a pointer to a buffer","width":319},{"text":"and a little int to say how big is our buffer","width":369},{"text":"well let's just check to see really if it is an int or if we should be doing a different type","width":226},{"text":"so let me pull up my favorite manpage on getline","width":362},{"text":"see that actually the correct type to use is size_t","width":398},{"text":"which is essentially an unsigned int or larger on some systems","width":259},{"text":"so let's just make a note of that","width":99},{"text":"that is the declaration that we are going to be using","width":210},{"text":"and so we will have not just a buffer to our character array","width":377},{"text":"but also size as well to say how big is our buffer","width":328},{"text":"and i will call this say capacity","width":168},{"text":"right so we could start calling this and we could say okay","width":256},{"text":"get me a line and oh i need to pass in a pointer to my buffer variable","width":441},{"text":"right and notice that the declaration here is star star asteric so it's a pointer to a pointer","width":513},{"text":"right so how did i get that","width":97},{"text":"i say okay give me the address of my variable","width":223},{"text":"and similarly for the capacity as well","width":150},{"text":"the size of the variable","width":126},{"text":"so give me the address of my capacity","width":317},{"text":"and getline is going to modify those two variables directly","width":222},{"text":"essentially if my buffer is not large enough","width":189},{"text":"it is going to free up the old buffer and then call malloc so that we get a larger buffer","width":518},{"text":"okay technically it might call realloc but let's not worry about exactly which library call it calls","width":335},{"text":"we just know that it's going to do all that buffer maintenance for us automatically","width":266},{"text":"and now we need to give it a filestream so why don't we use say stdin","width":413},{"text":"now right now our code suffers from a terrible flaw which is that we've assumed that our automatic variables buffer capacity will be set to nothing","width":546},{"text":"so the getline knows that it can't reuse what it happens to be pointing to","width":264},{"text":"so we actually need to set these to explicitly to null and the capacity to zero","width":403},{"text":"so the first time we call getline getline will see that the buffer is certainly not large enough and will allocate enough space","width":502},{"text":"we can now find out what the result is which is the number of characters getline has managed to retrieve","width":519},{"text":"or a negative value if it failed","width":127},{"text":"so let's make a note of that","width":146},{"text":"and we'll print this out","width":125},{"text":"so i'll print it out as an integer and let's have a look to see what we can find inside our buffer","width":445},{"text":"so we want the result and we want the buffer","width":227},{"text":"and lastly let's put a newline here","width":169},{"text":"okay so we'll run our little program here","width":385},{"text":"and now it's waiting for me to type something","width":368},{"text":"okay great so it says i have got six characters","width":218},{"text":"wait and i printed ABCDE","width":102},{"text":"actually the last character might be a newline character","width":355},{"text":"and quite often we don't actually need that","width":152},{"text":"so why don't we overwrite the very last character with null with a terminating byte","width":439},{"text":"so let's write the code for that","width":160},{"text":"first of all we only want to do that if we get at least one character back from getline","width":289},{"text":"so let's check that the result was positive","width":300},{"text":"and also we only want to do this if we are going to overwrite the last character which truly is a newline","width":385},{"text":"we could imagine for example reading from a file where the very last byte is not actually a newline","width":363},{"text":"so we should just check to see what we're going to write here","width":233},{"text":"so let's look inside our buffer and where do we want to look?","width":275},{"text":"well if we read one character that would be at the beginning of the buffer","width":403},{"text":"so we need to look at result minus one","width":129},{"text":"so if that is equal to the character of a newline","width":352},{"text":"then let's truncate the string","width":262},{"text":"the easiest way to do that remember is strings are just terminated by zero","width":190},{"text":"so let's just put a zero directly into that byte","width":188},{"text":"so we are going to say at the same spot set that equal to zero","width":356},{"text":"right so let's run our program again","width":534},{"text":"okay so this time it read it correctly and in our printf we didn't get that unwanted extra newline","width":570},{"text":"alright our program right now is allocating memory on the heap","width":270},{"text":"we don't do it we let getline do it","width":127},{"text":"but it's actually up to us when we finish using getline to free that buffer","width":362},{"text":"right so let's do that","width":121},{"text":"let's at the very end here we can call free on the buffer","width":316},{"text":"we don't need to do that every time we call getline because getline by default will try to for performance try to reuse the buffer for each line it gets","width":576},{"text":"so for example we could call getline twice and it would try to use the same buffer","width":511},{"text":"but the big take home message for getline is first of all","width":186},{"text":"you are going to need a pointer to a buffer and a capacity variacle which getline itself is going to change the contents of","width":470},{"text":"as you call it it can make the buffer as large as","width":304},{"text":"each time you call getline it might change that buffer to point to some new memory if the buffer needs to be larger","width":439},{"text":"secondly it's a great idea to check the return value of getline to see how many characters it managed to read","width":469},{"text":"and also to see if there was an error or not","width":138},{"text":"and the return type for that is ssize_t for a signed size integer type","width":469},{"text":"and finally it's good practice to don't forget to free the memory that is pointed at by your buffer variable","width":546},{"text":"okay that's it for me","width":87},{"text":"have fun playing bye","width":78}],
  // Video 19
  [{"text":"Hello welcome","width":135},{"text":"so this video is a little introduction to signals","width":222},{"text":"so signals are like a software interrupt","width":198},{"text":"we can use them to control our processes and even do things asynchronously","width":322},{"text":"so let's have a look at a little program i have written so far that doesn't use signals yet","width":333},{"text":"all it does is ask for the environment of home","width":181},{"text":"in other words the user's home directory","width":172},{"text":"and then we have a little loop that prints it out and sleeps for three seconds","width":314},{"text":"so every three seconds it is going to print out my home directory","width":211},{"text":"and on this machine i am root so it just keeps on printing out slash root","width":387},{"text":"so of course we can stop this program by pressing control c","width":383},{"text":"and when you do that you actually are sending a signal","width":195},{"text":"sigint or sig interrupt to the process","width":261},{"text":"now it maybe that our process doesn't like being interrupted","width":198},{"text":"why don't we catch that signal and install our own little handle for that","width":319},{"text":"so here is how we will do this","width":158},{"text":"i am going to say at the beginning of my program that if you get a certain signal say sigint ","width":797},{"text":"rather than having the default behavior which as we know is to stop the program or quit the program","width":367},{"text":"let us run my code instead","width":113},{"text":"so i will call it say nothankyou","width":227},{"text":"so what is nothankyou","width":113},{"text":"it has to be a pointer to a function","width":252},{"text":"how do we do that","width":61},{"text":"easy just write a function","width":75},{"text":"and in this case the correct type is something that doesn't return anything","width":310},{"text":"but does take an integer","width":136},{"text":"in fact it is the signal that is being sent to our program","width":253},{"text":"and so that we know that this is being called let's write something out directly to standard output","width":342},{"text":"so i can say write and i can say no","width":219},{"text":"so what is that that is a little message of three bytes to send","width":228},{"text":"so let's run this now","width":155},{"text":"okay so here is my program every three seconds it is going to print root","width":248},{"text":"but now i am going to press control c","width":359},{"text":"and it prints no no so it's refusing to quit","width":405},{"text":"you might also notice that the sleep also immediately returns","width":242},{"text":"more about that later","width":99},{"text":"it is still possible to stop our program here","width":180},{"text":"if we do control backslash then we force it to quit","width":382},{"text":"so sigint is one common signal that we send our programs","width":259},{"text":"there are many others","width":92},{"text":"just for fun let me show you one called sigalarm","width":239},{"text":"so this time i am going to say alarm seven seconds","width":498},{"text":"and so when you call alarm you are going to say give me a special signal called sigalrm in this many seconds","width":626},{"text":"in seven seconds","width":82},{"text":"and we better install then","width":112},{"text":"well let's just run it and see what happens to begin with","width":795},{"text":"so the default behavior of this sigalrm is to actually stop our program","width":299},{"text":"it quits the program","width":103},{"text":"that's a pretty aggressive alarm clock i think you'll agree","width":175},{"text":"and it also as you see prints out alarm clock on the shell","width":233},{"text":"perhaps we don't want our alarm signal to be so menacing","width":308},{"text":"so this time instead of sigint i can say look for a certain signal called sigalrm","width":452},{"text":"please call my function instead","width":515},{"text":"okay so there we go our alarm went off after four seconds and this time we asynchronously ran our code that printed out no to standard out","width":704},{"text":"so this is pretty exciting right","width":98},{"text":"you probably thought about interrupts on the hardware level","width":228},{"text":"now we can do interrupts at the software level and we can respond to things which happen in our environment very quickly","width":459},{"text":"so we will find signals to be very useful when we start dealing working with more than one process","width":381},{"text":"we can control our programs and we can also work with very large amounts of data coming in","width":371},{"text":"alright that is enough for me","width":106},{"text":"bye","width":36}],
  // Video 20
  [{"text":"so usually we think about our programs as just turning into one single process","width":299},{"text":"now i am going to show you some systems programming magic","width":187},{"text":"where actually we can turn our single process into two","width":217},{"text":"here is how we are going to do it","width":105},{"text":"let us have a very simple program that says hello world","width":216},{"text":"and here it is","width":138},{"text":"so between these two lines however","width":198},{"text":"i am going to call fork","width":426},{"text":"and here's a surprise","width":91},{"text":"we get hello world world","width":90},{"text":"yes we get two worlds","width":129},{"text":"why is that","width":65},{"text":"well at the beginning there was a single process","width":117},{"text":"but then we called fork and now our single process is actually being cloned","width":340},{"text":"it has been split into two","width":111},{"text":"so both the processes print out world","width":164},{"text":"and so we see both their output on our little terminal here","width":297},{"text":"okay what else can we do with this","width":97},{"text":"well let us first of all show that there really are two different processes","width":192},{"text":"i am going to look at their processor id","width":351},{"text":"and we will print it out","width":168},{"text":"so i will call getpid()","width":102},{"text":"and you will see that yeah i have got two different processes","width":258},{"text":"both trying to run at the same time","width":191},{"text":"in fact i have got a parent child relationship here","width":289},{"text":"i have got the original process","width":128},{"text":"the parent","width":63},{"text":"and you can think of fork as saying let us clone this original process right here right now","width":375},{"text":"so that i get a child that looks just like me","width":153},{"text":"or at least almost like me","width":111},{"text":"in many many respects","width":63},{"text":"it is the same memory","width":152},{"text":"it has got it's own variables","width":63},{"text":"but because its got its own address space","width":251},{"text":"what the child now does in terms of its memory is seperate from the parents","width":369},{"text":"okay so let's show you what we can then do with this","width":330},{"text":"first of all fork actually returns something here","width":154},{"text":"it actually returns back an id","width":192},{"text":"so let's make a note of that","width":188},{"text":"and we'll print it out","width":124},{"text":"so we'll say %d and we'll print out just here","width":552},{"text":"okay so here is what we see","width":166},{"text":"that the process id 681 has fork value of 682","width":562},{"text":"and process 682 has a fork return value of 0","width":386},{"text":"so the fork value is different for the parent and the child","width":290},{"text":"and in fact fork","width":173},{"text":"if it returns a positive number is talking to the parent","width":238},{"text":"and is telling the parent here is the id number for your child","width":333},{"text":"so let us make a note of that","width":162},{"text":"let us call this","width":75},{"text":"here is my child","width":63},{"text":"so i can call my child","width":149},{"text":"and then i can write an if statement to decide if i am the parent or the newly created child or not","width":466},{"text":"so we will say look if the child id what i return from fork is actually greater than 0","width":470},{"text":"then i am the parent","width":194},{"text":"so let's put something like hey i'm the grouchy parent","width":575},{"text":"if it is zero however then hey I'm the carefree child!","width":905},{"text":"so we will let's remove this ","width":254},{"text":"i'll get rid of that line now","width":83},{"text":"okay so now we have a little program where the parent and child are going to do two different things","width":381},{"text":"and in fact it is standard for the parent to wait for the child to finish","width":438},{"text":"we don't have to but quite often we need the child process to do something for us","width":436},{"text":"perhaps in the background","width":112},{"text":"but we don't actually want to continue until the child has finished","width":234},{"text":"so let us do that","width":88},{"text":"what i am going to wait for my child to finish","width":262},{"text":"so i am going to say waitpid and i need to say okay what is the id i need to wait on well here is the childid","width":566},{"text":"and later on i can ask for some status information about my child","width":345},{"text":"and for now the last argument i am just going to put as 0","width":189},{"text":"so i need to have a variable called status just a little integer","width":299},{"text":"and in fact we are going to pass not just the value of status but the address of our little variable","width":400},{"text":"and later on we can use that to find out say did our child exit normally or was it terminated in a surprising way","width":492},{"text":"so let us run this now and what we will expect to see is that we'll wait for the child to finish before we print","width":519},{"text":"I'm the grouchy parent","width":63},{"text":"so let's run this","width":393},{"text":"okay so this time the child process got to print out I'm the carefree child","width":442},{"text":"then it exited","width":119},{"text":"meanwhile the parent was waiting for the async condition and when that happened","width":342},{"text":"the parent is able to continue and is able to print I'm the grouchy parent","width":416},{"text":"so i want to finish on a common programming error that can really bring down a server","width":564},{"text":"and that is suppose we made many many many processes","width":406},{"text":"so it is one thing to create a few","width":142},{"text":"let's call say fork a couple of times and perhaps you can guess how many worlds we'll see here","width":971},{"text":"that's right we see four worlds","width":146},{"text":"and in fact the parent finished early so this is the hash of the terminal saying what would you like to do now","width":540},{"text":"but we had four processes all printing out world","width":212},{"text":"and if we had three forks now we have eight","width":311},{"text":"okay so let us make something now called a fork bomb which is where we keep creating lots and lots of processes","width":550},{"text":"and this often happens by accident by people who are new to systems programming","width":326},{"text":"but just for fun because i am just doing this inside a browser it doesn't matter if i bring my little virtual machine to a halt","width":582},{"text":"i can always just reload the page","width":114},{"text":"so let's print out my id","width":630},{"text":"i will put this in a little loop that says while one let's fork","width":327},{"text":"let's print out my process id","width":347},{"text":"and then i will sleep two seconds","width":460},{"text":"so initially i have two processes","width":111},{"text":"and then each of those processes calls fork","width":209},{"text":"so we got four","width":51},{"text":"and then each of those processes call fork","width":171},{"text":"prints it out and sleeps","width":93},{"text":"and so every two seconds i am doubling the number of processes that are in my system","width":291},{"text":"so that's a lot of processes","width":124},{"text":"and in fact pretty soon the kernel will run out of space","width":324},{"text":"it won't be able to keep track of any more processes","width":138},{"text":"and fork will stop working","width":220},{"text":"and now we see here's the kernel printing out all sorts of debug messages","width":248},{"text":"desperately trying to make the system stable again","width":190},{"text":"as it arbitrarily starts to kill processes in an attempt to recover some memory and space in its process tables","width":539},{"text":"so amazingly my little kernel here has managed to recover to the point to where i have a working system","width":500},{"text":"but that is fork bombs and you should avoid from accidentally doing this","width":346},{"text":"otherwise you will have a system administrator telling you that you cannot log onto that machine anymore","width":286},{"text":"okay have fun and i'll see you in the next video","width":194},{"text":"bye","width":39}],
  // Video 21
  [{"text":"okay, good morning class, how are you","width":367},{"text":"I'm good thank you","width":103},{"text":"alright, for those of you that weren't paying attention, cs241 has started. good morning class, how are you?!","width":373},{"text":"alright, great. so, in the next 15 minutes the game of course is for you to leave this room with more passion for system programming and maybe some more knowledge about how to do it as well","width":668},{"text":"and maybe some knowledge about how not to do it as well","width":210},{"text":"so one of the intents here is cover gotchas and common programming mistakes","width":280},{"text":"so, if you have a burning question, there's probably someone else in this room that has the same question","width":321},{"text":"I will endeavor to answer as many questions as possible without derailing the lecture","width":238},{"text":"so feel free to speak up","width":135},{"text":"if it's not appropriate, I will tell you","width":115},{"text":"and, just stay, come down and talk to me afterwards","width":147},{"text":"also, I hold office hours usually three times a week immediately after lecture","width":265},{"text":"because I figured thats the best way to reach most of the students","width":238},{"text":"so feel free to stop me","width":150},{"text":"I may not be able to stay for a full hour every time","width":157},{"text":"for example, there's a faculty meeting today where we're talking about how to take over the world","width":276},{"text":"uiuc style","width":83},{"text":"but most times I'm there to help you","width":286},{"text":"and I love to see people progress. its fantastic stuff when you start from the beginning of this course when you don't know anything","width":397},{"text":"till the end where you can actually do some pretty cool things","width":187},{"text":"and by the way, last semester many students came to me to say \"hey! you know what? I just had an interview and they asked me to explain X\" where X is a cs241 thing","width":657},{"text":"such as, what's the difference between a process and a thread?","width":223},{"text":"whats the difference between stack memory and heap memory?","width":136},{"text":"how would you do that?","width":55},{"text":"what's a common gotcha with this?","width":104},{"text":"why would a C program crash? that kinda stuff","width":265},{"text":"so you might find that the knowledge you gain in this class actually has an immediate impact for you outside of this class","width":413},{"text":"and if it does, wonderful!","width":160},{"text":"alright, so, let's get started with a couple of trick questions","width":333},{"text":"that we have here, wanna go to overhead, right!","width":292},{"text":"okay! how do you look up information for C library calls and system calls?","width":228},{"text":"easy! okay, here's the beautiful thing. with POSIX, POSIX includes many things","width":605},{"text":"it includes an API (application programming interface) in other ways, instead of calls, you can call","width":392},{"text":"and also, a manual of man pages about those calls","width":374},{"text":"so guess what? we're actually going to look up different calls","width":227},{"text":"the art of course is knowing which calls you should use","width":329},{"text":"and the POSIX man pages aren't going to tell you that","width":202},{"text":"you already have to have a basic idea of \"oh yeah! I need to use open\" or \"or yes! I need to use write or stat or lstat or fork()\"","width":629},{"text":"so that's the main thing you're going to get out of this course is the vocabulary","width":264},{"text":"with the then end expectation that you would actually then start to use this stuff and look it up","width":320},{"text":"so we've got two different kinds of things. we've got C library calls and system calls","width":463},{"text":"the C library is the part of your process","width":188},{"text":"okay, what's the difference between a program and a process?","width":153},{"text":"well, the program is the code that you've written turned into bytes which say you stored on disk","width":339},{"text":"and then when you actually execute it, or actually run it, it becomes a process","width":274},{"text":"and of course you can have multiple processes running for the same piece of program code","width":310},{"text":"but part of that process is the C library","width":146},{"text":"it comes kind of bundled with or loaded at runtime and it's a set of code and maybe some constants too that just runs as part of it","width":524},{"text":"so what kind of C library calls do we have? well for example, perhaps you want to do a string copy where you want to say \"okay, copy all the bytes into a destination from a source\"","width":787},{"text":"and we're gonna pass two pointers and it will keep copying those bytes starting from source into destination until what?","width":666},{"text":"until it reaches a zero byte","width":156},{"text":"because that's the definition of a C string","width":192},{"text":"of course, bad things might happen if you accidentally put these in the wrong order","width":312},{"text":"alright, if you tried to copy from some arbitrary place into a different place, who knows how many bytes its gonna copy before it gets to zero? oops.","width":512},{"text":"who knows where its going to immediately crash your program?","width":171},{"text":"for example, it might be that you try to write into some read only memory","width":306},{"text":"and the hardware say \"ah ah excuse me? excuse me? you see that process over there? it's being a baaad baaaaad process\"","width":483},{"text":"ok lady gaga I might","width":107},{"text":"so, look I enjoyed that joke personally","width":296},{"text":"so, let's um, this is an example of a C library call. it doesn't need to go into the system to run this","width":635},{"text":"we can do this entirely inside the process space","width":218},{"text":"inside the virtual memory of our proces","width":226},{"text":"ok, what about system calls? well, here's an example of one, you've already seen it: \"write()\"","width":412},{"text":"we want to get outside of our system. we want to break out of our system and get the system to break outside of our process and do something","width":444},{"text":"to the rest of the world","width":123},{"text":"okay, so, the system itself needs to handle that particular call","width":361},{"text":"and in fact it does that using a hardware interrupt","width":262},{"text":"that's the red pill, if you follow the matrix movie","width":218},{"text":"that's how you escape out of the box. out of the sandbox that your poor little process is stuck inside","width":508},{"text":"anyway, so we want to look up say some information about these and so for that we can use \"man\"","width":420},{"text":"which reads man pages","width":154},{"text":"which are incredibly terse and utterly useless if you dont have some basic knowledge","width":322},{"text":"but pretty useful if you already know something about what you intend to do","width":369},{"text":"so let's try one","width":276},{"text":"box pc","width":392},{"text":"okay so let's try looking up for example \"printf()\"","width":317},{"text":"there it is","width":44},{"text":"and it's in section 3 of the man page","width":96},{"text":"okay yeah, we want to open it. there it is","width":125},{"text":"now what do we see about these man pages? well the things I want to show you is that first of all it tells you what includes you better have","width":448},{"text":"it also includes a whole load of function calls which do similar things","width":300},{"text":"so, as well as printf, we've got sprintf or snprintf","width":367},{"text":"and, then we've got some really terse information on what it's gonna do","width":286},{"text":"and usually its got a return value as well","width":299},{"text":"so they might return say the number of characters printed","width":316},{"text":"excluding the NULL byte used to end output strings","width":192},{"text":"notice how those display little parenthesis here as if its not that important","width":325},{"text":"as if the number of bytes written is not that important to you","width":189},{"text":"as if that could never cause a big program to fail","width":239},{"text":"accidentally, you might assume that that is the actual number of bytes written","width":218},{"text":"no no no, it excludes it and it's an off by one error","width":172},{"text":"it's actually going to ignore the fact that it may have written a zero at the end because it's the end of a C string","width":394},{"text":"oops! that's exciting.","width":107},{"text":"you may have not had enough memory. you may have overwritten something else","width":306},{"text":"so, when you read man pages, read them slowly and try to understand everything they say","width":443},{"text":"and of course, it's always useful to find an example","width":266},{"text":"oh, this one actually has one, look at that! amazing","width":194},{"text":"most of them don't bother with an example","width":101},{"text":"so you end up doing any google search to say \"okay, easy example of blah blah blah blah\"","width":475},{"text":"but yeah so they're a good reference material","width":221},{"text":"now you'll notice we had different sections","width":139}],
  // Video 22
  [{"text":"Let's do another one","width":182.18181824684143},{"text":"Let's look for fork - create a child process. Yes, that's right, you create children by forking","width":922.1818182468414},{"text":"I knew you'd remember something from this lecture. We'll play more with this later because it's an amazing thing you can do with posix. You're first process can actually clone itself, at that very moment to become two separate processes","width":1220.1818182468414},{"text":"It's like you pull a switch and suddenly you've got a doppelganger","width":347.18181824684143},{"text":"If you're a physicist and you think about the many worlds theorem, it's a bit like that. The world from a process point of view splits into two. Suddenly you've got two processes for the price of one","width":681.1818182468414},{"text":"OK, so we'll see that. But again, notice we had different sections","width":265.18181824684143},{"text":"The sections you're going to see are.... can you see this? let's see if we can make it bigger","width":721.1818182468414},{"text":"section two, alright. This is where all the system calls live","width":368.18181824684143},{"text":"section three, this is where you'll find the C library stuff","width":274.18181824684143},{"text":"and section seven, you'll occasionally find there's actually longer articles. I hesitate to call them tutorials, they're not that useful","width":668.1818182468414},{"text":"but more long winded articles that have some better practices. it's worth reading at some point during this course","width":472.18181824684143},{"text":"you might find some useful information there. for example, when we talk about signals, but most of the time you'll be using these as reference","width":496.18181824684143},{"text":"unfortunately, let's go back to here and look up stat. some words appear in multiple places and if I make a new window here","width":970.1818182468414},{"text":"and I do man stat, then I get the wrong one. I get the one that would happen from the shell. So i have to say 'no, no, no I really wanted section two'","width":942.1818182468414},{"text":"so sometimes you have to force it to find the right section","width":410.18181824684143},{"text":"that's enough about man pages. you will be using them. when it comes to quizzes, i'll talk more about that later, but i will have expected you to know something basic about the return values, some of the common gotchas of using different calls","width":1074.1818182468414},{"text":"do you remember how to allocate memory on the heap?","width":398.18181824684143},{"text":"if your neighbor said 'malloc' congratulations, you made a good seating choice","width":356.18181824684143},{"text":"yes, malloc is one way to say 'hey, I need some memory and it's mine until I what?'","width":855.1818182468414},{"text":"free it, yes! ","width":216.18181824684143},{"text":"when you call malloc you are going to point to some bytes. will those bytes be zero?","width":787.1818182468414},{"text":"do you feel lucky punk? the answer is maybe, but it's not guaranteed. ","width":411.18181824684143},{"text":"if you get a brand new, fresh page of memory from the OS it's likely to have been zeroed out by the OS to make sure you don't accidently get any information from another process","width":831.1818182468414},{"text":"remember, we're trying to keep our processes separate, so you can't accidentally read someone else's password, or secret key, or something else that's secretly happening inside another process","width":550.1818182468414},{"text":"the OS makes sure to usually give you some zeroed memory","width":315.18181824684143},{"text":"however, if it's reuse of your own memory, it's quite likely there's just garbage in there","width":493.18181824684143},{"text":"it could be that because it's zero it lulls you into a false sense of security, you assume memory is zero","width":606.1818182468414},{"text":"why did C do this? sounds like a terrible thing to put the onus on programmers to make sure their programs always work. why didn't they always zero out the memory?","width":941.1818182468414},{"text":"time consuming, yes! C is all about trying to be as efficient as possible and if you can't cope with that, get a different major","width":725.1818182468414},{"text":"That is C's attitude, maybe we can find tools to spot memory errors, but it's very much a case of we're trying to write a language which is just a little bit above assembler. it's meant to be that it's almost as efficient as assembly code, just a lot easier to read and write","width":1409.1818182468414},{"text":"malloc has to be very efficient because we use it a lot. think about your java programs, OK I'm sorry. I know that was a bad experience, but think about all the times you've made new objects, etc.","width":832.1818182468414},{"text":"underneath that we're saying 'OK, I need some more memory'","width":275.18181824684143},{"text":"so malloc's job is to find some bytes. you say 'oh quick, I need another thirty two bytes and I need it right now. I can't continue my process untiil you give me thirty two bytes fo rme to play with. And, yes, I promise to free it later when I'm finished with it.'","width":960.1818182468414},{"text":"some processes are allocating a lot of memory all the time. so malloc tries to be efficient and when you free some memory, we can put it back into this pool of bytes that we can use later again. That's why it's called a heap, it's just going to be a big disorganized mess of allocated space and unallocated space","width":1346.1818182468414},{"text":"And, in fact, it's tricky to write malloc and free, so we are going to ask you to do it in 241","width":491.18181824684143},{"text":"we've got malloc and free. later on you'll also see halloc and realloc, but let's not talk about those now","width":580.1818182468414},{"text":"you can just implement those on top of malloc","width":389.18181824684143},{"text":"suppose we wanted to write our own string copy function. here it is!","width":561.1818182468414},{"text":"because these are character pointers, I should mention, how big is a character in C? ","width":638.1818182468414},{"text":"the size of a single [byte]","width":221.18181824684143},{"text":"if I do sizeof character,the answer is one. everywhere, at all times, before I even compile the code. it's a definition that the size of a character type is one","width":1079.1818182468414},{"text":"sizeof gives you the number of bytes","width":416.18181824684143},{"text":"so a character is always one byte. If i put a variable name in there I'd get one","width":618.1818182468414},{"text":"when I add one to these pointers, it is going to be incrementing along one byte at a time. I read one byte and I add one to the source pointer and add one to the destination pointer","width":901.1818182468414},{"text":"this code is slightly broken. perhaps you and your neighbor can figure out how it should be fixed. i'll point out the following","width":742.1818182468414},{"text":"what does this do? while star source","width":363.18181824684143},{"text":"thank you, yes! remember star means dereference, follow the money, take this expression and use it as a memory pointer and actually tell me what's in there","width":649.1818182468414},{"text":"because we're talking about a character pointer, we are asking memory to read just one byte. if we had an int pointer we might be reading four or eight bytes","width":553.1818182468414},{"text":"but, no, we're reading one byte. while this is non-zero, do something. with C, anything which is a non-zero value is true","width":686.1818182468414},{"text":"what a wonderful simple world","width":189.18181824684143}],
  // Video 23
  [{"text":"my love for you is 42","width":192},{"text":"so this means this is going to continue until we get that null byte","width":448},{"text":"alright that's enough hints","width":64},{"text":"let's fixed that code","width":128},{"text":"right so see if you and your neighbor can fix this code faster than your other neighbor that yu're not talking to","width":384},{"text":"it's not copying the string, that's one of the bytes","width":576},{"text":"copy the bytes so actually we didn't just want to copy src into dest ","width":3968},{"text":"all this would do is whatever the value of src is whatever the value of src is i is just some memory location, we set that into dest","width":384},{"text":"but dest is just a local variable so that would actually do nothing, it would actually just change src into dest","width":448},{"text":"what we want to do is just use src as a pointer","width":192},{"text":"so we need to put a star in here","width":192},{"text":"there we go","width":64},{"text":"right so we should have read the value at src hey go back to memory and then use dest as a pointer","width":384},{"text":"we wanted to dereference it ","width":128},{"text":"we wanted to say okay now write that value into whatever dest is pointing to","width":256},{"text":"so we've done that, we've copied one byte and we increment both pointers","width":256},{"text":"and then we go back around the loop so we're going to keep writing bytes until we get to the null byte","width":320},{"text":"is my function finished?","width":128},{"text":"no, what's wrong with it?","width":128},{"text":"yes thank you, yes we forgot to copy the null byte","width":448},{"text":"so this function is broken it forgot to copy the null byte","width":320},{"text":"but it might work if you test it if you happen to test it with memory that is already zero","width":320},{"text":"and you think aha I finished my mp","width":192},{"text":"right, no your code is broken","width":192},{"text":"because is forgot to terminate the C string","width":192},{"text":"and then some future function would start reading this and it wouldn't come across a null byte because there would be garbage after it","width":384},{"text":"and it would start printing random characters","width":192},{"text":"until it eventually got to a null byte","width":320},{"text":"of course if it didn't get to a null byte maybe other bad things would happen","width":256},{"text":"anyways so let's fix this","width":64},{"text":"we needed one more line to say after the while loop ","width":256},{"text":"the src should be a null byte which I could write like this","width":448},{"text":"okay here's another example of a classic C error which is when you've got two pointers you're probably using the wrong one","width":832},{"text":"okay so make sure that we change the very last byte at the end to be a zero byte","width":512},{"text":"so we terminate it","width":128},{"text":"we could have also fixed this by using a do while loop instead of a while loop","width":320},{"text":"so we would have only done the check at the very end","width":384},{"text":"we would have copied at least one byte","width":128},{"text":"alright so that was my string copy","width":192},{"text":"how about something that actually duplicates strings","width":128},{"text":"right so we want something that takes a character to some memory and we are going to make a new memory object","width":832},{"text":"and we're going to copy the contents of the original into our new piece of memory","width":320},{"text":"right so how do I get some new memory? easy I remember what I said ten minutes ago and say malloc","width":576},{"text":"so I've got malloc I've got the right size I copy.. whoops wait a moment I've got two pointers am I using them in the wrong direction?","width":832},{"text":"if in doubt, yes I probably am right?","width":128},{"text":"how do we check? easy go back to the manpage alright","width":256},{"text":"man let's try strcpy and BSD kindly calls them s1 and s2","width":960},{"text":"okay copies a string from s2 into s1","width":256},{"text":"yes we managed to do it the wrong way round","width":128},{"text":"what we should have done is swap these around","width":448},{"text":"by the way is this text large enough to see at the back?","width":320},{"text":"can you give me a thumbs up if it is?","width":128},{"text":"alright so most of you","width":192},{"text":"alright I'm assuming the people who didn't are going to sit close to forward in the future","width":320},{"text":"but seriously let me know if it's not","width":128},{"text":"okay right is our code finished? okay we run it and it doesn't work, it might crash","width":640},{"text":"here's one problem, what's the size of src? what will this give us?","width":448},{"text":"one, we've managed to allocate enough space for one byte","width":384},{"text":"and then we try to write into that one byte","width":256},{"text":"okay that's fine if our string is very short, just one byte long","width":320},{"text":"not so fine if our src strings were longer","width":256},{"text":"so we shouldn't have done this right?","width":192},{"text":"what we wanted to know was the number of characters at the src","width":320},{"text":"so how can we do that?","width":128},{"text":"call strlen of src","width":256},{"text":"so now we test it and it almost works but it still crashes","width":576},{"text":"here's the issue, strlen tells us about the number of characters excluding the null byte at the end","width":384},{"text":"look C is trying to help you give off by one errors","width":192},{"text":"what a polite language, if it's not my fault it's your fault","width":320},{"text":"alright look we only need to add one to that","width":256},{"text":"let's just even huh? who came up with this","width":128},{"text":"alright so when you write a language don't do this","width":448},{"text":"make your strlen actually say how many characters, how many bytes it actually took","width":384},{"text":"okay so we've got now we're calling malloc and we copy from the src ","width":576},{"text":"so this should be p, this should be from the src into our memory and finally we return p","width":384},{"text":"is it okay to turn p because look p is an automatic variable","width":192},{"text":"it's a local variable","width":64},{"text":"is that a problem? no because we are not returning a pointer to p itself","width":320},{"text":"we are running the contents of p","width":64},{"text":"and p is just looking at this memory that we've malloc'd and that memory that we've malloc'd will exist until we free it ","width":576},{"text":"now malloc itself returns a void pointer and if we wished we could cast that changes type into a character pointer","width":640},{"text":"in practice you don't need to","width":64},{"text":"that if you have a void pointer it's okay, it's allowed to cast it implicitly to a different type","width":704}],
  // Video 24
  [{"text":"alright so, is our code any good?","width":185},{"text":"yes, question?","width":629},{"text":"okay, so, this was discussed on piazza. it makes the code a bit more cluttered. if you do too many casts, you're forcing your way, you're saying: \"hey compiler, trust me I know what I'm doing\"","width":1076},{"text":"which is fine until the day you don't know what you're doing","width":166},{"text":"and you've just casted something which is incorrect","width":159},{"text":"maybe you're casting a pointer to a pointer to a pointer.","width":271},{"text":"and you would've potentially gotten a compiler error but by explicitly casting, you won't get any error","width":551},{"text":"so that's probably the biggest issue","width":76},{"text":"yes","width":411},{"text":"oh, I'm so, yes, you're right. I forgot that it's a character pointer. it would not have returned 1. it would've returned say 4 or 8 or however big your pointers were on your platform","width":958},{"text":"so, if its a 32 bit platform","width":323},{"text":"then how many typical bytes do you need?","width":406},{"text":"well, 4 bytes to hold 32 bits","width":134},{"text":"if its a 64 bit machine, then you'd need 8 bytes","width":594},{"text":"right, so, our code looks pretty good except one little issue. if you read the manpage of malloc, you can discover that malloc() can fail. and when it fails, it returns","width":686},{"text":"quick! read the man page!","width":77},{"text":"right, when it fails to give you any memory, it returns NULL","width":322},{"text":"so, we should check for that","width":100},{"text":"because right now our code would attempt to write into that 0 location","width":358},{"text":"if malloc fails","width":48},{"text":"so what we should do is, here is, we should, if p or not p which is another way of saying \"hey, is p zero\"","width":1196},{"text":"I didn't give any memory so no new string duplication for you","width":285},{"text":"and hopefully the code that calls my code actually bothers to check to see whether it got a valid pointer or not","width":517},{"text":"alright, okay, any other questions?","width":288},{"text":"alright, what's a double free?","width":438},{"text":"okay, so, let's say we free pointer, and then for some reason later, we free the same pointer","width":703},{"text":"in other words, we called free twice on the same memory block","width":241},{"text":"is that a bad thing?","width":148},{"text":"yes, that's a bad thing","width":144},{"text":"okay, here's why","width":118},{"text":"when you call free, the memory allocator says \"oh, look!\" he or she is finished with that memory so I can put it back into my free pile","width":717},{"text":"and I might allocate it again when someone asks for more memory but I'm going to update my linked list structures and whatever internal structures I have to keep a count of what memory is free","width":871},{"text":"so if you call free again, bad things may happen to those linked list structures","width":403},{"text":"bad things may happen to other code that's already actually using that memory space","width":467},{"text":"alright because between you freeing it and freeing it again later, it could be that another malloc has come in and been given that memory","width":589},{"text":"so when you double free, really exciting things can happen","width":217},{"text":"you have no idea what's gonna happen next. you have broken the universe at this point","width":369},{"text":"because, artibrary things can happen to your heap memory and who knows what the rest of your program is doing to your heap","width":538},{"text":"so, how can you avoid it? well, there's a couple of ways. first of all, don't write this code","width":368},{"text":"secondly, it's a good practice in production code to set your pointer to zero","width":393},{"text":"in other words, don't have, what are these pointers called now?","width":497},{"text":"the dangling pointer!","width":67},{"text":"it's a pointer to some memory address that is no longer yours to play with","width":308},{"text":"because say you free'd it","width":128},{"text":"and you don't want another piece of your code to accidentally use that pointer","width":461},{"text":"so, when you free memory or decided to use memory for some other purpose, it's good practice to set pointers to that memory to zero","width":901},{"text":"this of course looks very easy and trivial to avoid. in practice, these two frees could be somewhere arbitrary in your program. maybe someone kind of tries to free your data structure twice","width":833},{"text":"and then you end up calling free on some memory twice","width":453},{"text":"right, okay, let's have an example of a buffer overflow","width":466},{"text":"well a buffer in C can be anything. for example, it could be just a simple array","width":298},{"text":"so, let's make an array myData","width":722},{"text":"and this says, \"okay, I need space for 8 bytes or 8 characters\" and","width":1022},{"text":"let's set one of those entries to p. is that allowed in C?","width":681},{"text":"okay, so that's a trick question. yes, the compiler will compile that for you, it might give you a warning, it might get an error if you've racked up enough options","width":772},{"text":"but remember, what are we doing here is we're just simply saying \"okay, take whatever data's pointing to, add 8, times whatever the size of each entry is, and then use that to change some memory\"","width":737},{"text":"we actually want a bit representation in our p","width":360},{"text":"but, when we did this, we only asked for enough space for 8 entries. and we're trying to write a 9th entry. oops!","width":723},{"text":"we could also have run into the same problem if we had string copy","width":555},{"text":"one two three four five six seven eight","width":386},{"text":"ahh, I did it the wrong way around","width":409},{"text":"okay, so there's two things wrong with this code. first of all, the arguments is the wrong way around","width":534},{"text":"second of all, how many bytes is this going to write?","width":272},{"text":"into memory?","width":98},{"text":"nine!","width":51},{"text":"I've got the digits 12345678, and the NULL byte at the end to say \"hey! my string is finished\"","width":457},{"text":"but we only made space for 8","width":230},{"text":"so that ninth byte. what's that ninth byte being used for? maybe it's being used for another variable in which case we've just overwritten the value of another variable","width":636},{"text":"and that is how many C programs are vulnerable to buffer overflow","width":407},{"text":"that is how you could hack into say, a web application which didn't put enough space on a buffer","width":735},{"text":"and you could then overwrite nearby variables","width":290}],
  // Video 25
  [{"text":"let's do our last little thing here. what is typedef?","width":553.1818182468414},{"text":"it's just an alias","width":213.18181824684143},{"text":"we've got some basic types in C, but you can use the keyword typedef to say 'hey I need something else'","width":624.1818182468414},{"text":"I might have an unsigned int","width":428.18181824684143},{"text":"OK, that's a lot to type. I'm just going to call that my u int or I'm going to use an unsigned int to represent process identifiers for example. So don't be scared when you see typedef, it's just being able to alias a particular type so that you can have a short name for it","width":1430.1818182468414},{"text":"questions? yes!","width":426.18181824684143},{"text":"because writing struct x is painful and people don't want to have to write the keyword struct everytime","width":1247.1818182468414},{"text":"let's say I have a struct called poem","width":989.1818182468414},{"text":"now I'd have to say 'right suppose i wanted some memory'","width":202.18181824684143},{"text":"I want a pointer to a poem, so struct of poem pointer malloc sizeof struct poem","width":769.1818182468414},{"text":"it's kind of annoying to keep writing struct everywhere, yes? so instead you'd say typedef and that can be my poem struct","width":1168.1818182468414},{"text":"And then you might go further and say I want a poem pointer, so poem_s star poemptr","width":824.1818182468414},{"text":"then you might write this code and then you might write this code and that would be wrong","width":722.1818182468414},{"text":"whoops, look, i just tried to get the size of my pointer. that's going to be four bytes or eight bytes","width":322.18181824684143},{"text":"I didn't want that, I wanted the sizeof my original structure. be careful when you start playing with typedefs","width":931.1818182468414},{"text":"you'll see typedefs commonly used with structs and for things like unsigned ints","width":1041.1818182468414},{"text":"let's not compile this code for now","width":674.1818182468414},{"text":"instead let's print some things out here. how can I print strings out and single characters? well you've seen printf, fantastic. guess what? there's also","width":773.1818182468414},{"text":"putchar sixty five and that's going to print","width":565.1818182468414},{"text":"a single 'a'","width":203.18181824684143},{"text":"so if you wanted to print out a single character, there are these C calls like putchar","width":606.1818182468414},{"text":"if you want to print out a line, there's put s","width":417.18181824684143},{"text":"Hello World","width":315.18181824684143},{"text":"'It prints a new line too'","width":407.18181824684143},{"text":"so that's useful if you know that all you need to do is print out a C string. it will print out a c string followed by a new line","width":658.1818182468414},{"text":"all of these calls underneath end up calling, what? ","width":423.18181824684143},{"text":"yes, they call write","width":253.18181824684143},{"text":"<gibberish> some point your C library says I've had enough holding these bytes, I want to get rid of them, I want to flush them, I want to send them out and when it wants to do that it calls write to the OS","width":766.1818182468414},{"text":"it turns out actually you don't need to print everything to stdout. your processes by default have two output streams. one called standard out, one called standard error. let's prove that","width":1202.1818182468414},{"text":"let's use fprintf. I'm going to say something like 'this is using printf' and we'll try to run that and it doesn't work","width":829.1818182468414},{"text":"we get an error because we haven't given enough arguments to fprintf and in fact the. let's look it up","width":1177.1818182468414},{"text":"fprintf, yeah we need the file stream first. we can say standard error","width":829.1818182468414},{"text":"here's the thinking, here's why standard out and standard error exist and they're not quite the same","width":293.18181824684143},{"text":"quite often when we want to use these tools we want to process the output of one tool and send it immediately into the input of another tool","width":505.18181824684143},{"text":"but what about errors? well we'd like to see them still in the terminal, we'd like to send them to a different file","width":375.18181824684143},{"text":"you're compiler for example, might send - ahh","width":339.18181824684143},{"text":"what have we done wrong here? standard error undeclared? ah","width":910.1818182468414},{"text":"OK, great, that really did print. This is using fprintf. We can send things to these two different output streams and you too can make your own output strings by using fopen","width":1144.1818182468414},{"text":"And also they have different bufferings","width":716.1818182468414},{"text":"What've we got here? I've shown you things like puts and putchar","width":730.1818182468414},{"text":"how do I print - use fprintf, for example, I can send it to standard eror, blah blah blah","width":672.1818182468414},{"text":"is standard error buffered like standard out? no! standard error immediately calls write, it doesn't try to do any buffering","width":986.1818182468414},{"text":"standard out is a little bit diferent. standard out tries to have better performance, so rather than writing every single byte, let's collect a few up and once we assembled enough bytes then we'll call write and make it appear","width":964.1818182468414},{"text":"standard out by default when you're just looking at things in terminal buffers until you see a new line","width":671.1818182468414},{"text":"so if we see a new line, let's flush that buffer!","width":340.18181824684143},{"text":"in other words, call write on the whole buffer and out it goes","width":255.18181824684143}],
  // Video 26
  [{"text":"let's prove this while one do nothing ","width":2304},{"text":"right so we got the very first line over here","width":256},{"text":"from printing to standard error but we did not get the standard out line","width":384},{"text":"so look at my code, I said \"hey this is using printf and this is using printf exclamation point\"","width":320},{"text":"the difference between the two is that one of them went to standard error","width":192},{"text":"and we saw that straight away","width":128},{"text":"standard out that text is still sitting inside my process","width":256},{"text":"inside the c library because we didn't include any new lines and now my process has got stuck inside this infinite loop","width":704},{"text":"so now when I control C the program never has a chance to flush that buffer","width":256},{"text":"it never has a chance to write it out","width":128},{"text":"if I did just exit normally, if I did just say return 0 here","width":384},{"text":"then as part of the exiting, the C library says oh look I've got some open file descriptors","width":960},{"text":"I will make sure that my buffers are flushed","width":192},{"text":"so it does that at the very end as the program is finishing","width":192},{"text":"right oh and one last thing here, if you actually want to print into a C string","width":448},{"text":"the best thing to use is sfprintf but I'm not going to talk about that today","width":512},{"text":"but that's assemble things into, yes quick question","width":64},{"text":"there is two different streams so it's up to the terminal at the end to combine it into one and display","width":576},{"text":"but we could make it so that the standard error goes to a completely different file or goes somewhere else","width":320},{"text":"let's have a look at page two","width":64},{"text":"yes okay when you free a null pointer, nothing happens, it's a safe operation by definition of the spec","width":768},{"text":"being thinking beings, you want to see errors as soon as possible","width":512},{"text":"you can actually change it there's a call called setvbuff if you want to change it but that's the idea","width":448},{"text":"right okay so which one should we do here","width":448},{"text":"let's do these three, these are the funnest ones","width":448},{"text":"the first three questions on this you can see on the wiki book","width":384},{"text":"I want to kind of go through these, first of all let's write our most exciting system program today","width":640},{"text":"I'm going to use this fork and for that we need to include unitstd.h so let's do that","width":512},{"text":"okay so let's print something out in our little program here, let's find out what our process id is","width":1216},{"text":"so I'll just do %d for now, that's good enough for this lecture","width":384},{"text":"let's call getpid to mean get my process identifier so we'll run this","width":512},{"text":"and nex time I run it I'll have a new line as well so when I run it this time my program was process identifier 61","width":768},{"text":"and in fact if you do ps on a command line you can see all these different process little numbers","width":384},{"text":"and we'll use that later because we'll control them","width":128},{"text":"this little virtual machine doesn't have much going on","width":192},{"text":"right but if I was to run it again, I'd probably get a different process number","width":512},{"text":"one hundred and seventy five, okay","width":64}],
  // Video 27
  [{"text":"so now let's do something exciting","width":461},{"text":"let's call fork()","width":614},{"text":"look, I get two different numbers, 188 and 189","width":258},{"text":"I've actually got two processes running","width":216},{"text":"here's what happened: the moment you called fork(), your little process gets temporarily stopped for a nanosecond","width":624},{"text":"so the CPU's not going to execute anything in your code","width":231},{"text":"and we duplicate it","width":135},{"text":"we now have two nearly identical processes running","width":373},{"text":"and then we'll let them go","width":157},{"text":"so remember when I said, you pull a switch and you get an immediate doppleganger","width":207},{"text":"there's immdiately two processes","width":119},{"text":"now one thing you've noticed already is that they have different process identifiers","width":455},{"text":"another way that they're different is that one of them is the parent of another","width":1154},{"text":"let's get that back to result, and let's say...fork gave me the following","width":1102},{"text":"My pid is that","width":135},{"text":"okay, let's run that","width":585},{"text":"so, look at that! I got two processes running at the same time. one of them says \"hey! fork() gave me nothing. it gave me zero. and fork() gave me 203!\"","width":825},{"text":"so these two processes are now running in slightly different worlds. one of them had a different return value. one of them had a non-zero return value","width":533},{"text":"and in fact, the return value is the child process!","width":296},{"text":"so as a parent, if you wish, you could create a child by forking and then immediately kill it","width":403},{"text":"but I'm not going to show you how to do that today","width":157},{"text":"instead, I'm going to show you what happens when we fork() too much","width":732},{"text":"while 1 is greater than 0","width":505},{"text":"let's print that, let's not return, and let's sleep for one second","width":536},{"text":"just so we can kind of follow what's going on. actually, let's sleep for two seconds","width":351},{"text":"Are you ready? let's see what happens now","width":358},{"text":"okay! I've got two processes. OH! how many have I got now? FOUR processes. now I've got eight processes. now I've got 16. Each process, remember, sleeps for a second and then forks. it makes a copies of itself.","width":875},{"text":"so I've got all these running processes because say, I had 4 of them, and all 4 of them called fork(). oh dear, my system has crashed","width":682},{"text":"alright, eventually, my poor machine of course runs out of memory and it's unable to continue. alright.","width":1117},{"text":"so, actually, at this point, the system does its best to preserve itself","width":345},{"text":"it does its best to say \"ahhh, I don't want all these children!\"","width":203},{"text":"I cannot cope","width":98},{"text":"and so it prints out all the debugging information and then decides at random to start killing user processes. the idea being that that's the least bad thing that we could do in this case because we want to preserve the actual main operating system (the kernel running)","width":1101},{"text":"and maybe we'll have a few processes left that are still useful","width":181},{"text":"so let's see if I've even got a- no, I don't got anything do I?","width":216},{"text":"no, it's dead","width":64},{"text":"but that is an example of a fork() bomb. as you can see, it's pretty mean to everybody else that happens to be logged in to the system at the time","width":789},{"text":"so, when you start using forks for the MP, good luck!","width":378},{"text":"and try not to write fork bombs","width":133},{"text":"and with that, we'll finish there and I'll see you on Wednesday!","width":181}],


  // Start Lecture Video 1
  // Video 28
  [{"text":"your laptop before we release the official instructions ecetera","width":664},{"text":"but that is it. that is coming up","width":175},{"text":"alright, so, next question, who here is ready for section this week?","width":464},{"text":"and actually got a little working editor?","width":217},{"text":"alright, who here is still working on it?","width":214},{"text":"okay, who here is procrastinating and has not started yet?","width":266},{"text":"alright, okay, so note that if you raised your hand on that last question, you are definitely the minority.","width":336},{"text":"remember, the purpose of this work is for you to be on top of using these calls, understanding how memory works, understanding how to put them together so make sure you're ready","width":886},{"text":"and it's gonna be great prep for when we do the harder MPs","width":359},{"text":"right then so today here's what we're going to do. we're gonna talk a little bit more about C programming. I'm going to show you some more gotchas","width":382},{"text":"i'm gonna talk about getline I'm gonna talk about assert(), I'm going to show you some fun little demos and as usual, feel free to interrupt me and ask a question or two","width":654},{"text":"and as usual, most of this material is also in the wikibook. which was created last semester. So most of the lecture content, you'll see inside the wiki book","width":590},{"text":"alright, also, these lectures are now recorded so feel free to review them as well","width":337},{"text":"right so, let's have a look at our little handout. overhead!!...","width":605},{"text":"doo doo doo doo doo","width":489},{"text":"right! so here's something you can put inside your C programs. if you write line underscore and undersore or file underscore and underscore, something magic happens","width":665},{"text":"they get expanded by the C preprocessor into a number, as if you actually typed it, and a string, as if you actually typed in the file name","width":768},{"text":"that's currently being compiled","width":164},{"text":"so the value of line actually changes and the preprocessor knows which actual file line it is currently compiling","width":575},{"text":"so that can be useful for putting in debug information, so we can discover for example which part of our program is executing by printing this stuff out","width":758},{"text":"so, let's have a look, box pc","width":324},{"text":"okie dokie, so for example, I could say \"hey!\" or, let's just print it out. I'll do printf \"bad stuff happened in file %s at line %d\"","width":1293},{"text":"we'll put in, let's see I need the file and the string so that's a underscore. oops. can't get it back inside. thank you. file and line number.","width":771},{"text":"alright, so we will put a new line there...let's say exit our program so nothing else happens. okay, let's run this","width":1121},{"text":"alright, so there we go, bad stuff happened in file program.c at line 14. that's pretty useful if we want to open our editor and go back to that particular point. so that happened at runtime.","width":829},{"text":"and in fact that idea is used by another macro called assert","width":404},{"text":"so you can imagine we want to be able to say things like \"look, if my pointer is non-zero\" so I could say \"not equal to null\" or I could say \"not equal to zero\" or I could just say \"if not p\"  in other words, if its not a valid value","width":1270},{"text":"print an error message and quit","width":241},{"text":"right? that's a pretty useful thing to do during debugging. just do a quick test. before I start using p, I may be crashing in really strange ways so I just want to check if the following expression is true","width":647},{"text":"so that is actually what the assert macro does. so, I can say things like \"look, I want to assert that 2 is greater than 1\"","width":856},{"text":"let's check that. let's assert that 3 is less than 7 times 0","width":573},{"text":"right, let's run this","width":698},{"text":"we didn't get anything, did we?","width":750},{"text":"and, I'm wondering why","width":317},{"text":"let's see, we compiled asserts","width":415},{"text":"include assert.h and we don't seem to be. AH. we want to compile it in debug mode","width":537},{"text":"okay there we go, right","width":79},{"text":"so this time we, haha, yes! this time we remembered to include the assert.h and assert is actually a macro. it expands to include that underscore underscore line thing","width":837},{"text":"and underscore underscore file","width":86},{"text":"so now, here we go, when we run this, it prints out program.c at line 15 inside my function main assertion 3<7*0","width":578},{"text":"it's pretty useful. it actually shows you the expression","width":163},{"text":"it's a nice simple development thing to use asserts","width":329},{"text":"because then you can check that people that are calling your functions are actually giving you say valid arguments","width":317},{"text":"and you can check that your assumptions are correct before you try to write complicated code","width":344},{"text":"and, it kills your program. it aborts","width":203},{"text":"so that's assert","width":302},{"text":"now then, pretty easy to use, remember to include it, include...assert.h and then, and then inside your program you just say assert and write an expression you expect to be true","width":1181},{"text":"like \"Hey! its wednesday!\"","width":184},{"text":"if that expression is true, nothing happens","width":206},{"text":"and in fact, when you make a release build, this expression isn't even tested","width":464},{"text":"this compiles to no code","width":176},{"text":"so it's good for performance","width":230},{"text":"but then you realize that you've been living on the edge. it doesn't actually check it.","width":384},{"text":"and it's a macro, because we want to be able to print out the actual contents of the expression we're going to test.","width":405},{"text":"and also we want to print out the line number. and also it's a macro because we can make the contents of the macro disappear when we do a release build","width":718},{"text":"so, with that, let's see if you can write a version of string cat. and what you want to do for strcat is append the contents of another string onto the end of the first string.","width":1066},{"text":"but, we're not sure that people are giving us valid arguments","width":281},{"text":"so how would you write this so that it aborts if either one of these were NULL ?","width":385},{"text":"what would you write?","width":65},{"text":"so see if you and your neighbor can finish this","width":303}],
  // Video 29
  [{"text":"this function it should at the end simply return a pointer to the beginning of the target","width":495.18181824684143},{"text":"and i'll give you a hint, how do you actually determine where a string finishes?","width":464.18181824684143},{"text":"You walk along the string until you find a null character","width":285.18181824684143},{"text":"so the plan should be walk along with a little loop until you find a null character and then start copying the bytes from the source at that point to keep copying them across","width":561.1818182468414},{"text":"until you get across a null character in the source and then you know you're done copying","width":284.18181824684143},{"text":"and then before you finish make sure the very last thing you put at the end is a null character to terminate your string","width":515.1818182468414},{"text":"see if you can finish that code in about five minutes and I'll walk around answer any questions you have","width":519.1818182468414},{"text":"questions? ice cream? popcorn? yes?","width":16070.181818246841},{"text":"if you wanted to check that these are valid pointers, we want to check that they're non null","width":343.18181824684143},{"text":"so actually we could just say assert dest","width":548.1818182468414},{"text":"you could even say dest and source, however, that wouldn't give you very much debugging informationÂ all you'd discover is that one of them is broken","width":698.1818182468414},{"text":"so personally I wouldn't do that, I would write it as two different things on two different lines","width":300.18181824684143},{"text":"so that when it does it break I can discover at least whether the problem was with the source or the destination address","width":615.1818182468414},{"text":"OK, right, so if I get past that I know that both of those pointers are non null. my next challenge then is to walk to the end of the dest","width":868.1818182468414},{"text":"I could do that using a little loop. I could say things like while star dest ","width":730.1818182468414},{"text":"keep incrementing dest","width":247.18181824684143},{"text":"so that would work, in other words whilst - when I read the contents that dest is pointing to - whilst that's non null keep walking","width":600.1818182468414},{"text":"and it will keep doing that until I end up on a null byte. I also heard people doing things like, let's just add into dest strlen dest","width":1034.1818182468414},{"text":"in other words find out how many characters excluding the null byte, are pointed to at that destination and add that to dest","width":424.18181824684143},{"text":"so both of those would work","width":126.18181824684143},{"text":"now we want to copy. OK, how could we do this? well maybe I call string copy, but if I wanted to write this in a loop, let me write this little do while loop","width":1024.1818182468414},{"text":"going to dest and do I want to go into there, the contents at source","width":484.18181824684143},{"text":"I can't spell source, nevermind. whoops, and then increment both of those. dest plus plus, source plus plus. there we go","width":1024.1818182468414}],
  // Video 30
  [{"text":"alright and keep doing this while either one of these is valid","width":624},{"text":"okay what do you think about that code?","width":370},{"text":"hold on hold on you can't see it","width":200},{"text":"is this code correct?","width":128},{"text":"does it copy the null byte at the end?","width":1104},{"text":"okay alright if your neighbor thinks it copies the null byte get a new neighbor","width":524},{"text":"right why does it not copy the null byte?","width":543},{"text":"because we've incremented the source pointer","width":215},{"text":"right so we copy a byte, we keep copying characters and then we increment the source pointer and then we say while source","width":446},{"text":"so we are checking the next byte, the byte that we haven't yet copied","width":496},{"text":"so no, that code doesn't actually coy the very last byte","width":263},{"text":"you see, C program is easy","width":226},{"text":"or actually C programming with bugs is easy, writing correct programs is harder","width":369},{"text":"and we wouldn't have spotted this if our destination memory had all been zeroed by some fortuitous accident","width":448},{"text":"so that is incomplete, we still need to copy the byte at the end","width":373},{"text":"so at the very end I need to put a null byte in","width":374},{"text":"so I could write that as zero, I could write that as backslash zero","width":421},{"text":"that means the null byte","width":115},{"text":"and then finally return dest","width":471},{"text":"okay what do you think about that code","width":273},{"text":"yes, so if source is just an empty string what would happen?","width":866},{"text":"correct, we put two null bytes at the end","width":268},{"text":"so that's dangerous right? our code would actually copy more bytes than say the standard specification","width":540},{"text":"so now we've got a bug that only happens when we copy empty strings","width":537},{"text":"what else? there's another bug as well. yes? I'm writing memory that isn't part of dest or source","width":833},{"text":"okay, so I haven't malloc'd a new buffer yeah. okay so let me first mention the error I was going to point out","width":368},{"text":"which is actually the specification of strcat says we should return the beginning of the string","width":267},{"text":"we are actually returning the end of the string","width":150},{"text":"whoops, so we probably should have kept a copy of what the original value of dest was","width":363},{"text":"as it happens, most people don't tend to use this return value","width":225},{"text":"and so your code might work in most places until the day it doesn't","width":379},{"text":"now let's get back to that question of oh we haven't malloc'd any memory","width":225},{"text":"so strcat actually assumes that the destination is big enough for all these bytes that we are going to copy","width":536},{"text":"it doesn't do any mallocing itself, it just says okay give me a pointer, I'm going to assume that there is enough bytes available for me to copy whatever is available at source","width":610},{"text":"and if that is not true, well let's hope this code isn't actually driving a car or an expensive robot or flying a plane","width":568},{"text":"or something inside your bloodstream","width":332},{"text":"so strcat is dangerous, you have to promise that you've got enough bytes allocated at the target","width":597},{"text":"and for that reason many people avoid it and use strncat instead","width":393},{"text":"which I'm not going to talk about today","width":99},{"text":"and that saves you from some of these gotchas","width":248},{"text":"so it's better but it's still not perfect","width":186},{"text":"you can still have problems with strncat but I don't have time to talk about it right now","width":491},{"text":"okay right so for your next serving of C, I've got some code down here that uses strcpy and strcat and arrays and pointers to stuff","width":687},{"text":"what errors do you spot? if this was say a code review or in an interview and they said \"hey look at this code, what can you tell me about this?\"","width":602},{"text":"what can you and your neighbor find? what errors?","width":338},{"text":"what kinds of errors and how would you explain them?","width":284},{"text":"[long pause]","width":9792}],
  // Video 31 part 3
  [{"text":"okay, alright! so, what do we got here","width":354},{"text":"I got three variables: var1, var2, and arrrrrayyy!!!","width":287},{"text":"alright, just to point out that this is an array. and they all initialized to \"hello world! bounjour!\"","width":557},{"text":"now, there's a big difference between these and to point it out first of all let's talk about this very last line","width":404},{"text":"no, it is not possible to do this","width":548},{"text":"what this line is trying to do is say \"hey! I've got a pointer called array. make it point to the same thing that var2 is looking at\"","width":390},{"text":"no, you cannot do that. if you use just the array name here, it's treated as a pointer but there's a couple of big differences","width":780},{"text":"first of all, you can't change it","width":128},{"text":"this variable is the beginning of the array","width":384},{"text":"you can't make it point to a different piece of memory","width":278},{"text":"secondly, if you ask the size of array, you'd actually get back the number of bytes of the actual array","width":446},{"text":"unlike a pointer where it would tell you the number of bytes required to hold a pointer","width":253},{"text":"so no, you can't change array and make it point to something else","width":225},{"text":"you can, however, make a pointer to a character point to a character array. that's okay!","width":427},{"text":"now you've got var1 holding the same address that array hold","width":572},{"text":"alright, now, what about these other things up here?","width":192},{"text":"okay, strcpy! I want to copy into the array var1","width":251},{"text":"is that okay?","width":189},{"text":"if you said it's okay, you're correct!","width":276},{"text":"okay, why is that?","width":189},{"text":"well, here's what happens. we're actually saying \"I need an array and I need it to be big enough to hold the following data\" (bonjour)","width":582},{"text":"and when we run our program, when we start the process, we have a little array, here it is, and bonjour is copied into this array","width":1099},{"text":"so, our array lives in memory that you can read and write","width":233},{"text":"so if you want to copy other stuff into the array, yes, go for it. it will work. just remember that the array isn't an infinite length. it's fixed size. so you better make sure you accidentally copy too many bytes into this data structure","width":845},{"text":"so we're fine, we do strcpy into var1","width":191},{"text":"so that's okay, what about strcat var2 into array one?","width":209},{"text":"that looks fine too, ary is mutable, we can change it","width":456},{"text":"okay, here's the exciting part. yes, we're calling strcat so we are appending characters onto our array","width":480},{"text":"but you and I know that this array is not going to be big enough to hold whatever it is","width":442},{"text":"\"hello world\"","width":119},{"text":"we're gonna write the data w-o-r-l-d and a NULL byte past the end of the array","width":479},{"text":"who knows what's going to happen? woohoo. we don't know!","width":233},{"text":"it depends on how things are laid out in memory but I'll show a little demo in a moment just to show what happens","width":355},{"text":"whoops, what we have here is a buffer overflow. we had a buffer which is just our little array and we went past the end of it","width":579},{"text":"we wrote into memory that we should not have been writing into. we didn't own that memory. oops.","width":411},{"text":"and, I want to point out that this can happen not because you were just thinking about. you didn't think about memory slides. it can happen through typos.","width":623},{"text":"when you intended to say strcpy and instead your fingers wrote strcat","width":592},{"text":"bad things could happen. alright. especially if your pointer happens to point to arbitrary data at this point","width":365},{"text":"strcat is going to say \"okay! I'll copy this data for you. I just need to walk along this data and find a NULL byte\" and off he goes! bye!","width":581},{"text":"so be careful when you write strcat strcpy, just take a moment to check you actually wrote the intended one. of course, I've never had that mistake hahaha.","width":653},{"text":"and, what about strcat var1 var2? can I copy from what var2 points to into what var1 points to","width":849},{"text":"if you said yes, at least say it confidently because you're incorrect","width":381},{"text":"no you can't. var1 and var2 hold the memory address of this constant","width":560},{"text":"so yeah, you can change var1 you can make var1 point to something else. here we go. var1 equals hey, point to this other thing.","width":466},{"text":"hey, hold the value NULL","width":128},{"text":"ecetera. I can certainly make the contents of var1 be different","width":412},{"text":"but in this particular case, what it's pointing to is memory that is read only","width":502},{"text":"so if you try to start writing bytes into that address var1 points to, ah ah ah! no, you won't. the hardware will detect that and say \"you can't do that\" I'm only giving you read access to those bytes","width":950},{"text":"alright, any questions? yes! yeah. yes. the compiler will spot that","width":754},{"text":"so array names are special","width":387},{"text":"uh, it can be treated as a pointer. if you need a pointer, the compiler will turn that name into a pointer.","width":497},{"text":"and the pointer is at the beginning of the array","width":250},{"text":"alright, so, if you do things like ary+3, that will add 3 times however big each element is","width":576},{"text":"so if you point to an integer array, it will be array + 12 bytes","width":265},{"text":"if you're on a 32-bit machine with 4-byte integers","width":247},{"text":"alright so, remember, the compiler is just turning this into assembly code so it uses the type information","width":447},{"text":"and if its trying to get a pointer, it turns into a pointer","width":330},{"text":"okay, other questions. yes! uh, so var1 the variable itself is mutable. we can make var1 point to anything else. but yes, you are correct. I could now write strcpy var1 after this","width":1870},{"text":"okay, so, this is okay now. because var1 is pointing to the array. so of course I can copy okay into the array","width":754},{"text":"alright, we should talk about uh, I forgot to free memory. we do not need to free these memories. these are not on the heap","width":574},{"text":"you've actually got more than just the stack memory and heap memory","width":300},{"text":"you've got static memory where you'll discover these constants go","width":487},{"text":"where also our global variables go as well","width":178},{"text":"so you see heap memory when you call malloc. alright, that's how you get heap memory","width":564},{"text":"we haven't done a whole lot of malloc-ing yet","width":111},{"text":"and you see stack memory when you make a variable inside a function","width":556},{"text":"alright so here we go","width":155}],
  // Video 31 part 4
  [{"text":"that is going to be inside my heap","width":517.1818182468414},{"text":"well we're not doing that right now. we're playing things which are either constants or declared outside of functions","width":570.1818182468414},{"text":"let's do a quick demo. right, good","width":513.1818182468414},{"text":"here is the code we've got. I don't want this right now","width":683.1818182468414},{"text":"but I've done one extra thing, is I've made another array called demo. It's got the characters 1 2 3 4 5 6","width":594.1818182468414},{"text":"and I'm going to print it out twice. so we should see 1 2 3 4 5 6 twice, right","width":652.1818182468414},{"text":"but of course, because you know it's a demo, we're not going to see that. let's see what we get. oops, we have to turn off the asserts","width":856.1818182468414},{"text":"OK, we're not going to see that. this is what we saw instead. 123456. OK, so we've printed out the characters","width":783.1818182468414},{"text":"and then d and a smiley face. where did that come from?","width":866.1818182468414},{"text":"for some reason demo got obliterated by a d and smiley face and of course the null byte","width":633.1818182468414},{"text":"why? because first of all we copied var1 in and then we did a string cat and copied var2 into our array.","width":857.1818182468414},{"text":"but our array was not big enough to hold 'Hello..!' and 'World:-)'","width":485.18181824684143},{"text":"strcat doesn't know that, it merely copies the bytes until the end. and so it kept on going and it ran into the memory that is being used by demo","width":670.1818182468414},{"text":"and we could kind of prove that they are next to each other. let's have a look at where they are. so we can say, hey the array is at this address and demo is at this address","width":1380.1818182468414},{"text":"there we go. so array is at some low address and demo is at another low address, but just next door","width":669.1818182468414},{"text":"doing the mental arithmetic to subtract those two numbers is left as an exercise to the reader. but it's pretty close, yeah? it's about ten bytes","width":837.1818182468414},{"text":"right, that's our little demo. let's go back to our sheet. so let's talk about converting things","width":477.18181824684143},{"text":"if I've got a string and I want to convert it into a simple integer, how can I do that? well here's the easy way. use atoi","width":776.1818182468414},{"text":"so for example atoi of a hundred gives you the integer hundred","width":1033.1818182468414},{"text":"what do you think atoi of bananas is? ","width":1381.1818182468414},{"text":"place your guess now","width":700.1818182468414},{"text":"it's zero! so here's the downside of using atoi, yes it's really really quick. it's trivial to write code, but you'd better trust that what you're going to get is a valid integer that can be converted into a standard c integer because if it can't it doesn't crash, it doesn't complain, you have no way of knowing other than the fact that you got the value zero","width":1468.1818182468414},{"text":"so this returns a value of zero. so you don't know whether the user typed zero, entered zero, or whether it was invalid input","width":460.18181824684143},{"text":"so use it for little demos, quick hacks, etc., but if you actually want to check whether things are valid or not then it's time to use scanf","width":887.1818182468414},{"text":"because scanf will tell us how many things it successfully parsed. lets make a little scanf demo","width":1154.1818182468414},{"text":"OK, three integers walk into a program. there you go x y z. and I've got a string that I want to extract some values for","width":903.1818182468414},{"text":"maybe this is some 3D vertex data for example and I could use this function called scanf to say 'alright here's my input and I want you to treat it as an integer followed by some white space, another integer followed by some whitespace and another integer'","width":1163.1818182468414},{"text":"OK, how do I push that out? I need to give it the address of my variables. so remember ampersand means tell me the address of this thing","width":993.1818182468414},{"text":"OK and now if our program works","width":984.1818182468414},{"text":"tick tick tick tick, yeah! z is twelve! hooray! great, I've written a parser that can now read 3D data. watch out minecraft","width":843.1818182468414},{"text":"OK, what about 10 11 x?","width":571.1818182468414},{"text":"what do you think the value of z is now?","width":406.18181824684143},{"text":"well it's claiming that z is zero,but we should try something here. suppose we initialize z to be something else like 42","width":701.1818182468414},{"text":"z is still forty-two. so what our scanf did is it started eating, started walking along that string, it got to a point where it said this not what I expected and it choked. it just gave up and stopped","width":996.1818182468414},{"text":"so what we should do to write robust code is see how many things scanf actually managed to bite out of the input","width":644.1818182468414},{"text":"so let's have a variable here called numread and we can now check to see how many things were actually read by scanf and then we can write code that says, hold on a moment, I died trying to parse this line","width":1123.1818182468414},{"text":"now you can see numread equals two","width":203.18181824684143}],
  // Video 31 part 5
  [{"text":"extract out the x and the y and we failed when we tried to parse the third integer","width":474},{"text":"right, so scanf looks pretty easy and it is","width":268},{"text":"it is very easy to write bugs using scanf","width":281},{"text":"I've already mentioned one, okay so scanf - you saw that there are already different versions of it","width":545},{"text":"I was using sscanf because that allows me to start from the string which is good for demos","width":486},{"text":"there is also fscanf which guess what, starts from a file pointer","width":360},{"text":"so for example, I could read from stdin","width":235},{"text":"or I could read from a file that I've already got open","width":263},{"text":"and then we need the format string, okay so here's the first problem that you can run into","width":415},{"text":"this looks a lot like printf, printf's format string yes? I just showed you one with %d's","width":581},{"text":"and it is until it isn't","width":209},{"text":"it's actually subtly different, so the day that you actually need to write a scanf, open up the manpage and check the format specifiers because it's not quite the same","width":635},{"text":"for example floating points are slightly different","width":177},{"text":"so that's the kind of first gotcha. that second gotcha I've just shown you, which is that the number of items that you've read isn't necessarily all of them, so you should check that","width":819},{"text":"and then the third gotcha is guess what, we can put in addresses here and sometimes you want to put in an ampersand and sometimes you don't","width":722},{"text":"so I showed you one way we did ampersand y ampersand z because I actually wanted to know the address of my integer variables","width":904},{"text":"can you think of a time when you might not actually want to put in the ampersand?","width":492},{"text":"yeah, if you already have a pointer to the thing that you want to change","width":359},{"text":"so if you've got a pointer to an integer variable, there we go, let's put in pointer here and provided that pointer is pointing to something a variable I want to change, everything is fine","width":1612},{"text":"everything is not fine if I was to write in ampersand pointer","width":522},{"text":"because now what am I changing?","width":333},{"text":"I'm changing this, I'm not changing the thing its pointing to","width":383},{"text":"and if you think this is complicated or confusing, it is!","width":245},{"text":"so my advice is don't write scanf code until you've had three cups of coffee, you're completely awake and it's the most important thing in the world to get it right","width":470},{"text":"and even then, assume that you've got it wrong","width":211},{"text":"scanf code is incredibly hard to write correctly and you can get nasty little errors just by missing an ampersand or putting an ampersand when you don't need one","width":525},{"text":"scanf is not going to detect that, you have to be extremely clear about whether you mean to talk about the thing, the address of the thing or using the thing that the thing is pointing to","width":732},{"text":"so it's not for the feint hearted","width":118},{"text":"and with that warning, let's carry on","width":323},{"text":"I can promise you I've spent hours debugging scanf code","width":249},{"text":"that I thought was correct","width":209},{"text":"here's some other things that will kill us or get you","width":201},{"text":"gets is easy to use, you just say gets and you give it a pointer to your buffer","width":718},{"text":"to some characters","width":460},{"text":"description, never use this function","width":238},{"text":"the reason I bring it up is because people like to ask about it occasionally in exams and occasionally in interviews","width":356},{"text":"it's a classic example of how to hack a program, hack a C program because gets like strcpy has no idea how big this buffer is","width":781},{"text":"how many bytes it can safetly write into whatever address you give it","width":377},{"text":"so if the data that it's reading from stdin happens to be bigger than your buffer, arbitrary things can happen","width":431},{"text":"now someone could use this to supply data that is longer than your buffer and start overwriting arbitrary memory locations","width":433},{"text":"and those arbitrary memory locations probably correspond to other variables","width":283},{"text":"so now someone can use your program to do bad things, to do things that the program is not designed to do","width":490},{"text":"so how do we fix this? answer: use fgets instead","width":414},{"text":"right and I'm not going to talk about that because there's some more fun stuff we can do down here","width":425},{"text":"let's do environment stuff, I don't think I've shown you environment stuff yet have I?","width":441},{"text":"okay right so every program when it runs has arguments and an environment ","width":425},{"text":"so if we do env for example, you can see that my program has actually when it runs, has all of this information","width":601},{"text":"all kinds of useful stuff like the current user is root, where the home directory is for example, the current directory is probably in there as well","width":705},{"text":"so I can get access to this stuff when I write my C programs","width":405},{"text":"so let's write a little C program that does this","width":245},{"text":"for example, I'll say I've got extern, environ, now this extern means that look, this thing exists","width":806},{"text":"don't allocate any space for it, but when we finally link all the pieces of my program together","width":443},{"text":"the compiler is going to look for this variable because we've simply declared that it exists somewhere and I want to use it inside my C program right now","width":553},{"text":"so let me put the contents of the first entry of environ and then we'll exit","width":1106},{"text":"okay so you see we've just got a string","width":177},{"text":"a simple C string which is in the form of key and equals and a value","width":521},{"text":"and I could write a little loop to go through all of them and when I find once which is null at the end I know I've finished","width":666},{"text":"so if I want to enumerate all of my environment variables, I can use environ","width":385},{"text":"if I actually want to look one up that I know exists, I can use getenv, so let's getenv and say look for user okay so that will give me","width":704}],
  // Video 31 part 6
  [{"text":"uhh, an answer and I'll print that out.","width":983},{"text":"okay, so we can see that my program when it says getenv on the current user, it prints out root","width":439},{"text":"woohoo!","width":201},{"text":"so, environment variables are one way of passing useful things to your program. as we've seen, so say you can look at the current user's home directory and store your preferences there. or if you're mean, you can delete all their files","width":1117},{"text":"so that's one way to get a general general environment. the other way you've seen of course, is that our main method has two parameters. argc and argv","width":780},{"text":"which is a character pointer pointer","width":320},{"text":"so, let's all look at this. first of all, some important points about them (come back!)","width":285},{"text":"the first is that the very first entry of argv is not one of the program arguments. it's actually the program name","width":1112},{"text":"so I for example, could write a usage thing. blah blah blah blah","width":698},{"text":"and, if there are any other arguments, we can find out how many there are","width":522},{"text":"arguments %d our count","width":930},{"text":"alright so, it's program name, the way its actually executing we can actually discover from the program itself. it's the very first zeroth argument. and we've got one argument so this is like another kind of classic off by one thing again","width":913},{"text":"so if I have, you know, cats, it thinks its got two arguments","width":380},{"text":"what it means by that is that that array has got two entries","width":293},{"text":"and the first one being the program name","width":192},{"text":"the second entry being cats","width":126},{"text":"and in fact, that's not even quite correct either because it happens to be always one final entry at the end which is NULL","width":596},{"text":"so we could go through and look at all of the arguments","width":343},{"text":"so let's do that. we'll have a little pointer. let's make it point to argv + 1, in other words, we're not going to print out the program name this time (come back!)","width":882},{"text":"yeah let's get rid of that stuff","width":442},{"text":"okay, right, we'll stuff [something] we'll print everything we find at the pointer","width":587},{"text":"so I need a pointer to an array and a pointer","width":967},{"text":"while the entry is non-zero, let's print it out.","width":261},{"text":"and we'll add one!","width":959},{"text":"okay, so let's now try our little program. oh I forgot to follow the pointer. okay cats are cool","width":1330},{"text":"alright, so, we can access each of the arguments that the program has","width":483}],

  // Start Lecture Video 2
  // Part 0
  [{"text":"okay, hi. I'm gonna ask you to volunteer (student: oh okay) alright.","width":1559},{"text":"I'm going to ask you to volunteer for something in a moment","width":190},{"text":"Okay! Good morning class! how are you?","width":872},{"text":"great! so, here we go, uh today we're going to talk mostly about fork() and exec()","width":337},{"text":"maybe we'll have time to talk about signals as well","width":242},{"text":"yes there will be an in-class exam/quiz coming up next week","width":329},{"text":"we'll see when it happens","width":149},{"text":"I guarantee it won't be Monday","width":383},{"text":"Or tuesday or thursday","width":85},{"text":"alright, more details next week.","width":184},{"text":"so first of all let's just start off with a little demonstration of how fork() works","width":327},{"text":"for that, I need a volunteer, yes! thank you! please come on down","width":217},{"text":"alright, so, um, here's my process and of course [something] today you're gonna be my process, right?","width":527},{"text":"so, a process to run of course needs some instructions to execute","width":345},{"text":"here we go, stand here, you're my process, right.","width":137},{"text":"okay thank you. and, here's the code that I've already compiled right into something the CPU can execute","width":589},{"text":"okay, we've got inside the process memory you've got a pointer called neurons and an int called capacity right and we run this function called init brain","width":604},{"text":"it's kind of complicated","width":142},{"text":"it does a lot of stuff","width":39},{"text":"when we pass in the address of neurons and the address of capacity, so there's init brain when it returns will set where the neurons being held and the number of neurons that we have","width":798},{"text":"so, it looks a little like readline, yes?","width":211},{"text":"and, manage to actually return a void pointer so we can actually use that perhaps","width":252},{"text":"okay so we're running this code, okay, and the next thing to do is think of a number, right?","width":384},{"text":"so, think of a number between 1 and 10","width":185},{"text":"don't tell me! don't tell me...","width":213},{"text":"and then you're gonna print the number to standard out","width":181},{"text":"alright, so, this is my standard out here","width":270},{"text":"you can write a number...okay","width":229},{"text":"accept!","width":59},{"text":"oh you need a pen","width":64},{"text":"accept","width":81},{"text":"here's what we're gonna do, right. you thought of a number, yes? it's in your head. inside the process","width":308},{"text":"before you print it out, I'm going to change the program now","width":325},{"text":"in just here, I'm gonna call fork()","width":399},{"text":"okay? between thinking a number and printing it out","width":137},{"text":"I'm calling fork()","width":103},{"text":"so, what does fork() do? it doesn't not restart the process.","width":294},{"text":"no. here's what fork does: it says take a process that you've got and clone it","width":435},{"text":"yes? make an almost-exact copy of you!","width":272},{"text":"now I've scanned the audience and I've found the person who looks exactly like you","width":288},{"text":"I need my second volunteer. thank you, come on down","width":165},{"text":"[laughter]","width":390},{"text":"alright, so, at this point if you'd like to write down your number.","width":612},{"text":"so we've got two processes. don't show me your number","width":246},{"text":"and of course, thank you. so, we've got two processes and because we've cloned it, inside their memory, it should be exactly the same","width":773},{"text":"so if we now were to say to both of them, okay, continue executing, remember these are two completely different processes","width":330},{"text":"their own memory happen to be following the same assembly instructions here.","width":282},{"text":"the same code","width":115},{"text":"so if we asked them to print out their number, let's find out what they would say!","width":192},{"text":"here, hold them up and show the audience please","width":325},{"text":"look at that!","width":126},{"text":"alright, they're both printing out seven","width":240},{"text":"which is also what you wrote","width":183},{"text":"okay, that's a miracle. [laughter] alright so, well, a 1 in 10 miracle, not a big miracle, but we'll just leave it","width":432},{"text":"so this is how fork() works","width":192},{"text":"remember that this is what happens. it doesn't restart the process. it splits it","width":146},{"text":"so give our volunteers a round of applause, thank you very much [clapping]","width":197},{"text":"because we're going to use that now in C and remember anything you write in C could, in principle, be done in any other program as well. in any other script language like python","width":571},{"text":"python, for example, has a fork()","width":136},{"text":"but underneath, python's written in C, and underneath that, it just calls the fork() command","width":374},{"text":"okay so, I've got a little example of that in terms of code. here it is","width":852},{"text":"here we go, can we read that? okay, so here's my little example","width":220},{"text":"this srand() here thing, this says \"okay, system, tell me what time it is?\" and I'll use that to initialize my random number generator","width":566},{"text":"so remember to actually generate random numbers, we cheat. we just do some mathematical bit shifting tricks so it appears to us to be a random number","width":634},{"text":"and it appears to satisfy some basic statistical tests","width":258},{"text":"but there's not really a random source here","width":172},{"text":"it's just a mathematical stream of numbers that appears to run all over the place","width":370},{"text":"so later when we call rand() we get back a random number","width":221},{"text":"but look at this for a moment! I've called fork() this time beforehand","width":297},{"text":"so the question is, what do you think will happen here?","width":240},{"text":"will my two processes. so, I have a new job process created. will they both print out the same thing? let's run this and find out.","width":1026},{"text":"okay so what do we get? well each process is told to print out its id number","width":262},{"text":"so we get two different id numbers of course","width":128},{"text":"and look, my random number is 6!","width":258},{"text":"they both printed out the same thing! was it an accident? no. they actually both print out the same number","width":466},{"text":"so, why do you think that is?","width":359},{"text":"yes! at the back. thank you, yes, they both have the same random seed and the random state is part of the process","width":727},{"text":"so we've just cloned the whole thing","width":290},{"text":"so actually, you can use one process to guess what random number generators the child process is going to create as well","width":695},{"text":"because they are indentical","width":101},{"text":"it's like your cloned brother or sister or whatever your genetic clone knows exactly what you're thinking","width":652},{"text":"so this actually is potentially a vulnerability if you know, if you completely understand the state of a process, you can predict what it actually might do","width":695},{"text":"alright, so that's a silly example but I'm trying to show the idea that you start a process, you call fork() and suddenly, you have two processes continuing on past that fork() call","width":696}],
  // Part 1
  [{"text":"if I've got two processes how could I make the two process start to do different things?","width":513.1818182468414},{"text":"right now they've done the same thing, I want them to do different things","width":216.18181824684143},{"text":"here's how, we'll check the return value of fork because that is one asymmetry that we have to play with","width":530.1818182468414},{"text":"if child is greater than zero, so if the result is greater than zero for my fork","width":636.1818182468414},{"text":"guess what? it means I have a child!","width":460.18181824684143},{"text":"therefore I must be the parent","width":666.1818182468414},{"text":"so now our parent could just exit","width":792.1818182468414},{"text":"what's going to happen now? this time only one process gets to print out their random number, the child process","width":993.1818182468414},{"text":"we could make this more complicated and we could have our child calling another fork, for example. have many many many more children if we wished","width":720.1818182468414},{"text":"the main point to get here is the idea that you are duplicating the world at this point. you are duplicating the process by calling fork and you have two to play with","width":740.1818182468414},{"text":"let's put that aside for a moment and talk about that very first program. the very first program we've got here does quite a bit","width":570.1818182468414},{"text":"this is an example of quite a bit of system call programming. now we're actually calling system when we're making lots of different calls","width":749.1818182468414},{"text":"my question to you is can you explain every single line of this program?","width":534.1818182468414},{"text":"if you can, if you've been reading ahead in some of the manuals now's your chance to explain it to your neighbor. if you're not sure about something ask your neighbor. see if they know more system programming than you","width":819.1818182468414},{"text":"what is this program doing? ","width":221.18181824684143},{"text":"what does every line do?","width":275.18181824684143},{"text":"you want a handout? sure.","width":650.1818182468414},{"text":"this is the (cut's off)","width":329.18181824684143},{"text":"(speaking to a student) oh ok, what was the question?","width":816.1818182468414},{"text":"(still speaking directly to a student) we killed the parent process, but now the child process carries on","width":621.1818182468414},{"text":"yes, that is how we write the code. we say if I'm the parent just exit so the child carries on. yeah, sure","width":1991.1818182468414},{"text":"anybody else missing a handout?","width":5285.181818246841},{"text":"OK, let's start with a quick demo. This very first line is close one, alright, so if I print something here, woohoo 'hi!'","width":784.1818182468414},{"text":"and 'oh no'. ok, right, let's run this","width":695.1818182468414},{"text":"we're calling puts, I could've called printf as well. I get 'hi!' but that's all I get, I don't get the 'oh no!' because standard out is gone, we've closed itl ","width":778.1818182468414},{"text":"so yes, puts might eventually call write but it's just ignored, that output doesn't go anywhere. I could've for example put printf here, I could've put write into one the following the bytes","width":1010.1818182468414},{"text":"it doesn't matter, all of this stuff just goes no where, we've closed that file descriptor so one doesn't have any meaning anymore","width":488.18181824684143},{"text":"the system just ignores any attempts to send bytes to that particular file descriptor","width":433.18181824684143},{"text":"we've closed it, but then where'd my line go... we call open","width":863.1818182468414},{"text":"open says hey I'd like a file descriptor please","width":214.18181824684143},{"text":"let's see what this returns","width":331.18181824684143},{"text":"where's that return gone to, come back here","width":171.18181824684143},{"text":"and I'll print it out","width":153.18181824684143},{"text":"but I'll print it out to standard error","width":264.18181824684143},{"text":"and fd equals","width":873.1818182468414},{"text":"what error did we get?","width":455.18181824684143},{"text":"I better have some includes here. so if we check the man page for open and I need section two, we are going to need the following three includes. let's grab them","width":1224.1818182468414},{"text":"so we printed 'Hi!' and we get back from open an integer one","width":336.18181824684143},{"text":"it's opened a file descriptor for us, a stream, somewhere we can send bytes. except this time rather than making it appear in our console we're going to make it appear in a file and","width":986.1818182468414},{"text":"we gave these options to open to say 'OK, I'd like to open please this file called log.txt, I need to open it for read and write, I want to create it if it doesn't exist, I want to append to it and then finally I'm going to give some options which I also bitwise or about who can read it and who can write it","width":1188.1818182468414},{"text":"these options are saying that only I can read and write it","width":204.18181824684143},{"text":"so let's start printing some things out, like 'Hello', right and we'll run this","width":960.1818182468414}],
  // Part 2
  [{"text":"alright and keep doing this while either one of these is valid","width":624},{"text":"okay what do you think about that code?","width":370},{"text":"hold on hold on you can't see it","width":200},{"text":"is this code correct?","width":128},{"text":"does it copy the null byte at the end?","width":1104},{"text":"okay alright if your neighbor thinks it copies the null byte get a new neighbor","width":524},{"text":"right why does it not copy the null byte?","width":543},{"text":"because we've incremented the source pointer","width":215},{"text":"right so we copy a byte, we keep copying characters and then we increment the source pointer and then we say while source","width":446},{"text":"so we are checking the next byte, the byte that we haven't yet copied","width":496},{"text":"so no, that code doesn't actually coy the very last byte","width":263},{"text":"you see, C program is easy","width":226},{"text":"or actually C programming with bugs is easy, writing correct programs is harder","width":369},{"text":"and we wouldn't have spotted this if our destination memory had all been zeroed by some fortuitous accident","width":448},{"text":"so that is incomplete, we still need to copy the byte at the end","width":373},{"text":"so at the very end I need to put a null byte in","width":374},{"text":"so I could write that as zero, I could write that as backslash zero","width":421},{"text":"that means the null byte","width":115},{"text":"and then finally return dest","width":471},{"text":"okay what do you think about that code","width":273},{"text":"yes, so if source is just an empty string what would happen?","width":866},{"text":"correct, we put two null bytes at the end","width":268},{"text":"so that's dangerous right? our code would actually copy more bytes than say the standard specification","width":540},{"text":"so now we've got a bug that only happens when we copy empty strings","width":537},{"text":"what else? there's another bug as well. yes? I'm writing memory that isn't part of dest or source","width":833},{"text":"okay, so I haven't malloc'd a new buffer yeah. okay so let me first mention the error I was going to point out","width":368},{"text":"which is actually the specification of strcat says we should return the beginning of the string","width":267},{"text":"we are actually returning the end of the string","width":150},{"text":"whoops, so we probably should have kept a copy of what the original value of dest was","width":363},{"text":"as it happens, most people don't tend to use this return value","width":225},{"text":"and so your code might work in most places until the day it doesn't","width":379},{"text":"now let's get back to that question of oh we haven't malloc'd any memory","width":225},{"text":"so strcat actually assumes that the destination is big enough for all these bytes that we are going to copy","width":536},{"text":"it doesn't do any mallocing itself, it just says okay give me a pointer, I'm going to assume that there is enough bytes available for me to copy whatever is available at source","width":610},{"text":"and if that is not true, well let's hope this code isn't actually driving a car or an expensive robot or flying a plane","width":568},{"text":"or something inside your bloodstream","width":332},{"text":"so strcat is dangerous, you have to promise that you've got enough bytes allocated at the target","width":597},{"text":"and for that reason many people avoid it and use strncat instead","width":393},{"text":"which I'm not going to talk about today","width":99},{"text":"and that saves you from some of these gotchas","width":248},{"text":"so it's better but it's still not perfect","width":186},{"text":"you can still have problems with strncat but I don't have time to talk about it right now","width":491},{"text":"okay right so for your next serving of C, I've got some code down here that uses strcpy and strcat and arrays and pointers to stuff","width":687},{"text":"what errors do you spot? if this was say a code review or in an interview and they said \"hey look at this code, what can you tell me about this?\"","width":602},{"text":"what can you and your neighbor find? what errors?","width":338},{"text":"what kinds of errors and how would you explain them?","width":284},{"text":"[long pause]","width":9792}],
  // Part 3
  [{"text":"okay, alright! so, what do we got here","width":354},{"text":"I got three variables: var1, var2, and arrrrrayyy!!!","width":287},{"text":"alright, just to point out that this is an array. and they all initialized to \"hello world! bounjour!\"","width":557},{"text":"now, there's a big difference between these and to point it out first of all let's talk about this very last line","width":404},{"text":"no, it is not possible to do this","width":548},{"text":"what this line is trying to do is say \"hey! I've got a pointer called array. make it point to the same thing that var2 is looking at\"","width":390},{"text":"no, you cannot do that. if you use just the array name here, it's treated as a pointer but there's a couple of big differences","width":780},{"text":"first of all, you can't change it","width":128},{"text":"this variable is the beginning of the array","width":384},{"text":"you can't make it point to a different piece of memory","width":278},{"text":"secondly, if you ask the size of array, you'd actually get back the number of bytes of the actual array","width":446},{"text":"unlike a pointer where it would tell you the number of bytes required to hold a pointer","width":253},{"text":"so no, you can't change array and make it point to something else","width":225},{"text":"you can, however, make a pointer to a character point to a character array. that's okay!","width":427},{"text":"now you've got var1 holding the same address that array hold","width":572},{"text":"alright, now, what about these other things up here?","width":192},{"text":"okay, strcpy! I want to copy into the array var1","width":251},{"text":"is that okay?","width":189},{"text":"if you said it's okay, you're correct!","width":276},{"text":"okay, why is that?","width":189},{"text":"well, here's what happens. we're actually saying \"I need an array and I need it to be big enough to hold the following data\" (bonjour)","width":582},{"text":"and when we run our program, when we start the process, we have a little array, here it is, and bonjour is copied into this array","width":1099},{"text":"so, our array lives in memory that you can read and write","width":233},{"text":"so if you want to copy other stuff into the array, yes, go for it. it will work. just remember that the array isn't an infinite length. it's fixed size. so you better make sure you accidentally copy too many bytes into this data structure","width":845},{"text":"so we're fine, we do strcpy into var1","width":191},{"text":"so that's okay, what about strcat var2 into array one?","width":209},{"text":"that looks fine too, ary is mutable, we can change it","width":456},{"text":"okay, here's the exciting part. yes, we're calling strcat so we are appending characters onto our array","width":480},{"text":"but you and I know that this array is not going to be big enough to hold whatever it is","width":442},{"text":"\"hello world\"","width":119},{"text":"we're gonna write the data w-o-r-l-d and a NULL byte past the end of the array","width":479},{"text":"who knows what's going to happen? woohoo. we don't know!","width":233},{"text":"it depends on how things are laid out in memory but I'll show a little demo in a moment just to show what happens","width":355},{"text":"whoops, what we have here is a buffer overflow. we had a buffer which is just our little array and we went past the end of it","width":579},{"text":"we wrote into memory that we should not have been writing into. we didn't own that memory. oops.","width":411},{"text":"and, I want to point out that this can happen not because you were just thinking about. you didn't think about memory slides. it can happen through typos.","width":623},{"text":"when you intended to say strcpy and instead your fingers wrote strcat","width":592},{"text":"bad things could happen. alright. especially if your pointer happens to point to arbitrary data at this point","width":365},{"text":"strcat is going to say \"okay! I'll copy this data for you. I just need to walk along this data and find a NULL byte\" and off he goes! bye!","width":581},{"text":"so be careful when you write strcat strcpy, just take a moment to check you actually wrote the intended one. of course, I've never had that mistake hahaha.","width":653},{"text":"and, what about strcat var1 var2? can I copy from what var2 points to into what var1 points to","width":849},{"text":"if you said yes, at least say it confidently because you're incorrect","width":381},{"text":"no you can't. var1 and var2 hold the memory address of this constant","width":560},{"text":"so yeah, you can change var1 you can make var1 point to something else. here we go. var1 equals hey, point to this other thing.","width":466},{"text":"hey, hold the value NULL","width":128},{"text":"ecetera. I can certainly make the contents of var1 be different","width":412},{"text":"but in this particular case, what it's pointing to is memory that is read only","width":502},{"text":"so if you try to start writing bytes into that address var1 points to, ah ah ah! no, you won't. the hardware will detect that and say \"you can't do that\" I'm only giving you read access to those bytes","width":950},{"text":"alright, any questions? yes! yeah. yes. the compiler will spot that","width":754},{"text":"so array names are special","width":387},{"text":"uh, it can be treated as a pointer. if you need a pointer, the compiler will turn that name into a pointer.","width":497},{"text":"and the pointer is at the beginning of the array","width":250},{"text":"alright, so, if you do things like ary+3, that will add 3 times however big each element is","width":576},{"text":"so if you point to an integer array, it will be array + 12 bytes","width":265},{"text":"if you're on a 32-bit machine with 4-byte integers","width":247},{"text":"alright so, remember, the compiler is just turning this into assembly code so it uses the type information","width":447},{"text":"and if its trying to get a pointer, it turns into a pointer","width":330},{"text":"okay, other questions. yes! uh, so var1 the variable itself is mutable. we can make var1 point to anything else. but yes, you are correct. I could now write strcpy var1 after this","width":1870},{"text":"okay, so, this is okay now. because var1 is pointing to the array. so of course I can copy okay into the array","width":754},{"text":"alright, we should talk about uh, I forgot to free memory. we do not need to free these memories. these are not on the heap","width":574},{"text":"you've actually got more than just the stack memory and heap memory","width":300},{"text":"you've got static memory where you'll discover these constants go","width":487},{"text":"where also our global variables go as well","width":178},{"text":"so you see heap memory when you call malloc. alright, that's how you get heap memory","width":564},{"text":"we haven't done a whole lot of malloc-ing yet","width":111},{"text":"and you see stack memory when you make a variable inside a function","width":556},{"text":"alright so here we go","width":155}],
  // Part 4
  [{"text":"alright, the only other thing I want to say about this. this is the second semester I've presented sleep sort. Before that CS241 didn't have a sorting algorithm","width":714.1818182468414},{"text":"and it kinda felt lonely because 125, 225, every other theory class you take has a sorting algorithm. now we can proudly say, yes, system programming has a sorting algorithm","width":734.1818182468414},{"text":"right, so, questions about this algorithm? other than never use it!","width":577.1818182468414},{"text":"right so clearly it's got some limitations. sleep's going to count for a second in seconds etc","width":490.18181824684143},{"text":"and also it relies on the operating system to implement sleep so it's not truly an order n algorithm. the operator is just delegating all the work to the operating system to make sure the processes sleep the right amount of time. in other wrods, when you call sleep your process gets stuck, it's not going to execute anymore instructions until the operating system wakes it up. we'll be talking about how it does that when we talk about scheduling later on in the course","width":1925.1818182468414},{"text":"let's go back to some more serious questions. what does the child inherit from the parent?","width":509.18181824684143},{"text":"all the money, right, no. ","width":217.18181824684143},{"text":"what've we got? what've we seen so far, what does it inherit when we call fork? what do you think it inherits? what do you get? i'm sorry?","width":832.1818182468414},{"text":"variables, yes! so you get a copy of the memory","width":300.18181824684143},{"text":"all of the processes memory you get a complete copy of that. ok, what else?","width":683.1818182468414},{"text":"that's kind of all in the memory, yes all of your c variables etc, the state of any kind of libraries like the rand. state of the random number generator. what else might you get?","width":929.1818182468414},{"text":"OK, I'll give you two. current directory and open files","width":1036.1818182468414},{"text":"if you've opened a file you'll fork will also be able to read and write into that file. more about that more later in terms of the details in terms of what happens when both the parent and child read and write into the same file","width":1062.1818182468414},{"text":"what's different between the child process and the parent process?","width":290.18181824684143},{"text":"here's a couple of differences. first of all, guess what, if you call getpid you get different numbers","width":815.1818182468414},{"text":"what else is different? the return value of fork ","width":1050.1818182468414},{"text":"if the result is greater than zero you know you have a child and therefore you must be the parent","width":1541.1818182468414},{"text":"oh yes","width":149.18181824684143},{"text":"there's something else that's different","width":538.1818182468414},{"text":"what do you think getppid does?","width":325.18181824684143},{"text":"yes! parents! hey I want to know the ID of my parent","width":355.18181824684143},{"text":"so of course that's going to be different","width":375.18181824684143},{"text":"you could probably write out a program to print the parent ID in two different ways. in the parent if fork returns a number it's easy, it's my ID. if i'm the child then I should be calling getppid to get the parent","width":1023.1818182468414},{"text":"so if I've got these two processes and I've shown you that we can write an if statement so they can do two different things, how can I make it so my parent waits for the child to finish?","width":927.1818182468414},{"text":"easy, we call wait or waitpid. let's have a look at this","width":530.1818182468414},{"text":"I will write a little program that immediately forks","width":516.1818182468414},{"text":"if result is greater than zero..what? I'm the parent","width":583.1818182468414},{"text":"OK, what should we do with the parent? let's wait for our child to do something","width":501.18181824684143},{"text":"so how do we finish? for this we'll look up waitpid","width":917.1818182468414},{"text":"we'll say who are you waiting for? I could pass in minus one to say 'hey I'm waiting for anybody', but actually I care about my child finishing","width":559.1818182468414},{"text":"then I can find out what happened to them, so I can basically do a post mortem on my child here and I can pass in some options but I don't need them for this lecture so I want to put zero","width":922.1818182468414},{"text":"let's have an integer and notice that I'm passing in the address of the integer","width":359.18181824684143},{"text":"if I do that waitpid can write it's notes into that integer because I've given the address of the integer","width":725.1818182468414},{"text":"now we could print something out about the child. percent d... waitpid said","width":1186.1818182468414},{"text":"ah, didn't save it","width":642.1818182468414},{"text":"our program get's result. what does our child do?","width":402.18181824684143},{"text":"our child does nothing. well actually it just gets to the end of the program, it finishes","width":432.18181824684143},{"text":"so the child says 'oh my result is actually zero so let me do what's down here. OK, nothing, I'll just finish, I'll just quit'","width":461.18181824684143},{"text":"we could write some special code for the child though. why don't we say sleep for a little bit like two seconds and then quit","width":935.1818182468414},{"text":"byeee","width":256.18181824684143}],
  // Part 5
  [{"text":"okay so if this works, then what we should see is the child will sleep for two seconds and our parent will then be paused also for two seconds","width":801},{"text":"because it had to wait for the child","width":361},{"text":"okay, so one, two, bye and then our parent can continue right?","width":389},{"text":"so we've made the parent wait for the child","width":312},{"text":"now there's a little bit more to using waitpid","width":321},{"text":"that actually there are some macros down here ","width":389},{"text":"here they are, that actually to put useful information out of this, I should use these macros","width":380},{"text":"so for example, we can find out the exit value of the child but only the lowest seven or eight bits","width":702},{"text":"sorry, eight bits, so if your child return a value 42, great we can see that","width":495},{"text":"if it returns a value 304, I'm sorry you won't see that as a value, you only get the lowest eight bits","width":426},{"text":"we can also check to see if it was terminated by a signal","width":224},{"text":"right, how can you generate a signal?","width":291},{"text":"pull our a whistle from your pocket, yeah but you could also press control c on your keyboard to interrupt a process","width":448},{"text":"and when you interrupt a process, you are sending that process a signal","width":428},{"text":"there's other signals that can happen as well","width":159},{"text":"so if your process tries to write into read only memory, your process dies","width":438},{"text":"how does it die? it gets sent a signal that in cannot ignore","width":285},{"text":"so as you can see, we can actually find out some things about our child","width":303},{"text":"and you'll be using that in this week's little assignment before section","width":488},{"text":"alright so let's make it print something out, right so in this case what we'll do is we will say","width":706},{"text":"if it exited, so let's check the value of status","width":373},{"text":"then we'll print out the exit value","width":528},{"text":"WEXITSTATUS we'll get those lowest bits and we'll make the child return 42","width":1515},{"text":"did it run? one error, what's my error?","width":811},{"text":"oh, okay so I have not included something..","width":1038},{"text":"one two yay, okay great","width":168},{"text":"so this time you can see our waitpid got some arbitrary value","width":288},{"text":"if you actually want to pull out the exit value then you should use those macros","width":453},{"text":"alright so if exited, then we know that we can actually pull out an exit status as well","width":410},{"text":"right, so how do I wait for my child to finish? waitpid!","width":351},{"text":"and on here how do I find the exit value? you should use the if exited then we can use the WEXITSTATUS macro","width":1113},{"text":"and all these macros do is just pull out the relevant bits and do some bit shifting from that original integer","width":697},{"text":"okay, right so are you ready? page 2","width":413},{"text":"how do I start a background process? well a background process is something that we want to run in the background","width":379},{"text":"right we don't care about interacting with it","width":365},{"text":"maybe I want to actually say compile a program in the background","width":227},{"text":"let's do it from the command line here so","width":404},{"text":"for example if I want to look at the contents of /usr/include/stdlib.h","width":522},{"text":"right, I could say that actually I just want to send that to a file","width":609},{"text":"but I don't want to wait for this to finish well I can just put an ampersand at the very end","width":318},{"text":"that means run it in the background","width":206},{"text":"and I can continue doing this whilst that copying happens","width":392},{"text":"we could do the same thing in C by not bothering to wait","width":650},{"text":"so I've got my fork here and I could do other stuff in the background ","width":476},{"text":"sorry I could do other stuff inside the parent and not wait for the child to finish","width":313},{"text":"so this is why fork is very powerful right? now I can fork and start a process to compile something. I could fork and start another child process to connect to the internet","width":563},{"text":"and I don't have to wait for these things to complete","width":164},{"text":"I can do things in parallel yay","width":201},{"text":"right, so now if you've got 4 CPUs you can use all four at the same time to compile different parts of your program for example","width":557},{"text":"there is a problem though","width":397},{"text":"good parents don't let their children become zombies","width":437},{"text":"suppose you created a child process and off it goes and it starts compiling stuff","width":439},{"text":"and then you the parent process finish, you quit","width":252},{"text":"what happens to the child process?","width":142},{"text":"it's still alive! ha ha ha compiling alive, it's still going right!","width":449},{"text":"but it has no parent","width":198},{"text":"uh oh, right, so, uhm, so here's what happens, if nobody is around to wait for the child when it finally finishes","width":1095},{"text":"if you don't call wait on a finished process, you get a zombie","width":277},{"text":"so a zombie is a dead process","width":150},{"text":"that no one cares about","width":228},{"text":"so waitpid is like going to the gravestone and saying yeah I remember you let's do a postmortem ","width":228},{"text":"if you don't do that to a process, the system says well actually somebody might want to know about that process","width":392},{"text":"they might want to know its exit value for example","width":138},{"text":"so it's going to take up some system resources, not a lot, but a little bit to remember what happened to that child","width":557},{"text":"so that's what a zombie is, it's a dead process that nobody cares about","width":384}],
  // Part 6
  [{"text":"alright, doesn't sound too bad, right? but what would happen if we had too many zombies?","width":607.1818182468414},{"text":"eventually, the system says \"I'm not creating any more processes for nobody\"","width":294.18181824684143},{"text":"yes? I will kill another process so your fork(), for example, would fail or another processes fork() would fail.","width":959.1818182468414},{"text":"okay so, you can do that. the child will continue and the child will do what it wants to do. okay?","width":380.18181824684143},{"text":"um, so, uh, the system has one thing it will try to do to prevent zombies. which is that in this situation if the parent finishes, and the child is left running","width":982.1818182468414},{"text":"that child is re-parented","width":265.18181824684143},{"text":"given a new parent","width":51.18181824684143},{"text":"so if it called get ppid(), it doesn't crash, it doesn't explode, no it has a new parent.","width":521.1818182468414},{"text":"I'll tell you who the parent is","width":180.18181824684143},{"text":"process 1","width":253.18181824684143},{"text":"the ultimate of processes. the first process in your system. the first process that ever existed when you booted up: process 1","width":473.18181824684143},{"text":"well, kind of the first process","width":109.18181824684143},{"text":"the first process with a process number anyway","width":206.18181824684143},{"text":"the ultimate of processes","width":78.18181824684143},{"text":"right? which classically has been initially or just initiate or just init","width":613.1818182468414},{"text":"goes by various names","width":213.18181824684143},{"text":"and it calls wait","width":173.18181824684143},{"text":"on the poor little orphans","width":114.18181824684143},{"text":"alright, to ensure that we don't get zombies.","width":292.18181824684143},{"text":"so, life is not too bad if your parent dies right? the children as they finish, they will get reparented onto init. then init will make sure it calls waitpid on any future children that die","width":1190.1818182468414},{"text":"so, we run into problems, though, when we have a long-running parent.","width":493.18181824684143},{"text":"so let's say you made a webserver","width":468.18181824684143},{"text":"well the parent tries to live forever, wheeeeee, it's going to keep going around, hey! lets just run forever, right?","width":525.1818182468414},{"text":"and I'm going to serve the web request. and for each web request, I make a new child","width":604.1818182468414},{"text":"so if we have it so that the child does the work, each web request, each HTTP request we might run into a problem now","width":602.1818182468414},{"text":"because the parent is making all these children and never cleans up after them","width":463.18181824684143},{"text":"so in this scenario, when you've got a long-running parent, you've got to remember to call wait() or waitpid()","width":633.1818182468414},{"text":"because if you don't, you'll have a whole lot of zombies","width":220.18181824684143},{"text":"you'll have a whole load of exit values and other meta information about the process thats still just lying around inside this system","width":593.1818182468414},{"text":"okay, so, you must remember to call waitpid() to clear up or to prevent zombies","width":1215.1818182468414},{"text":"okay, alright, so, we won't talk about signals today. instead, let's see if I've got some notes","width":804.1818182468414},{"text":"okay! right!","width":439.18181824684143},{"text":"just a heads up, we'll shortly be publishing this","width":324.18181824684143},{"text":"so, your assignment for this week is two-fold","width":299.18181824684143},{"text":"first of all, time to jump into android","width":282.18181824684143},{"text":"get the SDK and the NDK installed and working on say, your laptops","width":325.18181824684143},{"text":"or start using the lab if you don't have a laptop","width":307.18181824684143},{"text":"we want you to basically make something simple and [something] to get as many people as board with actually using the NDK/SDK if possible","width":565.1818182468414},{"text":"secondly, you'll be using fork() and exec() and the stuff we've seen today to make your own simple \"make\" program which we've called \"fake\" instead of \"make\"","width":783.1818182468414},{"text":"so, let's have fun with learning to program fork() and exec() and enjoy your weekend! thank you very much!","width":703.1818182468414},{"text":"questions come down and see me now or 5 minute coffee shop","width":128.18181824684143}],
];
